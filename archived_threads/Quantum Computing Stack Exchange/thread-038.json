{"question": "\nMy question is simple: does applying QAOA with a statevector simulation always result in a perfect solution?\nI'm trying to calculate the best \u03b3 & \u03b2 that solve certain problems but my statevector simulation of problem always finds the exact solution with a single stage (p=1) of QAOA.\nI know that in a in a real quantum device, the entire statevector isn't calculated (the whole point of quantum computing!) but rather multiple 'shots' are processed to build up a statistical picture.\nUsing these inputs, a typical solver like COBYLA won't work as well as they assume each function value they get is true. As such, getting the best possible \u03b3 & \u03b2 values is harder than when using the statevector simulation, which can get arbitarily close as this guide says. Is this where the need for multiple stages of the QAOA comes from? We cannot get as high quality angles with shot based simulators and so we need more stages ?\nI first noticed this when trying to solve the MIS problem using the statevector simulator in qiskit and was getting perfect results each time up to N=14 nodes, which seemed a little crazy. At first, I thought this was perhaps due to the QAOA being 'good' at this sort of problem and thought I would have to simulate at higher N's before more stages were needed. I then tried the same setup on a MAXCUT (N=12) problem and got the same outcome: QAOA always finding an optimum solution with just one stage. I know from this paper that multiple stages were needed for MAXCUT at the same region of N's (and graph complexity) and so this is what leads me to think QAOA evaluates perfectly when the entire statevector is calculated. Am I correct ?\nEDIT: I've included the Qiskit Code I've used to generate this.\nFor completion I've included all my code but the relevant bit is outside of all the functions. Here is what these functions do:\nweighted_erdos_graph generates an Erdos-Renyi graph using the standard networkx implementation with randomly weighted nodes. own_maximum_weighted_independent_set_qubo Is taken from D-Wave, and generates the QUBO for a given graph. This is in the form of a dictionary which convert_to_array converts to a numpy array for ease of manipulation.  the_auto_doco_mod (I had Wallace and Gromit on the mind...) takes this numpy array and converts this to a QuadracticProgram, with the binary variables interpretted as quadractics (I know this is a bit hacky, but it works).\nfrom qiskit import IBMQ, Aer, QuantumCircuit, ClassicalRegister, QuantumRegister, execute\nfrom qiskit.aqua import aqua_globals, QuantumInstance\nfrom qiskit.aqua.algorithms import QAOA, NumPyMinimumEigensolver\nfrom qiskit.optimization.algorithms import MinimumEigenOptimizer, RecursiveMinimumEigenOptimizer\nfrom qiskit.optimization import QuadraticProgram\nfrom qiskit.optimization.applications.ising.docplex import get_operator\nimport numpy as np\nfrom docplex.mp.model import Model\nfrom docplex.cp.expression import binary_var_list\n\n#########\u00a0Functions ####################\n\ndef own_maximum_weighted_independent_set_qubo(G, weight=None, lagrange=2.0):\n    \"\"\"Return the QUBO with ground states corresponding to a maximum weighted independent set.\n\n    Parameters\n    ----------\n    G : NetworkX graph\n\n    weight : string, optional (default None)\n        If None, every node has equal weight. If a string, use this node\n        attribute as the node weight. A node without this attribute is\n        assumed to have max weight.\n\n    lagrange : optional (default 2)\n        Lagrange parameter to weight constraints (no edges within set)\n        versus objective (largest set possible).\n\n    Returns\n    -------\n    QUBO : dict\n       The QUBO with ground states corresponding to a maximum weighted independent set.\n\n    Examples\n    --------\n\n    >>> from dwave_networkx.algorithms.independent_set import maximum_weighted_independent_set_qubo\n    ...\n    >>> G = nx.path_graph(3)\n    >>> Q = maximum_weighted_independent_set_qubo(G, weight='weight', lagrange=2.0)\n    >>> Q[(0, 0)]\n    -1.0\n    >>> Q[(1, 1)]\n    -1.0\n    >>> Q[(0, 1)]\n    2.0\n\n    \"\"\"\n\n    # empty QUBO for an empty graph\n    if not G:\n        return {}\n\n    # We assume that the sampler can handle an unstructured QUBO problem, so let's set one up.\n    # Let us define the largest independent set to be S.\n    # For each node n in the graph, we assign a boolean variable v_n, where v_n = 1 when n\n    # is in S and v_n = 0 otherwise.\n    # We call the matrix defining our QUBO problem Q.\n    # On the diagnonal, we assign the linear bias for each node to be the negative of its weight.\n    # This means that each node is biased towards being in S. Weights are scaled to a maximum of 1.\n    # Negative weights are considered 0.\n    # On the off diagnonal, we assign the off-diagonal terms of Q to be 2. Thus, if both\n    # nodes are in S, the overall energy is increased by 2.\n    cost = dict(G.nodes(data='node_weight', default=1))\n    scale = max(cost.values())\n    Q = {(node, node): min(-cost[node] / scale, 0.0) for node in G}\n    Q.update({edge: lagrange for edge in G.edges})\n\n    return Q\n\ndef weighted_erdos_graph(nodes, prob, seed =None):\n    \"\"\"Generates an erdos graph with weighted nodes\n    https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93R%C3%A9nyi_model\n    Node weights randomly assigned with the same seed as the erdos graph\n    \"\"\"\n    graph = nx.erdos_renyi_graph(n=nodes, p =prob, seed=seed, directed=False)\n    np.random.seed(seed)\n    graph_weights = np.random.randint(10,size = nodes)\n\n    for i in range(0,nodes):\n        graph.nodes[i][\"node_weight\"] = graph_weights[i]\n    #print(list(graph.nodes(data=True)))\n    return graph\n\n\ndef the_auto_doco_mod(qubo_array,model_name,constant):\n\n    \"\"\"\n\n    Function that takes the   QUBO array created for a graphing problem and converts it to a docplex model\n    ready for qiskit\n\n    Directly constructs the quadractic program with reference to this page\n    \"\"\"\n    number_of_variables = len(qubo_array[1]) # gets the number of variables from the length of the square qubo matrix\n    #mdl = Model('model_name')\n    mod = QuadraticProgram()\n\n    for variable in range(0,number_of_variables): # creates the binary variables from the size of the matrix\n        var_name = \"x_\" +str(variable)\n        mod.binary_var(name =var_name)\n\n    mod.minimize(quadratic =qubo_array)  # can put in all constraints as quadractic as the binary variables mean that x_0 ^ 2 = x_0 in both cases\n                                                    #\u00a0 not sure of the impact of this on performance however\n\n    print(mod.export_as_lp_string())\n\n    return mod\ndef convert_to_array(dictionary):\n    \"\"\"\n\n    Function to convert qubo dictionary from dwave into a numpy array \n\n    \"\"\"\n\n\n   ####### Generate the matrix ##########\n    key_list = dictionary.keys()\n    matrix_size= np.max([element[0] for element in key_list])  # gets the matrix size by taking the biggest number from the list of keys: a bit hacky but hey, it's 3 am\n    qubo = np.zeros((matrix_size +1, matrix_size +1))\n\n    ###### Adds diagonal values ######\n\n    for item in dictionary.items():\n\n        position = item[0]\n        value = item[1]\n\n\n        qubo[position] = value\n\n    return qubo\n\n################## Graph Generation, QUBO & QuadracticProgram Formulation #######\nerdos_14_7_456 = gp.weighted_erdos_graph(12,0.7,456)\nerdos_14_array=  convert_to_array(own_maximum_weighted_independent_set_qubo(erdos_14_7_456))\nqp = the_auto_doco_mod(erdos_14_array,'Erdos 14',2)\n\n\n######### Setting up the Statevector Simulator #######\n\naqua_globals.random_seed = np.random.default_rng(123)\nseed = 1456\nbackend = Aer.get_backend('statevector_simulator')\n\n\n###### Generating the Circuit #####\nquantum_instance = QuantumInstance(backend,seed_simulator=seed, seed_transpiler=seed)\n\n######## Algorithms ########\nqaoa = QAOA(quantum_instance=quantum_instance, p = 1)\nexact_mes = NumPyMinimumEigensolver()\n\n######### Applying the solvers ########\nqaoa_optimizer = MinimumEigenOptimizer(qaoa)\nexact = MinimumEigenOptimizer(exact_mes)\n\n##########\u00a0Results ########\nqaoa_result = qaoa_optimizer.solve(qp)\nprint(\"Qaoa\\n\",qaoa_result)\n\n\nnp_result = exact.solve(qp)\nprint(\"Numpy\\n\",np_result)\n\n\nThis gives the output:\n\nQaoa\n optimal function value: -2.2222222222222223\noptimal value: [0. 0. 0. 1. 1. 0. 1. 0. 0. 0. 0. 0.]\nstatus: SUCCESS\nNumpy\n optimal function value: -2.2222222222222223\noptimal value: [0. 0. 0. 1. 1. 0. 1. 0. 0. 0. 0. 0.]\nstatus: SUCCESS\n\n```\n\n", "answers": ["\nNo, solving QAOA with p=1 using pure-state simulation does not always result in a perfect solution. 'Perfect' is interpreted to imply preparation of a state that minimizes the expectation value, such that increasing p cannot yield a smaller value. Several analytic results show that increasing p will generally yield better solutions, eg, here and here, with results from pure-state simulations showing this to be true in practice, eg, here\nIntuitively, the depth p needs to be sufficiently large to walk the cycles of the graph. For the above example of a line graph with n=3, the depth p=1 suffices. But testing against larger graphs will confirm the expected behavior that increasing p improves the optimal solution quality.\n", "\nIt turns it out it sure doesn't. I was using the QAOA qiskit method and I think this function takes out the solution bitstring that gives the lowest objective value. As I was trying only for small N, there would be a decent probability attached to the solution even without the algorithm !\n"], "comments": [], "link": "https://quantumcomputing.stackexchange.com//questions/16275/statevector-simulation-of-qaoa-always-finds-exact-solution"}