{"question": "\nI'm using the following piece of python code:\nimport matplotlib.pyplot as plt\nfrom qiskit import *\nfrom qiskit.tools.visualization import plot_bloch_multivector, plot_histogram\n\nfrom qiskit import execute, IBMQ, BasicAer\nfrom qiskit.providers.ibmq import least_busy\nfrom qiskit.tools.monitor import job_monitor\n\nsecret_number = \"1010\"\nn = len(secret_number)\ncircuit = QuantumCircuit(n+1, n)\ncircuit.h(range(n))\ncircuit.x(n)\ncircuit.h(n)\ncircuit.barrier()\nfor i,v in enumerate(reversed(secret_number)):\n    if v==\"1\":\n        circuit.cx(i, n)\n\ncircuit.barrier()\ncircuit.h(range(n))\ncircuit.barrier()\ncircuit.measure(range(n), range(n))\nsimulator = Aer.get_backend(\"qasm_simulator\")\nsim_result = execute(circuit, backend=simulator, shots=4096).result()\n\n\nIBMQ.load_account()\nprovider = IBMQ.get_provider(\"ibm-q\")\n# qcomp = provider.get_backend(\"ibmq_16_melbourne\")\nqcomp = provider.get_backend(\"ibmq_burlington\")\njob = execute(circuit, backend=qcomp, shots=4096)\njob_monitor(job)\nreal_result = job.result()\ncounts = real_result.get_counts(circuit)\nimport collections\nc = collections.Counter(counts)\n\n# printing\nprint(circuit.draw())\nprint(\"result simulation:\")\nprint(sim_result.get_counts())\nprint(\"results (top 5):\")\nprint(c.most_common(5))\n\nThe results are shown here:\n\nAs you can see, the expected result is 1010, which is correctly the value that the quantum simulator gives me. However, I find this result on the fifth position for this execution in the real quantum computer. Is this due to noise? How can I get around this?\nAs complementary information, I tried the same code with secret_number = \"1011001\" and the ibmq_16_melbourne server. These are the results:\n\nAs you see. The error is amplified.\n", "answers": ["\nI am quite certain the problem here is noise. 2-qubit gates such as the CX gate are usually more prone to errors than single qubit gates like the Z gates. Also it really depends on when you run the code because with time these machines also get worse and need recalibration. As I write this answer the CNOT error rate in burlington is 2 orders of magnitude bigger than the error rate for the single qubit gate U2 which is the one probably used to implement the Z gates you useed in the second example.\n\nThe Oracle for the Bernstein algorithm can be implemented both using CX or Z gates. The CX gates make use of the Phase Kickback effect to create the same effect you can achieve with the Z gates (basically in this case a 180 degrees phase flip) so no black magic here. The issue is not in the gate itself but in the noise of the machines.\nIf you still do not believe you can try to copy the noise model from the burlington machine and apply it to the qasm simulator. You will see that you get also really messed up results in comparison to a noiseless run. Try plugging this to your code and see what happens (reference: https://qiskit.org/documentation/apidoc/aer_noise.html)\nfrom qiskit.providers.aer.noise import NoiseModel\n\nnoise_model = NoiseModel.from_backend(qcomp)\n# Get coupling map from backend\ncoupling_map = qcomp.configuration().coupling_map\n# Get basis gates from noise model\nbasis_gates = noise_model.basis_gates\n\nnoisy_result = execute(circuit, Aer.get_backend('qasm_simulator'),\n                 coupling_map=coupling_map,\n                 basis_gates=basis_gates,\n                 noise_model=noise_model,\n                 shots=4096).result()\n\nprint(noisy_result.get_counts())\n\nI got the following counts:\n{'0010': 178, '0001': 2, '1000': 316, '1111': 2, '0011': 7, '0110': 1, '1001': 16, '1101': 1, '1100': 4, '1110': 49, '1010': 3331, '0000': 39, '1011': 150}\n\nThese results are still better than the results you posted but I'm quite certain the issue here is in the noise and the fact that the first implementation is using CX gates and therefore will experience more trouble than the second one.\nYou can also try playing with this: https://qiskit.org/textbook/ch-quantum-hardware/measurement-error-mitigation.html and see if you get any improvements there.\nHope this is helpful ;)\nedit\nI'm not personally aware of other tricks you could play with the hardware here and I've had bad experiences with Burlington in the past as well. You probably can't apply any repetition code either (https://qiskit.org/textbook/ch-quantum-hardware/error-correction-repetition-code.html) because you'd need three times more qubits and Burlington has only 5 so I really feel there's nothing you can do to work around this using that specific device. \n", "\nThis is a partial answer, in case somebody is having the same issue as I.\nMy code was based on this IBM tutorial video but with the implementation in the real computer, for the video they use the description of the oracle with CX gate. However in the documentation's example, they use the Z gate for reasons that are still unclear to me, since I'm still learning and I don't have the necessary background. Thus, on the question's code, it suffice to replace circuit.cx(i, n) with circuit.z(i) and then you can see the magic in the following picture:\n\nThe reason why CX gate doesn't work is still unclear to me. It would be nice if anyone can provide some clarification. \n"], "comments": ["Does this section of the textbook help? qiskit.org/textbook/ch-quantum-hardware/\u2026", "Thank you @met927 , the problem apparently was not noise. I provided an answer. I remains unclear to me the real reason the CX gate doesn't work.", "You have only four qubits in your register. How are you getting seven bits out?", "the program initializes the needed gates depending on the length of the variable secret_number.", "Thanks @dncolomer, it's really informative. I didn't know about the U2 error rate. As I said, I'm pretty new in this domain (I just recently studied the coursera course on quantum computing and the youtube courses of quantum mechanics). Well, in the end it's actually en error, which was kind of expected due to the difference between the simulation.", "It's an amazing subject isn't it!? :) happy my answer brought some clarity. I'm not an expert either but I've seen how unpredictable noise can be in some of the smaller devices :)"], "link": "https://quantumcomputing.stackexchange.com//questions/11575/bernstein-vazirani-ibmq-error-due-to-probably-measurements?r=SearchResults"}