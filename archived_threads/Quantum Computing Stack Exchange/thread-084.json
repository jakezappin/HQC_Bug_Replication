{"question": "\nWhen performing a VQE algorithm, the electronic problem Hamiltonian of the physical system under study needs to be mapped to a qubit Hamiltonian written as a sum of tensor products of Pauli operators (X, Y, Z) and the Identity operator forming the so-called Pauli strings. When measuring the expectation value of a Hamiltonian during running VQE calculation, it is desirable to group the list of Pauli strings into commuting subsets in order to minimize the number of measurements. I am trying to understand how this can be achieved in Qiskit. I have looked over the Qiskit code and the conclusions, to me at least, are a bit surprising. Here is the code I have used to run a\u00a0VQE calculation:\nfrom qiskit.algorithms.optimizers import SLSQP\nfrom qiskit.primitives import Estimator\nfrom qiskit_nature.second_q.algorithms.ground_state_solvers import GroundStateEigensolver, VQEUCCFactory\nfrom qiskit_nature.second_q.circuit.library.ansatzes import UCC\nfrom qiskit_nature.second_q.drivers import PySCFDriver\nfrom qiskit_nature.second_q.formats.molecule_info import MoleculeInfo\nfrom qiskit_nature.second_q.mappers import JordanWignerMapper, ParityMapper, QubitConverter\nfrom qiskit_nature.second_q.algorithms.initial_points import HFInitialPoint\n\nqubit_converter = QubitConverter(ParityMapper(), two_qubit_reduction=True)\n\nmolecule = MoleculeInfo([\"H\", \"H\"], [(0.0, 0.0, 0.0), (0.0, 0.0, 0.74)])\n\ndriver = PySCFDriver.from_molecule(molecule, basis=\"sto3g\")\nelectronic_structure_problem = driver.run()\nsecond_quantized_hamiltonian = electronic_structure_problem.second_q_ops()\npauli_sum_operator = qubit_converter.convert(second_quantized_hamiltonian[0], num_particles=electronic_structure_problem.num_particles)\n\nnum_particles = electronic_structure_problem.num_particles\nnum_spatial_orbitals = electronic_structure_problem.num_spatial_orbitals\n\nucc = UCC(num_spatial_orbitals, num_particles, excitations='sd', qubit_converter=qubit_converter)\nvqe_factory = VQEUCCFactory(Estimator(), ucc, SLSQP(), initial_point = HFInitialPoint()) \u00a0\ngse = GroundStateEigensolver(qubit_converter, vqe_factory)\n\n# comment out line where solve method is invoked:\n# result = gse.solve(electronic_structure_problem)\n\n# the commented line above is actually calling:\nmain_operator, aux_ops = gse.get_qubit_operators(electronic_structure_problem)\nraw_mes_result = gse.solver.compute_minimum_eigenvalue(main_operator, aux_ops)\nprint(\"\\n grouping type: \", main_operator.grouping_type)\n\nThis is pretty much generic Qiskit code. I might be wrong here but, it looks to me that when running this piece of code, no grouping algorithm is applied by default to the Pauli strings. The last print statement in the code above outputs: 'None'. Also, I cannot find an obvious way to select a grouping method. How can one do that? It would be great if somebody could provide an answer along with some pointers to the Qiskit code in order to understand what is actually going on.\nAfter a grouping method is applied when measuring the expectation value of Pauli terms, a rotation must be made to a basis where X and Y operators are changed into Zs in order to perform measurements on a real quantum computer, which typically makes measurements only in the Z basis. From looking at Qiskit code, I see two options for grouping: qubit-wise and a second graph based approach. After using the qubit-wise method, finding a rotation basis is rather easy. The downside is that the number of Pauli groups is relatively large. The other method produces a significantly smaller number of Pauli groups but finding a rotation basis is not so easy. I am wondering what is the computational cost for the second approach? Is it feasible for large molecules (100 orbitals) or is it one of those problems that grow exponentially with the Pauli weight of the list of Pauli strings (the maximum number of non-identity elements in a given spin operator)?\nQiskit code also makes reference to a so-called TPB (Tensor Product Basis) grouping method. What is this and how it relates to the discussion above?\nHere is the software version I am using:\n\n", "answers": ["\nThe Estimator primitive may group the operator paulis internally when computing the observable value of the operator and some offer control over that:\nThere are different Estimators from the various providers. Above you are using the reference primitive from Terra which computes classically with matrices etc. The Estimator from Aer has an abelian_grouping parameter, True, by default. The BackendEstimator from Terra has a similar parameter; this primitive simply wraps backend.run() for providers that do not have primitives. The IBM Runtime Estimator does grouping but does not expose any parameter to disable that.\n"], "comments": ["Any idea what kind of algorithm is using IBM Runtime for grouping Pauli terms? Cannot find this info in the code.", "They use a group_commuting method of the operator in quantum_info. github.com/Qiskit/qiskit-terra/blob/\u2026 You can see the method called if you look at the source code of either the Backend or Aer Estimator.", "Thank you! Both are using the qubit-wise commutation method, which scales w.r.t. no qubits as N^4. The other method for grouping supported by Qiskit should scale more favorably as N^3. It is true that after grouping the Pauli strings, one has to find a basis that diagonalizes the Pauli terms, which might be difficult computationally for larger molecules that can produce a large Pauli weight. Are you aware of any place in Qiskit where the second grouping method is actually used? I mean, the method exists in Qiskit and can be invoked as group_commuting() but I cannot find any actual usage.", "The only other Estimator logic is in the IBM Runtime - I do not know what is done for that but I imagine its likely the same."], "link": "https://quantumcomputing.stackexchange.com//questions/31833/how-grouping-of-pauli-strings-is-handled-in-qiskit-when-running-vqe?r=SearchResults"}