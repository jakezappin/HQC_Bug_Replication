{"question": "\nI've got the following quantum code using QISKit (based on hello_quantum.py):\nimport sys, os\nfrom qiskit import QuantumProgram, QISKitError, RegisterSizeError\n\n# Create a QuantumProgram object instance.\nQ_program = QuantumProgram()\ntry:\n    import Qconfig\n    Q_program.set_api(Qconfig.APItoken, Qconfig.config[\"url\"])\nexcept:\n    offline = True\n    print(\"WARNING: There's no connection with IBMQuantumExperience servers.\");\nprint(\"The backends available for use are: {}\\n\".format(\",\".join(Q_program.available_backends())))\nbackend = 'ibmqx5'\ntry:\n    # Create a Quantum Register called \"qr\" with 2 qubits.\n    qr = Q_program.create_quantum_register(\"qr\", 2)\n    # Create a Classical Register called \"cr\" with 2 bits.\n    cr = Q_program.create_classical_register(\"cr\", 2)\n    # Create a Quantum Circuit called \"qc\". involving the Quantum Register \"qr\"\n    # and the Classical Register \"cr\".\n    qc = Q_program.create_circuit(\"bell\", [qr], [cr])\n\n    # Add the H gate in the Qubit 0, putting this qubit in superposition.\n    qc.h(qr[0])\n    # Add the CX gate on control qubit 0 and target qubit 1, putting \n    # the qubits in a Bell state\n    qc.cx(qr[0], qr[1])\n\n    # Add a Measure gate to see the state.\n    qc.measure(qr, cr)\n\n    # Compile and execute the Quantum Program.\n    result = Q_program.execute([\"bell\"], backend=backend, shots=1024, seed=1)\n\n    # Show the results.\n    print(result)\n    print(result.get_data(\"bell\"))\n\nexcept QISKitError as ex:\n    print('There was an error in the circuit!. Error = {}'.format(ex))\nexcept RegisterSizeError as ex:\n    print('Error in the number of registers!. Error = {}'.format(ex))\n\nI set my APItoken in Qconfig.py as:\nAPItoken = 'XXX'\nconfig = {\n    'url': 'https://quantumexperience.ng.bluemix.net/api',\n}\n\nHowever, the code fails with the following error:\nThe backends available for use are: ibmqx2,ibmqx5,ibmqx4,ibmqx_hpc_qasm_simulator,ibmqx_qasm_simulator,local_qasm_simulator,local_clifford_simulator,local_qiskit_simulator,local_unitary_simulator\n\nERROR\nThere was an error in the circuit!. Error = 'QISkit Time Out'\n\nI've tested both ibmqx4 and ibmqx5, the same issue. I can see that they're active at /qx/devices.\nWhat does it mean? Does it mean the IBM Q server is down, or the program is too big to execute? Or there is something else going on? In other words, what should I do to run a simple Hello Quantum program on IBM quantum server?\n", "answers": ["\nYour job timed out, probably because of the queue being too long for the job to complete in the time allowed by default for .execute().\nBut you already know that, of course, because you have already written an excellent answer of your own. Nevertheless, I have some insights to add from battle hardened experience.\nI usually use this notebook to check on how busy a device is, and if it is active. Then I typically run jobs in the following way.\n    noResults = True\n    while noResults:\n        try: # try to run, and wait if it fails\n            executedJob = engine.execute([\"script\"], backend=backend, shots=shots, max_credits = 5, wait=30, timeout=600)\n            resultsVeryRaw = executedJob.get_counts(\"script\")\n            if ('status' not in resultsVeryRaw.keys()):\n                noResults = False\n            else:\n                print(resultsVeryRaw)\n                print(\"This is not data, so we'll wait and try again\")\n                time.sleep(300)\n        except:\n            print(\"Job failed. We'll wait and try again\")\n            time.sleep(600)\n\nThis uses try to manage any exceptions that might result. The program will just wait and try again rather than crash.\nIf we get to the point of successfully using .get_counts, the program then checks to see if it actually contains results. Or rather, it checks that the 'status' key is not present, for it is the harbinger of doom. If there is not proper results, the program again waits and tries again.\n", "\nAs per GitHub post, I had to increase the timeout for Q_program.execute(), for example:\nresult = Q_program.execute([\"bell\"], backend=backend, shots=1024, seed=1, timeout=600)\n\nThe reason is probably, that the queues are busy, so we need to tell QISKit to wait up to 10 minutes. This instruction is basically blocking the rest of the script and wait till the job is executed on the actual backend server and the results are returned.\n\nTo list details of the jobs which has been submitted, the following code can be used as proposed by @ajavadia:\nfrom qiskit import QuantumProgram\nimport Qconfig\n\nqp = QuantumProgram()\nqp.set_api(Qconfig.APItoken, Qconfig.config['url'])\n\n# Download details of all the jobs you've ever submitted (the default limit is 50).\nmy_jobs = qp.get_api().get_jobs(limit=999)\n\n# Filter down to get a list of completed jobs.\ndone_jobs = [j for j in my_jobs if j['status']=='COMPLETED']\n\n# Print the results for all of your completed jobs.\nfor j in done_jobs:\n    for q in j['qasms']:\n        print(q['qasm'])\n        print(q['result'])\n\n"], "comments": ["Dealing with timeouts is somewhat inevitable, unfortunately. As well as increasing how long it will wait, you could use exception handling to get it to try again."], "link": "https://quantumcomputing.stackexchange.com//questions/1247/there-was-an-error-in-the-circuit-error-qiskit-time-out?r=SearchResults"}