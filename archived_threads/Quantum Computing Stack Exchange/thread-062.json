{"question": "\nI am trying to create a portfolio optimization with the DWave Quantum Computer. I wrote some code trying to somehow reconstruct the following Ising model paper:\n\n\n\n\nAi is the maximum amount of money that can be invested in the i-th asset.\nB is the total budget.\nRi denote the random variable representing the return from asset i.\nThis is how I tried to code it:\n    import datetime\n    import pandas as pd\n    import fix_yahoo_finance as yf\n    import pandas_datareader.data as web\n    import numpy as np\n    import neal\n    import dimod\n    from dwave.system import DWaveSampler\n    import random\n    import hybrid\n    \n    def cov(a,b):\n        return a.cov(b)\n    \n    def hi(price, returns, cov):\n        #mean price\n        Ai = np.mean(price)\n    \n        #mean expected return\n        E = np.mean(returns)\n    \n        # hi = -(1/2)((1/3)*cov(Ri,Rj) + (1/3)Ai^2 - (1/3)E(Ri) - 2B(1/3)*Ai)\n        h = (-(1/2)*((1/3)*cov + (1/3)* (Ai ** 2) - (1/3)* E - 2*100*(1/3)*Ai))\n        return h\n    \n    yf.pdr_override()\n    \n    start = datetime.datetime(2018,1,3)       \n    end = datetime.datetime(2021,1,1)\n    all_data = {ticker: web.get_data_yahoo(ticker,start,end)\n              for ticker in ['AAPL','IBM','MSFT','GOOGL']}    #Note: GOOG has become GOOGL\n    price = pd.DataFrame({ticker:data['Adj Close']\n                        for ticker,data in all_data.items()})\n    volume = pd.DataFrame({ticker:data['Volume']\n                         for ticker,data in all_data.items()})\n    returns = price.pct_change()      #calculate the percentage of the price\n    \n    returns = returns.dropna()\n    \n    print(returns.tail())\n        \n    a = cov(returns['AAPL'], returns['IBM'])\n    b = cov(returns['IBM'], returns['MSFT'])\n    c = cov(returns['MSFT'], returns['GOOGL'])\n    d = cov(returns['GOOGL'], returns['AAPL'])\n    \n    apple = hi(price['AAPL'],returns['AAPL'], a)\n    ibm = hi(price['IBM'],returns['IBM'], b)\n    microsoft = hi(price['MSFT'],returns['MSFT'], c)\n    google = hi(price['GOOGL'],returns['GOOGL'], d)\n    \n    \n    sampler = neal.SimulatedAnnealingSampler()\n    \n    #qpu = DWaveSampler()\n    \n    h = {apple: 0.0, ibm: 0.0, microsoft: 0.0, google: 0.0}\n    #energy changes when bias value changes\n    J = {(apple, ibm): 0.0, (ibm, microsoft): 0.0, (google, apple): 0.0, (apple, microsoft): 0.0, (ibm, google): 0.0}\n    sampleset = sampler.sample_ising(h, J, num_reads=10, annealing_time=2000)\n    print(sampleset)\n\nAnd this is the output sampleset:\n\nI was wondering what the numbers on top meant, so the -224463.77916595488 1414.5773363996423 etc. and if this is correct\n", "answers": ["\nI am not familiar with the application you are trying to implement but see a general misunderstanding in the setting of the terms h_i and J_i,j . The numbers in the top of the output are the names of the variables you have defined. You are defining the values of the variables apple, ibm, microsoft, google as variable names. The setting of the biases h_i and coupling strengths J_i,j can be done as dictionaries. But you have to use strings as variable names (keys) and the term is the actual value. So instead of h[apple]=0.0, you need to use something like h[\"apple\"]=apple. The same goes for J_i,j.\nIn your current implementation all terms are set as 0.0 . This is why all \"solutions\" have an energy of zero and are trivially minimal.\n"], "comments": ["Thank you! I figured this out later haha, but now that I have confirmation, I know for sure."], "link": "https://quantumcomputing.stackexchange.com//questions/17680/what-do-the-numbers-in-the-ising-sampleset-mean?r=SearchResults"}