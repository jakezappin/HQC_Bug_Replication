{"question": "\nI have created a noise model which uses depolarizing error and I add it using the add to all qubits quantum error command. I also use readout error and add that using the add to all qubits readoute error command.\nWhen I've tested this noisemodel on a simple circuit I can successfully vary the amount of noise the circuit receives, however when I try to add it in to my VQE code which is the code from the QisKit textbook, when I increase the parameters there isn't a noticeable change.\nI was thinking this is because the VQE algorithm is already quite good at handling noise, however when I am increasing these parameters by a power of 10 there should be some sort of change.\nAny insight would be greatly appreciated.\nHere is my code for my simple example:\nfrom qiskit import QuantumCircuit, execute\nfrom qiskit import IBMQ, Aer\nfrom qiskit.visualization import plot_histogram\nfrom qiskit_aer.noise import NoiseModel\n\n# Build noise model from backend properties\nprovider = IBMQ.load_account()\nbackend = provider.get_backend('ibmq_quito')\nnoise_model = NoiseModel.from_backend(backend)\n\n# Get coupling map from backend\ncoupling_map = backend.configuration().coupling_map\n\n# Get basis gates from noise model\nbasis_gates = noise_model.basis_gates\n\n# Make a circuit\ncirc = QuantumCircuit(3, 3)\ncirc.h(0)\ncirc.cx(0, 1)\ncirc.cx(1, 2)\ncirc.measure([0, 1, 2], [0, 1, 2])\n\n# Perform a noise simulation\nresult = execute(circ, Aer.get_backend('qasm_simulator'),\n                 coupling_map=coupling_map,\n                 basis_gates=basis_gates,\n                 noise_model=noise_model).result()\ncounts = result.get_counts(0)\nplot_histogram(counts)\n\nThe reuslts from this are below\n\nI then created by own noisemodel with the following\nfrom qiskit import QuantumCircuit, execute, Aer\nfrom qiskit.visualization import plot_histogram\nimport qiskit_aer.noise as noise\nfrom qiskit.providers.aer.noise import QuantumError, ReadoutError\n\n# Error probabilities\nprob_1 = 0.02  # 1-qubit gate\nprob_2 = 0.2  # 2-qubit gate\n\n# Depolarizing quantum errors\nerror_1 = noise.depolarizing_error(prob_1, 1)\nerror_2 = noise.depolarizing_error(prob_2, 2)\n\n# Readout quantum errors\np0given1 = 0.1\np1given0 = 0.05\n\nReadoutError = ReadoutError([[1 - p1given0, p1given0], [p0given1, 1 - p0given1]])\n\n# Add errors to noise model\nnoise_model = noise.NoiseModel()\nnoise_model.add_all_qubit_quantum_error(error_1, ['u1', 'u2', 'u3'])\nnoise_model.add_all_qubit_quantum_error(error_2, ['cx'])\nnoise_model.add_all_qubit_readout_error(ReadoutError)\nprint(noise_model)\n# Get basis gates from noise model\nbasis_gates = noise_model.basis_gates\n\n# Make a circuit\ncirc = QuantumCircuit(3, 3)\ncirc.h(0)\ncirc.cx(0, 1)\ncirc.cx(1, 2)\ncirc.measure([0, 1, 2], [0, 1, 2])\n\n# Perform a noise simulation\nresult = execute(circ, Aer.get_backend('qasm_simulator'),\n                 basis_gates=basis_gates,\n                 noise_model=noise_model).result()\ncounts = result.get_counts(0)\nplot_histogram(counts)\n\nAnd I get the following:\n\nI can then change my parameters: prob_1, prob_2, p0given1 and p1given0\nIncreasing these increases my noise, decreasing these decreases my noise. This is what I wanted to achieve of having controllable noise. Then when I take this code over to my VQE code I add them to a noise model through the following:\nnoise_model1 = noise.NoiseModel()\nnoise_model1.add_all_qubit_quantum_error(error_1, ['u1', 'u2', 'u3'])\nnoise_model1.add_all_qubit_quantum_error(error_2, ['cx'])\nnoise_model1.add_all_qubit_readout_error(readout_error)\nsim_noise = AerSimulator(noise_model=noise_model1)\nqi = QuantumInstance(sim_noise,\n                    noise_model=noise_model1)\n\nThis then gives me the quantum instance which I can use in my VQE code. However all of my results are very similar even if I'm changing my probabilities massively. Even when I put the probabilities to almost no error it still acts as if I have set the probabilities to a very high error.\nBelow is my entire VQE code:\nNote: I am aware that I could nest my parameters increasing in size into a loop instead of using if statements, I've just done it this way to help me visualize.\nI also have 3 parameters p_reset,p_meas and p_gate1 which I used when testing a different type of \"quantum_error\" which also didn't help improving my results so these can be ignored. They aren't applied to the noisemodel.\nI also have tried with 'qasm_simulator' and AerSimulator, both give the same result and don't really change with changes in these parameters.\nfrom qiskit.algorithms import VQE\nfrom qiskit.algorithms import NumPyMinimumEigensolver\nfrom qiskit_nature.algorithms import (GroundStateEigensolver,\n                                      NumPyMinimumEigensolverFactory)\nfrom qiskit_nature.drivers import Molecule\nfrom qiskit_nature.drivers.second_quantization import (\n    ElectronicStructureMoleculeDriver, ElectronicStructureDriverType)\nfrom qiskit_nature.transformers.second_quantization.electronic import FreezeCoreTransformer\nfrom qiskit_nature.problems.second_quantization import ElectronicStructureProblem\nfrom qiskit_nature.converters.second_quantization import QubitConverter\nfrom qiskit_nature.mappers.second_quantization import ParityMapper\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom qiskit_nature.circuit.library import UCCSD, HartreeFock\nfrom qiskit.circuit.library import EfficientSU2\nfrom qiskit.algorithms.optimizers import COBYLA, SPSA, SLSQP\nfrom qiskit.opflow import TwoQubitReduction\nfrom qiskit import BasicAer, Aer\nfrom qiskit.utils import QuantumInstance\nfrom qiskit.utils.mitigation import CompleteMeasFitter\nfrom qiskit.providers.aer.noise import NoiseModel\nimport numpy as np\nfrom qiskit.providers.aer import AerSimulator\n\n# Importing standard Qiskit libraries\nfrom qiskit import QuantumCircuit, transpile, Aer, IBMQ\nfrom qiskit.providers.aer import QasmSimulator\n\ndef get_qubit_op(dist):\n    molecule = Molecule(\n        geometry=[ [\"H\", [0.0, 0.0, 0.0] ],\n                  [\"H\", [dist, 0.0, 0.0725] ]],\n        multiplicity=1,charge=0)\n\n    driver = ElectronicStructureMoleculeDriver(\n        molecule=molecule,\n        basis=\"sto3g\",\n        driver_type=ElectronicStructureDriverType.PYSCF)\n\n    problem = ElectronicStructureProblem(driver)\n\n    second_q_ops = problem.second_q_ops()  # Get 2nd Quant OP\n    num_spin_orbitals = problem.num_spin_orbitals\n    num_particles = problem.num_particles\n\n    mapper = ParityMapper()  # Set Mapper\n\n    hamiltonian = second_q_ops[0]  # Set Hamiltonian\n\n    # Do two qubit reduction\n    converter = QubitConverter(mapper,two_qubit_reduction=True)\n    reducer = TwoQubitReduction(num_particles)\n    qubit_op = converter.convert(hamiltonian)\n    qubit_op = reducer.convert(qubit_op)\n    return qubit_op, num_particles, num_spin_orbitals, problem, converter\n\nfrom qiskit.providers.aer.noise import pauli_error\nfrom qiskit import IBMQ\nfrom qiskit.providers.aer.noise import NoiseModel, ReadoutError\nfrom qiskit.providers.fake_provider import FakeMelbourne\nbackend = FakeMelbourne()\nfrom qiskit.providers.aer.noise import depolarizing_error\nnm_1 = NoiseModel.from_backend(backend)\nimport qiskit_aer.noise as noise\ndef custom_noise(idx): \n    # Error probabilities\n    if idx == 0:\n        prob_1 = 0.005  # 1-qubit gate\n        prob_2 = 0.01   # 2-qubit gate\n        p0_1 = 0.99\n        p1_0 = 0.005\n        p0 = 1 - p0_1\n        p1 = 1 - p1_0\n        p_reset = 0.015\n        p_meas = 0.01\n        p_gate1 = 0.0125\n    elif idx == 1:\n        prob_1 = 0.05  # 1-qubit gate\n        prob_2 = 0.1   # 2-qubit gate\n        p0_1 = 0.9\n        p1_0 = 0.05\n        p0 = 1 - p0_1\n        p1 = 1 - p1_0\n        p_reset = 0.15\n        p_meas = 0.1\n        p_gate1 = 0.125\n    elif idx == 2:\n        prob_1 = 0.1  # 1-qubit gate\n        prob_2 = 0.2   # 2-qubit gate\n        p0_1 = 0.8\n        p1_0 = 0.1\n        p0 = 1 - p0_1\n        p1 = 1 - p1_0\n        p_reset = 0.3\n        p_meas = 0.2\n        p_gate1 = 0.35\n    elif idx == 3:\n        prob_1 = 0.15  # 1-qubit gate\n        prob_2 = 0.3   # 2-qubit gate\n        p0_1 = 0.6\n        p1_0 = 0.3\n        p0 = 1 - p0_1\n        p1 = 1 - p1_0\n        p_reset = 0.45\n        p_meas = 0.3\n        p_gate1 = 0.475\n    elif idx == 4:\n        prob_1 = 0.2  # 1-qubit gate\n        prob_2 = 0.4   # 2-qubit gate\n        p0_1 = 0.5\n        p1_0 = 0.4\n        p0 = 1 - p0_1\n        p1 = 1 - p1_0\n        p_reset = 0.60\n        p_meas = 0.4\n        p_gate1 = 0.6\n    print(prob_1,p0_1,p_reset)\n    #adding quantum error objects\n    '''\n    error_reset = pauli_error([('X', p_reset), ('I', 1 - p_reset)])\n    error_meas = pauli_error([('X',p_meas), ('I', 1 - p_meas)])\n    error_gate1 = pauli_error([('X',p_gate1), ('I', 1 - p_gate1)])\n    error_gate2 = error_gate1.tensor(error_gate1)\n    '''\n    \n    # Depolarizing quantum errors\n    error_1 = noise.depolarizing_error(prob_1, 1)\n    error_2 = noise.depolarizing_error(prob_2, 2)\n    \n    #Readout errors\n    readout_error = ReadoutError([[p0_1, p0], [p1_0, p1]])\n    \n    # Add errors to noise model\n    noise_model1 = noise.NoiseModel()\n   # noise_model.add_all_qubit_quantum_error(error_reset, \"reset\")\n   # noise_model.add_all_qubit_quantum_error(error_meas, \"measure\")\n   # noise_model.add_all_qubit_quantum_error(error_gate1, [\"u1\", \"u2\", \"u3\"])\n   # noise_model.add_all_qubit_quantum_error(error_gate2, [\"cx\"])\n   # noise_model.add_all_qubit_readout_error(readout_error)\n    noise_model1.add_all_qubit_quantum_error(error_1, ['u1', 'u2', 'u3'])\n    noise_model1.add_all_qubit_quantum_error(error_2, ['cx'])\n    noise_model1.add_all_qubit_readout_error(readout_error)\n    print(noise_model1)\n    \n    '''\n    noise_model = NoiseModel()\n    error = depolarizing_error(prob_1,1)\n    noise_model.add_all_qubit_quantum_error(error, ['u1', 'u2', 'u3'])\n    '''\n    backend1 = Aer.get_backend('qasm_simulator')\n    basis_gates = noise_model1.basis_gates\n    sim_noise = AerSimulator(noise_model=noise_model1)\n    qi = QuantumInstance(backend1,\n                         noise_model=noise_model1,\n                         basis_gates=basis_gates,\n                         measurement_error_mitigation_cls=CompleteMeasFitter)\n    return qi\n\ndef exact_solver(problem, converter):\n    solver = NumPyMinimumEigensolverFactory()\n    calc = GroundStateEigensolver(converter, solver)\n    result = calc.solve(problem)\n    return result\n\ndistances = np.arange(0.2, 2.5, 0.2)\n\nfor idx in range(0,5):\n    exact_energies = []\n    vqe_energies = []\n    optimizer = SLSQP(maxiter=100)\n    qi = custom_noise(idx)\n    for dist in distances:\n        (qubit_op, num_particles, num_spin_orbitals,\n                                 problem, converter) = get_qubit_op(dist)\n        result = exact_solver(problem,converter)\n        exact_energies.append(result.total_energies[0])\n        init_state = HartreeFock(num_spin_orbitals, num_particles, converter)\n        var_form = EfficientSU2(qubit_op.num_qubits, entanglement=\"linear\")\n        vqe = VQE(var_form, optimizer=optimizer, quantum_instance=qi)\n        vqe_calc = vqe.compute_minimum_eigenvalue(qubit_op)\n        vqe_result = problem.interpret(vqe_calc).total_energies[0].real\n        vqe_energies.append(vqe_result)\n        print(f\"Interatomic Distance: {np.round(dist, 2)}\",\n              f\"VQE Result: {vqe_result:.5f}\",\n              f\"Exact Energy: {exact_energies[-1]:.5f}\")\n    print(\"Energies for idx {} have been calculated\".format(idx))\n    plt.plot(distances, vqe_energies, label=\"VQE Energy index = {}\".format(idx))\n    \nprint(\"All energies have been calculated\")\nplt.plot(distances, exact_energies, label=\"Exact Energy\")\nplt.xlabel('Atomic distance (Angstrom)')\nplt.ylabel('Energy')\nplt.legend()\nplt.show()\n\nBelow are the results:\n\nThis shows that increasing the noise doesn't have the same affect as which it has on my simple example above.\n", "answers": [], "comments": ["Hi! Please show code examples, otherwise it will be difficult to help you", "@AlexeyUvarov Hello I have added some more detail for you.", "Thanks! So far, everything you've added looks okay. However, please also add your VQE code which you say doesn't work as intended.", "@AlexeyUvarov Thanks for the fast reply, I have added the code.", "@AlexeyUvarov I have also added the plot for you too.", "I'm afraid I don't see where exactly the problem is. Perhaps, to simplify the situation, you can try fixing some parameters of the ansatz, some atomic distance, and then see if the noise affects the output. Then if you don't see anything there you might move to VQE.", "@AlexeyUvarov Hey, I did something similar with just finding the minimum eigen state and increasing the noise with each iteration, this worked as it should with the result increasing every time the noise is increased. This means something is wrong with the VQE code which I don't know. However this is fine as I can finish my project without this piece of code now. Thanks for the help."], "link": "https://quantumcomputing.stackexchange.com//questions/29255/why-my-noise-model-acts-different-on-my-vqe-circuit-compared-to-a-simple-circuit?r=SearchResults"}