{"question": "\nSo I'm trying to replicate the results from Huang's paper, following Pennylane's tutorial. But instead of using Pennylane (in particular their recently implemented ClassicalShadow class), I'm trying to implement it in Qutip for individual purposes.\nThe generator function I'm implementing is, in essence, a line-by-line copy of the one in Pennylane's tutorial but in Qutip. The problem is, however, whenever I try to reconstruct any particular state as a benchmark for the code, the distance metrics are not improving at all.\nThis is the code\nimport numpy as np\nimport qutip as qt\nfrom qutip.qip.operations.gates import x_gate, y_gate, z_gate\nfrom qutip.measurement import measure, measure_observable\n\ndef gen_cshadow(state, csh_size, num_qubits):\n    '''\n    Qobj, int, int, list --> array\n    \n    This function takes as input a density matrix, prepared beforehand, and generates a minimal representation of it\n    called a classical shadow, which is a numpy array containing the information of the measurement result and the list index of\n    the applied single-qubit unitaries. The shape of the output array is determined by both csh_size,\n    the cardinality of the classical shadow, and num_qubits, the number of qubits in the multi-qubit system. This code is\n    an implementation of the protocol proposed in Nat. Phys. 16, 1050\u20131057 (2020) (10.1038/s41567-020-0932-7)\n\n    state: Density matrix, a qutip Qobj of shape (2**num_qubits, 2**num_qubits) and dimensions [[2,..., 2], [2,...,2]]\n    where the lists are of length num_qubits.\n\n    csh_size: Integer, defines the cardinality of the classical shadow.\n\n    num_qubits: Integer, defines the number of qubits of the system.\n    '''\n    # Initializing single-qubit Clifford gates (Random Pauli Basis)\n    unitaries = [x_gate, y_gate, z_gate]\n\n    # Uniform random sampling of the Pauli measurements\n    uts_ids = np.random.randint(0, len(unitaries), size = (csh_size, num_qubits), dtype = int)\n\n    # Initializing outcome array of shape csh_size x num_qubits\n    outcomes = np.zeros((csh_size, num_qubits))\n\n    for snapshot in range(csh_size):\n        # Extract the Pauli basis measurement\n        observables = [unitaries[uts_ids[snapshot, qb]](N = num_qubits, target = qb) for qb in range(num_qubits)]\n        outcomes[snapshot] = [measure_observable(state, observables[i])[0] for i in range(num_qubits)]\n\n    return outcomes, uts_ids\n\ndef snapshot_state(out_list, obs_list):\n    '''\n    DOCSTRING - TO DO\n    '''\n\n    num_qubits = len(out_list)\n\n    zero_state = np.array([[1, 0], [0, 0]])\n    one_state = np.array([[0, 0], [0, 1]])\n\n    phaze_z = np.array([[1, 0], [0, -1j]], dtype = complex)\n    hadamard = (1/np.sqrt(2))*np.array([[1, 1], [1, -1]])\n    identity = np.eye(2)\n\n    rotations = [hadamard, hadamard @ phaze_z, identity]\n\n    snapshot = [1]\n    for outcome, basis in zip(out_list, obs_list):\n        state = zero_state if outcome == 1 else one_state\n        U = rotations[basis]\n        local_state = 3 * (U.conj().T @ state @ U) - identity\n        snapshot = np.kron(snapshot, local_state)\n\n    return snapshot\n\ndef reconstruction(cshadow):\n    '''\n    DOCSTRING - TO DO\n    '''\n    cs_size, num_qubits = cshadow[0].shape\n    out_lists, obs_lists = cshadow\n\n    # State reconstruction\n    shadow_state = np.zeros((2 ** num_qubits, 2 ** num_qubits), dtype = complex)\n    for i in range(cs_size):\n        shadow_state += snapshot_state(out_lists[i], obs_lists[i])\n\n    return shadow_state / cs_size\n\nif __name__ == '__main__':\n    bell_state = qt.bell_state()\n    bell_state = qt.ket2dm(bell_state)\n    shadow = gen_cshadow(bell_state, 1000, 2)\n    sh_state = reconstruction(shadow)\n    print(sh_state)\n    pass\n\nNow let me explain what I think the code should be doing. Just like the tutorial, the first function is a generator of measurement outcomes for the individual qubits and the IDs of the respective observables. The idea of the for loop within that function is to provide a uniformly sampled measurement basis for each of the qubits per snapshot, thus the observables list is just creating the appropriate 2n\u00d72n matrices (n is the number of qubits) needed for each single-qubit operation.\nThe following line should be simulating a single-shot measurement (projective according to source) of the state \u03c1 in the measurement basis of the respective unitary, which I think is the same thing they do in the tutorial. The rest of the code is simply the reconstruction of the state using numpy.\nI have not been able to pinpoint what is wrong with the code, the only thing I can think of is that the first function is not generating what I think. Any help would be highly appreciated.\n", "answers": [], "comments": ["what is your output? how do you know your code is not generating the expected results?", "The output is the \"reconstruction\" of the state. The problem is, whenever I run the code this reconstruction is pretty much random. In principle, the snapshots are indeed random variables, but the variance should decrease as the number of snapshots increases, and so the reconstruction should improve. But my code is not doing that, the variance is not decreasing."], "link": "https://quantumcomputing.stackexchange.com//questions/32819/what-is-the-mistake-in-this-qutip-implementation-of-the-classical-shadows-protoc?r=SearchResults"}