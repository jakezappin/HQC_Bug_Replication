{"question": "\nI'm working with pennylane. My goal is to plot CFI(Classical Fisher Information)with following quantum state.\n\nWith the above equation I set gamma as 0. Then It becomes:\n\nIf gamma is not equal to zero, it needs to be normalized like: sqrt(coeff_0_state^2 + coeff_1_state^2)\nSo, I expect to get following plot.\n\nThe red line is the correct result when gamma = 0\nBut I got following\n\nWith the following code:\nimport pennylane as qml\nimport scipy as sp\nfrom pennylane import numpy as np\nfrom pennylane import math as m\nimport matplotlib.pyplot as plt\n\n\n# Variable for plot\nN = 1000\ntau_CFI = np.linspace(-0.001, 3.0, N)\n\n\n# == Generate coeff ==\ndef With_norm(theta, gamma):\n    coeff = np.array([ ((1+np.exp(-1.j * theta))/2) * (np.sqrt(1-gamma)) , (1-np.exp(-1.j * theta))/2 ]) / (1-gamma * (np.cos(theta)**2) ) \n    \n    norm = np.linalg.norm(coeff)\n    # norm_sp = sp.linalg.norm(coeff)\n    # norm_new = qml.math.sqrt(qml.math.real(coeff[0])**2 + qml.math.imag(coeff[0])**2 + qml.math.real(coeff[1])**2 + qml.math.imag(coeff[1])**2)\n    \n    # print(norm_new == norm)\n    # return norm\n    return coeff / norm\n\n\ndef Without_norm(theta):\n    gamma = 0\n    coeff = np.array([ ((1+np.exp(-1.j * theta))/2) * (np.sqrt(1-gamma)) , (1-np.exp(-1.j * theta))/2 ]) / (1-gamma * (np.cos(theta)**2) )\n    \n    norm_new = qml.math.sqrt(qml.math.real(coeff[0])**2 + qml.math.imag(coeff[0])**2 + qml.math.real(coeff[1])**2 + qml.math.imag(coeff[1])**2)\n    # norm = np.linalg.norm(coeff)\n    norm = 1\n    \n    return coeff / norm\n\n\n# With_norm(np.pi,0)\n\n# == Generate Q_node ==\n\ndev_with_norm = qml.device('default.qubit', wires = 1)\n@qml.qnode(dev_with_norm)\ndef circuit_with_norm(theta):\n    \n    qml.QubitStateVector(With_norm(theta, 0), wires=range(1))\n\n    \n    return qml.probs()\n    # return qml.density_matrix(wires=0)\n    \n    \ndev_without = qml.device('default.qubit', wires = 1)\n@qml.qnode(dev_without)\ndef circuit_without(theta):\n    \n    qml.QubitStateVector(Without_norm(theta), wires=range(1))\n\n    \n    return qml.probs()\n    # return qml.density_matrix(wires=0)\n    \n# circuit_without(np.pi/2)\n\n# == Compare with CFI plot ==\nN = 1000\ntau_CFI = np.linspace(-0.001, 3.0, N)\n\nCFI_without = np.zeros(N)\nCFI_with = np.zeros(N)\n\nfor i in range(len(tau_CFI)):\n    CFI_with[i] = qml.qinfo.classical_fisher(circuit_with_norm)(tau_CFI[i])\n    CFI_without[i] = qml.qinfo.classical_fisher(circuit_without)(tau_CFI[i])\n\nplt.subplot(211)\nplt.plot(tau_CFI, CFI_with)\nplt.title('With normalized')\nplt.xlabel('Time')\nplt.ylabel('Probability_0_state')\n# plt.legend()\nplt.grid()\n\n\nprint('== print out CFI ==')\nplt.subplot(212)\nplt.plot(tau_CFI, CFI_without)\nplt.title('Without normalized')\nplt.xlabel('Time')\nplt.ylabel('Probability_0_state')\nplt.grid()\n\n\n'With_normalized' I calculate the state vector coefficient with 'np.linalg.norm' for normalization. And 'Without_normalized' I normalized the coefficient just by dividing with constant 1.\nSince gamma = 0 they should be made the same result. But I don't know why the result of the CFI which is normalized by 'np.linalg.norm' shows different.(It should be constant 1)\nThanks in advance.\n", "answers": ["\nThere seems to be a bug in classical_fisher in combination with np.linalg.norm. I opened an issue here, should be resolved soon (fingers crossed). For the meantime I suggest you use np.sqrt(np.sum(np.abs(coeffs)**2)), this works as expected.\n"], "comments": ["Just to be sure, the expected output is a constant 1, as is the case for the without case? Looks like there is a problem in tracing the gradient through np.linalg.norm.", "Thanks for your help. I fixed with np.sqrt(np.sum(np.abs(coeffs)**2)) that you suggested to me."], "link": "https://quantumcomputing.stackexchange.com//questions/33993/problems-trying-to-plot-the-classical-fisher-information-with-pennylane?r=SearchResults"}