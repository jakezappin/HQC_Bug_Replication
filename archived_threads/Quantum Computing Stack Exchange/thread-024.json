{"question": "\nthe Question\nIs there a standard way to use deterministic errors (so, for instance, X_ERROR(1)) in Stim with PyMatching? Currently, sometimes if I use X_ERROR(1) in my circuit, my pymatching decoder fails with ValueError: maximum absolute edge weight of 16777215 exceeded.\nI apologize if there is an obvious solution in the docs. I wasn't able to find one.\nI think this failure makes sense because...\nSo using X_ERROR(1) sets \ud835\udc5d  = 1.\nReading what Craig explains here, \"Ultimately the ... error probability \ud835\udc5d becomes a weight \ud835\udc64=lg(\ud835\udc5d/(1\u2212\ud835\udc5d))\", it makes sense X_ERROR(1) would cause problems given that lg(1/(1-1)) is a weird divide-by-zero edge case*.\nAnd it looks like this is what is happening because, indeed, my matching graphs end up with an edge of weight: -inf.\nExample: [(0, None, {'fault_ids': set(), 'weight': -inf, 'error_probability': 1.0})] error.\nAnd I think this is why I get the ValueError: maximum absolute edge weight of 16777215 exceeded\n(In fact, I'm now confused why there are some circuits I can write with X_ERROR(1) that don't fail in pymatching.)\n*Technically, in that post, he's talking about how pymatching combines edges. I'm making the assumption that even a single edge probability will be converted into weight: \ud835\udc64=lg(\ud835\udc5d/(1\u2212\ud835\udc5d))\nHack-arounds ...\n\nRunning X_ERROR(0.99) does stop the error message but it makes doing fault enumeration a little weirder so I was hoping there would be another solution I just wasn't aware of.\n\nI can't use a normal X gate because I'm using DETECTORs (per documentation DETECTORs will treat X differently from X_ERROR(1))\n\n\nA minimum failing example:\n###### imports \nimport stim \nimport pymatching \nimport numpy as np\n\n###### Boilerplate decompose, run, and decode circuit function \ndef run_decode(circuit, num_shots):\n    model = circuit.detector_error_model(decompose_errors=True)\n    matching = pymatching.Matching.from_detector_error_model(model)\n    sampler = circuit.compile_detector_sampler()\n    syndrome, actual_observables = sampler.sample(\n        shots=num_shots, separate_observables=True)\n    predicted_observables = matching.decode_batch(syndrome)\n    error_rate = np.sum(np.any(predicted_observables !=\n                        actual_observables, axis=1))/num_shots\n\n    return error_rate\n\n\n###### FAILING FUNCTION \ncirc = stim.Circuit(\"\"\"R 0\nX 0\nX_ERROR(1) 0\nM 0 \nDETECTOR rec[-1]\"\"\")\n\nrun_decode(circ, 10_000)\n\n\nThe edges of the matching graph here look like:\n[(0, None, {'fault_ids': set(), 'weight': -inf, 'error_probability': 1.0})] and the code fails with:\nValueError: maximum absolute edge weight of 16777215 exceeded.\nPlease let me know if you need anymore information. I'll be happy to respond.\n", "answers": ["\nIf you're trying to enumerate how errors are corrected, you shouldn't be telling pymatching which errors you are inserting. It will just end up correcting them perfectly (once this probability 1 crashing bug is fixed), because you've told it exactly which errors have happened by giving it a model that contains exactly those errors with probability 1.\nWhat you should do is make one version of the circuit that has a normal noise model. Derive the detector error model given to pymatching from that variant of the circuit. Then have a second variant of the circuit with only your forced errors. Use that to generate the detection event samples given to pymatching.\n"], "comments": ["Okay, that makes a lot of sense. Thank you!"], "link": "https://quantumcomputing.stackexchange.com//questions/32560/using-deterministic-errors-in-stim-detector-circuit-and-decoding-with-pymatching/32561?r=SearchResults#32561"}