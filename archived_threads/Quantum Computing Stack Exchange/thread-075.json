{"question": "\nEdit: Improved code a bit\nEdit 2: After corresponding with a Qiskit developer, this issue was considered not a bug per se but a missing functionality that has not yet been implemented (and will be difficult to do so). The proscribed solution is to not transpile partial circuits. In practice I find one can transpile partial circuits then check for qubit identity swapping and fix as needed. The correspondence is here: https://github.com/Qiskit/qiskit-terra/issues/7472\nThis is a condensed description of the IBM bug that was a problem here, to make it more clear.\nThe following code compiles to a correct circuit when the measurement is present, but not when the measurement is absent:\nfrom qiskit.compiler import transpile\nfrom qiskit import QuantumCircuit, IBMQ\nprovider = IBMQ.load_account()\nlima = provider.get_backend('ibmq_lima')\nn_q = 3\nqc_foo = QuantumCircuit(n_q, n_q)\nqubit_list = [0,1,2]\nqc_foo.swap(0,1)\nqc_foo.swap(0,2)\nqc_foo.barrier()\nqc_foo.measure(qubit_list, qubit_list)\nqc_foo_trans = transpile(qc_foo, backend=lima, optimization_level=3\n                         , initial_layout=qubit_list, seed_transpiler=101)\nqc_foo_trans.draw()\n\nWith measurement the circuit is:\n\nAnd without measurement (comment out .measure line in code):\n\nNotice the latter circuit is not equivalent to the intended circuit. The reason is that in both cases part of the work is moved to the measurements by swapping them i.e. q1->c0 and q0->c1. But when there are no measurements, that extra work disappears and the final qubit identities are wrong. It is further strange that a barrier does not stop this in either case.\nThis is an especially big problem when trying to perform a circuit multiple times in a row before measurement. In that case the circuit itself has to be correct, and simple solutions like remapping state prep or measurements won't help.\n(This is mostly a bug report, to make the problem more visible to Qiskit contributors. But temporary solutions are welcome.)\n", "answers": ["\nThis looks like expected behavior by optimizer at level 3. Whatever backend you chose, level 3 is noise-adaptive, and most probably qubits chosen as 1 and 2 are the least noisy to perform the swap on, and later reinterpret the result during measurement.\nThe qubit identities are not wrong in itself - the optimizer/transpiler will remember its mapping of logical to physical qubits and adjust the code accordingly. So if ever you actually measure the result it would be correct as expected.\n", "\nI don't think Qiskit currently provides a straightforward way to exclude a certain transpiler pass.\nYou can construct a pass manager that contains only the passes you want then use it.\nmy_pass_manager = PassManager()\nmy_pass_manager.append(my_list_of_passes)\nqc_foo_trans = transpile(qc_foo, backend=lima, pass_manager=my_pass_manager)\n\nHowever, this would be a tedious task.\nA quicker solution is to monkey patch the transpiler pass (OptimizeSwapBeforeMeasure in your case) to alter its behavior\nfrom qiskit.transpiler.passes.optimization import OptimizeSwapBeforeMeasure\n\n# Monkey patching the transpiler pass class:\ndef doNothing(self, dag):\n    return dag\n\nOptimizeSwapBeforeMeasure.run = doNothing\n\n# Now, call transpile as usual\nqc_foo_trans = transpile(qc_foo, backend=lima, optimization_level=3)\n\n"], "comments": ["If this is intended behavior, there should at least be a way to turn it off without sacrificing gate optimization. What if someone wants to repeat a circuit ten times before measuring? It\u2019d be silly to input the 10x length circuit to the optimizer rather than optimize once and repeat, as the latter would both have fewer gates and take less compute time. But this qubit swapping bug makes optimizing the 1x circuit impossible, as it assumes I\u2019ll measure immediately rather than repeating and so swaps identities. Surely what I\u2019m describing is a common use case?", "Additionally \u2014 I don\u2019t think your claim is true that the qubit identities are remembered. When I add measurements later, the identities come out wrong."], "link": "https://quantumcomputing.stackexchange.com//questions/23458/qubit-identities-get-swapped-in-ibm-qiskit?r=SearchResults"}