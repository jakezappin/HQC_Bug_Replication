{"question": "\nI want to load a lognormal distribution and then use an IntegerComparator to flip a qubit (|0\u27e9|0\u27e9 to |1\u27e9|1\u27e9) if its value is less than a threshold. Then I want to use an Quantum Amplitude Estimation algorithm to calculate the probability of measuring |1\u27e9|1\u27e9.\nMy code so far is:\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom qiskit import Aer, QuantumCircuit, QuantumRegister, execute\nfrom qiskit.aqua.algorithms import IterativeAmplitudeEstimation\nfrom qiskit.circuit.library import LogNormalDistribution, IntegerComparator\n\n\n\nnum_uncertainty_qubits = 3\n\nS = 100\nvol = 0.4\nr = 0.04\nT = 3*(30/365)\n\n\nmu = np.log(S) + (r-0.5*vol**2)*T\nsigma = vol*np.sqrt(T)\n\nmean = np.exp(mu - 0.5*sigma**2)\nvariance = (np.exp(sigma**2)-1)*np.exp(2*mu + sigma**2)\nstddev = np.sqrt(variance)\n\nlow = np.maximum(0, mean-3*stddev)\nhigh = mean + 3*stddev\n\nuncertainty_model = LogNormalDistribution(num_uncertainty_qubits, mu=mu, sigma=sigma**2, bounds=(low, high))\n\n# 3 qubit LogNormalDistribution model\nuncertainty_model = LogNormalDistribution(3, mu=mu, sigma=sigma, bounds=(low, high))\n\n# function to create the quantum circuit of the IntegerComparator and the uncertainty model\n# x_eval is the threshold below which the qubit should be flipped\ndef get_cdf_circuit(x_eval):\n    qr_state = QuantumRegister(uncertainty_model.num_qubits, 'state')\n    qr_obj = QuantumRegister(1, 'obj')\n    qr_comp = QuantumRegister(2, 'compare')\n    state_preparation = QuantumCircuit(qr_state, qr_obj, qr_comp)\n    \n    state_preparation.append(uncertainty_model, qr_state)\n    comparator = IntegerComparator(uncertainty_model.num_qubits, x_eval, geq=False)\n    \n    state_preparation.append(comparator, qr_state[:]+qr_obj[:]+qr_comp[:])\n    \n    return state_preparation\n\n# Function to implement the Amplitude Estimation algorithm\n\ndef run_ae_for_cdf(x_eval, epsilon=0.01, alpha=0.05, simulator='qasm_simulator'):\n\n    state_preparation = get_cdf_circuit(x_eval)\n\n    ae_var = IterativeAmplitudeEstimation(state_preparation=state_preparation,\n                                          epsilon=epsilon, alpha=alpha,\n                                          objective_qubits=[len(qr_state)]) \n    result_var = ae_var.run(quantum_instance=Aer.get_backend(simulator), shots=100)\n    \n    return result_var['estimation']\n\nBroadly speaking, I want to flip the objective qubit to |1\u27e9|1\u27e9 if the state is less than or equal to x_eval.\nOn running this, I'm getting the same amplitude estimation every time, even when I use different threshold values.\nI'm missing something. Please help me out.\nPS: https://i.stack.imgur.com/tHyDM.jpg This is the link to the QuantumCircuit. P(X) is the LogNormalDistribution and Cmp is the comparator.\nPPS: Using LinearAmplitudeFunction to compare floating numbers:\ndef get_comparator(threshold, num_qubits, low, high):\n    breakpoints = [low, threshold]\n    offsets = [0,0]\n    slopes = [0,0]\n    f_min = 1\n    f_max = 0\n    objective = LinearAmplitudeFunction(\n        num_qubits,\n        slopes,\n        offsets,\n        domain=(low, high),\n        image=(f_min, f_max),\n        breakpoints=breakpoints\n    )\n    return objective\n\n", "answers": ["\nI think it would be also useful to see your Quantum Circuit using %matplotlib inline\nand qc.draw('mpl') to see whether all gates are correctly connected. I had a similar problem with QAE and figured out by using this method that the order of qubits I tried to append the IntegerComparator onto was wrong. Cheers\n", "\nI am also working with IterativeAmplitudeEstimation in qiskit. I was able to run QAE for 'Credit Analysis with Quantum Computing' as described in\nhttps://qiskit.org/documentation/tutorials/finance/09_credit_risk_analysis.html\nby preparing the quantum circuits from scratch. But when using the libraries as described on the page I got many errors (see below). I guess some of the libraries have simply just moved?\nFrom which library are you loading LogNormalDistribution? I use\nfrom qiskit.circuit.library import IntegerComparator\nfrom qiskit.aqua.algorithms.amplitude_estimators.iqae import IterativeAmplitudeEstimation\nfrom qiskit.aqua.components.uncertainty_models import NormalDistribution\nfrom qiskit.aqua.components.uncertainty_models import LogNormalDistribution\n\nI for example get the following error for LogNormalDistribution when I load the model from  qiskit.aqua.components.uncertainty_models\n__init__() got an unexpected keyword argument 'bounds'\n\nor 'LogNormalDistribution' object has no attribute 'num_qubits'\nI hope to get the libraries running to help you dig into your question.\n", "\nI had to exchange len(qr_state) with num_uncertainty_qubits in the code you posted\n    # in run_ae_for_cdf\n    ae_var = IterativeAmplitudeEstimation(state_preparation=state_preparation,\n                                          epsilon=epsilon, alpha=alpha,\n                                          objective_qubits=[num_uncertainty_qubits])\n\nbut then for me it seems to work just fine.\nThe output is\n# executing your script with python -i and then:\n>>> run_ae_for_cdf(1)\n0.03904972139433151\n>>> run_ae_for_cdf(3)\n0.35743729093195115\n>>> run_ae_for_cdf(6)\n0.8437041835749457\n>>> run_ae_for_cdf(70)\n0.9999743710958622\n\nYou have 3 qubits in your system so the largest integer you can represent is 7 (=23\u22121=23\u22121) so for values \u22658\u22658 the CDF should be 1. That's because the CDF F(x)F(x) is the probability of measuring a state smaller than xx:\nF(x)=Pr(measure any state\u00a0|i\u27e9\u00a0with\u00a0i\u2264x)F(x)=Pr(measure any state\u00a0|i\u27e9\u00a0with\u00a0i\u2264x)\nSince ii can reach 7 at most, we should see\nF(x)={some increasing function, if\u00a0x\u226471, if\u00a0x>7F(x)={some increasing function, if\u00a0x\u226471, if\u00a0x>7\nWith your code you can generate the following plot\n>>> from matplotlib import pyplot as plt\n>>> i = list(range(20))\n>>> f = [run_ae_for_cdf(val) for val in i]\n>>> plt.axhline(1, color=\"k\", linestyle=\"-\")  # the max we reach\n>>> plt.axvline(8, color=\"k\", linestyle=\":\")  # from here on it should be 1\n>>> plt.xlabel(\"x\")\n>>> plt.ylabel(\"CDF, $F(x)$\")\n>>> plt.show()\n\nwhich seems to meet what we expected.\n\n"], "comments": ["For me your code works, though I had to change len(qr_state) to 3 because qr_state is not globally defined. If I run run_ae_for_cdf for the values 2, 3 and 4 I obtain 0.129, 0.309 and 0.489, respectively. Can you post the entire code, including imports and how you call the function?", "I got rid of the individual quantum registers so that there isn't any confusion. And I changed len(qr_state) to  3. However, for all different x_eval values, I'm getting 1 as the output which shouldn't happen.", "@Cryoris I've uploaded the entire code. I just call run_ae_for_cdf(70) to check the code. PS: 70 is just an example, can be any integer value.", "For me your code works, see the output in the answer below :)", "I've added a link to the quantum circuit. Let me know what you think.", "What values are you selecting for mu=mu, sigma=sigma, bounds=(low, high)? If I use the default values and do not define particular values I get 0.113, 0.284, 0.464 for x_eval = [2, 3, 4].", "I updated the link to the decomposed quantum circuit diagram. I've also added the entire code. Let me know.", "Please note that with num_uncertainty_qubits = 3 you will only be able to reflect values up to 7. Your lower and upper bound, as well as the x_eval=70 are not within that limit. You either need to increase the number of uncertainty qubits or scale down your problem to be within that limit.", "This solves it. Thanks a lot for your help!", "Thanks for your answer. I imported the LogNormalDistribution from qiskit.circuit.library", "I reinstalled qiskit and now all libraries work perfectly. I use from qiskit.circuit.library import LogNormalDistribution from qiskit.circuit.library import WeightedAdder from qiskit.circuit.library import IntegerComparator from qiskit.aqua.algorithms import IterativeAmplitudeEstimation", "This is perfect. Also, is there any way to compare floating numbers in qiskit? I mean instead of the 7 that was taken in this example, can I use a float? I've added a code block where I tried implementing the same using LinearAmplitudeFunction with threshold as a floating number."], "link": "https://quantumcomputing.stackexchange.com//questions/15179/computing-the-cdf-with-qae-in-qiskit?r=SearchResults"}