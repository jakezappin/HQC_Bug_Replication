{"question": "\nI try to follow this to perform measurement error mitigation for calculating H2 energy with VQE. With some modification, I did the calculation on \"qasm_simulator\" with the noise model built from \"ibmq_santiago\". However, it does not seem to improve the result. Please see below. I tried a separate experiment, and for the computational basis, the error mitigation seems to work really well. So in principle I could have measured the expectation values of ZZ,XX, etc and the calibration matrix myself, followed by calculating the energy. However, I expect that \"VQE\" should be able to do these for me. So is there any way that we can improve it further?\nfrom qiskit.aqua.components.optimizers import COBYLA\nfrom qiskit.aqua import QuantumInstance\nfrom qiskit.circuit.library import TwoLocal\nfrom qiskit.aqua.algorithms import VQE, NumPyMinimumEigensolver\nfrom qiskit.aqua.operators import X, Y, Z, I\nfrom qiskit import Aer, IBMQ \nfrom qiskit.ignis.mitigation.measurement import CompleteMeasFitter\nfrom qiskit.providers.aer.noise import NoiseModel\n\nIBMQ.load_account()\nprovider = IBMQ.get_provider(group='open', project='main')\nbackend = provider.get_backend('ibmq_santiago')\n\n\nH2_op = (-1.052373245772859 * I ^ I) + \\\n        (0.39793742484318045 * I ^ Z) + \\\n        (-0.39793742484318045 * Z ^ I) + \\\n        (-0.01128010425623538 * Z ^ Z) + \\\n        (0.18093119978423156 * X ^ X)\n\nnpme = NumPyMinimumEigensolver()\nresult = npme.compute_minimum_eigenvalue(operator=H2_op)\nref_value = result.eigenvalue.real\nprint( 'reference result = ' , ref_value )\n\noptimizer = COBYLA  # COBYLA, L_BFGS_B, SLSQP \n\nvar_form = TwoLocal(rotation_blocks='ry', entanglement_blocks='cz')            \nHam_vqe = VQE(H2_op, var_form , optimizer(maxiter=1000) , include_custom=True ) \n\nnoise_model = NoiseModel.from_backend(backend)\n# Get coupling map from backend\ncoupling_map = backend.configuration().coupling_map\n# Get basis gates from noise model\nbasis_gates = noise_model.basis_gates\n\n\n# Noisy simulation\nquantum_instance = QuantumInstance( Aer.get_backend('qasm_simulator'),\n             coupling_map=coupling_map,\n             basis_gates=basis_gates,\n             noise_model=noise_model,\n             shots = 8192  )\n\nresult = Ham_vqe.run( quantum_instance )\n\nprint( 'noisy result = ' , result.eigenvalue.real )\nprint( 'noisy result - reference result = ' , result.eigenvalue.real-ref_value )\n\n# Noisy simulation with mitigation\n\nquantum_instance = QuantumInstance( Aer.get_backend('qasm_simulator'),\n             coupling_map=coupling_map,\n             basis_gates=basis_gates,\n             noise_model=noise_model,\n             shots = 8192 ,\n             measurement_error_mitigation_cls=CompleteMeasFitter , \n             cals_matrix_refresh_period=30 )\n\nresult = Ham_vqe.run( quantum_instance )\n\nprint( 'with mitigation, noisy result = ' , result.eigenvalue.real )\nprint( 'with mitigation, noisy result - reference result = ' , result.eigenvalue.real-ref_value )\n\nand the output is\nreference result =  -1.8572750302023824\nnoisy result =  -1.8406772338912365\nnoisy result - reference result =  0.016597796311145885\nwith mitigation, noisy result =  -1.841906128159805\nwith mitigation, noisy result - reference result =  0.015368902042577348\n\n", "answers": [], "comments": [], "link": "https://quantumcomputing.stackexchange.com//questions/15769/why-measurement-error-mitigation-does-not-seem-to-improve-the-result-of-vqe?r=SearchResults"}