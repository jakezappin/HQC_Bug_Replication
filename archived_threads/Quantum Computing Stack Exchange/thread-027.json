{"question": "\nSuppose I am given a parameterized quantum circuit in Qiskit: as an example, here I consider a ZZFeatureMap ansatz, commonly used for data embedding in quantum machine learning appications:\nfrom qiskit.circuit.library import ZZFeatureMap\n\nnum_features = 3\npqc = ZZFeatureMap(num_features, reps=1).decompose()\npqc.measure_all()\n\npqc.draw('mpl')\n\n\nWhat I want to do is to run nsims full simulations of the above circuit passing each time a different set of values to be assigned to the ansatz free parameters. Moreover, each single simulation has to be repeated a number of times equals to shots in order to get a statistically robust final outcome for the measurement operation.\nThe most straightforward way to do it in Qiskit should be something like the following:\nimport numpy as np\nfrom qiskit import Aer\n\nnsims = 1000\nshots = 2048\nparameter_values = np.random.rand(nsims, num_features)\n\nsimulator = Aer.get_backend('aer_simulator')\nfor vals in parameter_values:\n    job = simulator.run(pqc.assign_parameters(vals), shots=shots)\n\nHowever, on my local CPU, this took more than 10 seconds already. I guess that here the problem is that every time I call the assign_parameters method inside the loop, Qiskit is actually creating a deepcopy of the whole circuit to make the parameter binding possible.\nAnother possibility I tried out is based on the Sampler primitive, provided by Qiskit itself:\nfrom qiskit.primitives import Sampler\n\nsampler = Sampler()\ncircuits = [pqc] * nsims \njob = sampler.run(circuits, parameter_values, shots=shots)\n\nThis solution is slightly better that the first one but still it looks pretty slow and far from being optimal. So, how can I make it faster? Is there an efficient way that maybe leverages more advanced Qiskit features?\n", "answers": ["\nIf you're running simulations of circuits with few qubits (like your example above), the Sampler should be the fastest out-of-the-box method to run the circuit. It's internally relying on the Statevector class, which just applies the gates and computes the full statevector -- this has almost no overhead so it's fast for small circuit, but starting from say 10+ qubits or really deep circuits this is likely going to be slower than Aer.\nTo marginally speed this approach up you could try using putting the CX P(theta) CX sequence in a two-qubit gate with a to_matrix method, so the Statevector can apply the full block at once instead of 3 individual gates.\nIf you want to avoid the deep copy, which you correctly identified as the bottleneck, you could use a hacky approach:\n\nCreate the circuit with fixed values of the first simulation\nEvaluate the single circuit with the Sampler\nReplace the gate angles of the P gate by iterating over circuit.data, finding the PhaseGates and replacing PhaseGate.params with the new value\nGo to 2 :)\n\nThis is a bit hacky as you have to manually compute the gate angles and iterate over the circuit data -- but it avoids the expensive copy. FYI, we're currently working on making circuits lightweight and copies cheap, so in the future this is hopefully not going to be a problem anymore.\nI hope that helps!\n"], "comments": [], "link": "https://quantumcomputing.stackexchange.com//questions/31902/what-is-the-most-efficient-way-to-run-several-simulations-of-parameterized-quant?r=SearchResults"}