{"question": "\nLet's say we have the following circuit (picture and code shown below), and now the q0q0 is an ancilla qubit. If the system of interest has only two qubits, Is there a way to use only q1,2q1,2 as my ansatz and plug it into the built-in VQE in qiskit?\nA little more context is the following. I would like to realize a quantum circuit consists of a linear combination of two unitary operators, such as I+gI+g where II is the identity operator and gg is the translation operator that moves the qubits as q0\u2192q1,q1\u2192q2,q2\u2192q0q0\u2192q1,q1\u2192q2,q2\u2192q0. According to this paper, https://arxiv.org/abs/1202.5822, it is possible to do so with an ancilla qubit, see Fig. 1 and Eq. 3. But suppose I would like use the resulting circuit as a variational ansatz, how can I do that? If there is an approach to realize I+gI+g without ancilla qubit, I will be very happy to learn that!\nfrom qiskit.circuit import ParameterVector\nfrom qiskit import QuantumCircuit\ntheta = ParameterVector( 'theta' , 2 )\nqc = QuantumCircuit( 3 ) \nq = qc.qubits\nqc.h(q) \nqc.crx( theta[0] , q[0], q[1] )\nqc.cry( theta[1] , q[1], q[2] )\nqc.draw('mpl')\n\n\n", "answers": [], "comments": ["Qiskit's VQE() is extremely inflexible. However, nothing stops you from defining a function taking as input parameters theta[0] and theta[1] (simply as floats, with no ParameterVector involved) and returning the corresponding circuit, and then using scipy.minimize to find the minimum of this function. The only problem with such an approach is that you will generate a new circuit each time you change the parameters. In a real experiment, however, running a circuit is so slow, that this will be a negligible time overhead."], "link": "https://quantumcomputing.stackexchange.com//questions/15316/run-vqe-for-parametrized-quantum-circuit-with-ancilla-qubits?r=SearchResults"}