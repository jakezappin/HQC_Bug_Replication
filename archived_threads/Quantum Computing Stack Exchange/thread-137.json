{"question": "\nI am trying to implement VQE from the Qiskit to obtain the ground state of a very specific Hamiltonian that has been generated via a docplex minimized quadratic model. The model has been converted to an Ising Hamiltonian using Qiskit's Optimization module. The resultant Hamiltonian denoted by H is as follows:\nfrom qiskit.providers.aer import AerSimulator, QasmSimulator\nfrom qiskit.algorithms import VQE\nfrom qiskit.algorithms.optimizers import COBYLA \nfrom qiskit.circuit.library import TwoLocal\nfrom qiskit import *\nfrom qiskit.opflow import OperatorBase\nfrom qiskit.opflow import Z, X, I  # Pauli Z, X matrices and identity\nimport pylab\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nH =   504.0 * I^I^I^I^I^I^I^Z+1008.0 * I^I^I^I^I^I^Z^I+2016.0 * I^I^I^I^I^Z^I^I+504.0 * I^I^I^I^Z^I^I^I+1143.7999999999997 * I^I^I^Z^I^I^I^I+2287.6 * I^I^Z^I^I^I^I^I+4575.200000000001 * I^Z^I^I^I^I^I^I+1143.7999999999997 * Z^I^I^I^I^I^I^I+98.0 * I^I^I^I^I^I^Z^Z+196.0 * I^I^I^I^I^Z^I^Z+392.0 * I^I^I^I^I^Z^Z^I+49.0 * I^I^I^I^Z^I^I^Z+98.0 * I^I^I^I^Z^I^Z^I+196.0 * I^I^I^I^Z^Z^I^I+93.1 * I^I^Z^Z^I^I^I^I+186.2 * I^Z^I^Z^I^I^I^I+372.4 * I^Z^Z^I^I^I^I^I+46.55 * Z^I^I^Z^I^I^I^I+93.1 * Z^I^Z^I^I^I^I^I+186.2 * Z^Z^I^I^I^I^I^I\n\nbackend = QasmSimulator()\noptimizer = COBYLA(maxiter=2000)\nansatz = TwoLocal(num_qubits=8, rotation_blocks='ry', entanglement_blocks=None, entanglement='full', reps=1, skip_unentangled_qubits=False, skip_final_rotation_layer=False)\n# set the algorithm\nvqe = VQE(ansatz, optimizer, quantum_instance=backend)\n\n#run it with the Hamiltonian we defined above\nresult = vqe.compute_minimum_eigenvalue(H) \n\nThis however yields the error:\n'Circuit execution failed: ERROR:  [Experiment 0] QasmSimulator: Insufficient memory for 141-qubit circuit using \"statevector\" method. You could try using the \"matrix_product_state\" or \"extended_stabilizer\" method instead.'\n\nMy questions are:\n\nHow and why does my circuit yield 141 qubits when there are only 8 Pauli Operators in each term of my Hamiltonian? What am I missing conceptually?\nHow do we calculate the number of qubits required when solving this sort of problem?\n\n", "answers": ["\nEasy Fix:\nIt seems like it is because of the way you define HH. You need the parenthesis around each of the term!\nSo something like:\nH =    (504.0 * I^I^I^I^I^I^I^Z) + (1008.0 * I^I^I^I^I^I^Z^I) + ( 2016.0 *  I^I^I^I^I^Z^I^I)\n\nJust replace this in your code then it will work!\n\nAlternative (longer) way:\nHere I will offer another way to define the Hamiltonian in case you are curious. Instead of doing the above, if you replace it with something like:\nfrom qiskit.aqua.operators import *\npauli_terms = ['IIIIIIIZ', 'IIIIIIZI', 'IIIIIZII' ]\npauli_weights = [504.0, 1008.0, 2016.0]\npauli_dict = {'paulis': [{\"coeff\": {\"imag\": 0., \"real\": pauli_weights[i] }, \"label\": pauli_terms[i]} \\\n                         for i in range(len(pauli_terms))]}\nH = WeightedPauliOperator.from_dict(pauli_dict)\n\nThis should work. I just grabbed the first 3 entries of your Hamiltonian. Here is the full script for you to reproduce the result:\nimport numpy as np\nfrom qiskit.providers.aer import AerSimulator, QasmSimulator\nfrom qiskit.algorithms.optimizers import COBYLA \nfrom qiskit.circuit.library import TwoLocal\nfrom qiskit.aqua.operators import *\nfrom qiskit.aqua import set_qiskit_aqua_logging, QuantumInstance\nfrom qiskit.aqua.algorithms import NumPyMinimumEigensolver, VQE, NumPyEigensolver\nfrom qiskit.circuit import QuantumCircuit, ParameterVector\n\npauli_terms = ['IIIIIIIZ', 'IIIIIIZI', 'IIIIIZII' ]\npauli_weights = [504.0, 1008.0, 2016.0]\npauli_dict = {'paulis': [{\"coeff\": {\"imag\": 0., \"real\": pauli_weights[i] }, \"label\": pauli_terms[i]} \\\n                         for i in range(len(pauli_terms))]}\nHamiltonian = WeightedPauliOperator.from_dict(pauli_dict)\nansatz = TwoLocal(num_qubits=8, rotation_blocks='ry', entanglement_blocks=None, entanglement='full', reps=1, skip_unentangled_qubits=False, skip_final_rotation_layer=False)\nprint(ansatz)\nbackend = QasmSimulator()\nquantum_instance = QuantumInstance(backend,\n                                   shots = 8192,\n                                   initial_layout = None,\n                                   optimization_level = 3)  \n\noptimizer = COBYLA(maxiter= 100, tol=0.000000001)   \nvqe = VQE(Hamiltonian, ansatz, optimizer, initial_point= None , include_custom = False)\nprint('We are using:', quantum_instance.backend)\nvqe_result = vqe.run(quantum_instance)\nvqe_result['eigenvalue']\n\noutput:\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nq_0: \u2524 RY(\u03b8[0]) \u251c\u2500\u2524 RY(\u03b8[8]) \u251c\n     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\nq_1: \u2524 RY(\u03b8[1]) \u251c\u2500\u2524 RY(\u03b8[9]) \u251c\n     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u250c\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\nq_2: \u2524 RY(\u03b8[2]) \u251c\u2524 RY(\u03b8[10]) \u251c\n     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\nq_3: \u2524 RY(\u03b8[3]) \u251c\u2524 RY(\u03b8[11]) \u251c\n     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\nq_4: \u2524 RY(\u03b8[4]) \u251c\u2524 RY(\u03b8[12]) \u251c\n     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\nq_5: \u2524 RY(\u03b8[5]) \u251c\u2524 RY(\u03b8[13]) \u251c\n     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\nq_6: \u2524 RY(\u03b8[6]) \u251c\u2524 RY(\u03b8[14]) \u251c\n     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\nq_7: \u2524 RY(\u03b8[7]) \u251c\u2524 RY(\u03b8[15]) \u251c\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nWe are using: qasm_simulator\n\n(-3528+0j)\n\nAlthough I am not sure why you would have two consecutive layers of RYRY rotation though.\n"], "comments": ["This answer was godsent! Thank you so so much. We had been stuck since yesterday!", "No problem! :) I am glad I was able to help!", "Interesting, what is a reason for such behvior? Is it connected with operators priority?", "@MartinVesely I think so."], "link": "https://quantumcomputing.stackexchange.com//questions/17663/what-explains-my-anomalously-scaled-up-vqe"}