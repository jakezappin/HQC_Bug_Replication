{"question": "\nThe circuit which measures a Z-type stabilisers in the surface code is:\n\nwhereas for X-type stabilisers it's:\n\nBoth types of stabilisers are measured in a memory experiment in the inbuilt surface code circuits of Stim, which I am using by following the linux command line instructions for Sinter. Even though both types of stabilisers are measured for each memory experiment, the two extra hadamards for X-type stabiliser measurements (which detect Z errors) means they have higher depth. This causes a higher logical error rate in a memory experiment for memory X (preserving |+\u27e9L|+\u27e9L which is more affected by ZZ errors) than for memory Z (preserving |0\u27e9L|0\u27e9L which is more affected by XX errors). That is pLX>pLZpLX>pLZ.\nThe circuits I am using are stim's inbuilt surface code circuits. These measure both types of stabilisers for both types of memory experiment. See a distance 2, unrotated surface code with 1 round of stabiliser measurements below as an example (though for my simulations I am doing odd distances and dd rounds of stabiliser measurements).\nMemory Z prepares the data qubits in |0\u27e9\u2297n|0\u27e9\u2297n and measures them in the Z basis at the end (preserving |0\u27e9L|0\u27e9L):\n\nWhereas Memory X prepares the data qubits in |+\u27e9\u2297n|+\u27e9\u2297n and measures them in the X basis at the end (preserving |+\u27e9L|+\u27e9L):\n\nNote that these diagrams are without noise but for my simulations I am using a circuit noise model (setting all of Stim's inbuilt errors to pp).\nWhen making threshold curves for the rotated surface code using Stim's inbuilt circuits I see, as expected, that pLX>pLZpLX>pLZ. For example for distance 7 and 9 below pLX>pLZpLX>pLZ for each distance:\n\nOn the other hand for the unrotated surface code I am seeing the opposite. Instead of pLX>pLZpLX>pLZ I am seeing pLX<pLZpLX<pLZ I have triple checked that I am running and plotting the correct memory experiment type and can not figure out what is causing it. I have simulated every odd distance up to 15 and keep seeing pLX<pLZpLX<pLZ, as per the plots below:\n\n\nI am running the memory experiments from a linux command line following the instructions for Sinter here which are:\nmkdir -p circuits\npython -c \"\n\nimport stim\n\nfor p in [0.001, 0.005, 0.01]:\n    for d in [3, 5]:\n        with open(f'circuits/d={d},p={p},b=X,type=rotated_surface_memory.stim', 'w') as f:\n            c = stim.Circuit.generated(\n                rounds=d,\n                distance=d,\n                after_clifford_depolarization=p,\n                after_reset_flip_probability=p,\n                before_measure_flip_probability=p,\n                before_round_data_depolarization=p,\n                code_task=f'surface_code:rotated_memory_x')\n            print(c, file=f)\n\"\n\nsinter collect \\\n    --processes 4 \\\n    --circuits circuits/*.stim \\\n    --metadata_func \"sinter.comma_separated_key_values(path)\" \\\n    --decoders pymatching \\\n    --max_shots 1_000_000 \\\n    --max_errors 1000 \\\n    --save_resume_filepath stats.csv\n\nsinter plot \\\n    --in stats.csv \\\n    --group_func \"'Rotated Surface Code d=' + str(metadata['d'])\" \\\n    --x_func \"metadata['p']\" \\\n    --fig_size 1024 1024 \\\n    --xaxis \"[log]Physical Error Rate\" \\\n    --out surface_code_figure.png \\\n    --show\n\n", "answers": ["\nI don't know what's causing that inversion but...\n\nThe two extra hadamards for X-type stabilisers mean a higher depth circuit with more chance for an error, causing a higher logical error rate in a memory experiment for memory X\n\nThis is a very concerning sentence! It sounds like you're making a major error in your circuit. In order to protect unknown or entangled logical states, the memory circuit must be independent of the value of the logical qubit. Otherwise you haven't shown your memory circuit can preserve unknown states or entangled logical states. The only circuit detail that should differ, when changing the basis, is the initialization of the logical state at the very beginning and the measurement of the logical state at the very end. The bulk should be literally gate-for-gate detector-for-detector identical, for all logical bases. So the circuit depth should be identical for both memory experiment bases.\nDon't skip the X stabilizer measurements, even when performing a Z basis experiment. The X stabilizer measurements introduce noise, and spread the noise around, in ways that relevantly affect the overall logical error rate. To omit them is tantamount to p-hacking. Even if they \"don't matter\" for the state you happened to test.\n\nIf you actually aren't skipping the X stabilizer measurements, then my best guess for what's happening in your circuit is that there are hook errors creating the asymmetry. If you are measuring the X stabilizers in one step and Z stabilizers in another, and not doing a lot of rounds, the issue could be whether the step next to a time boundary is in the same basis or not. Look for anything in the circuit that would be different under exchange of X/Z and reflection around the appropriate diagonal line of symmetry. It's hard to say more without the actual circuits.\n"], "comments": ["Hi Craig, thanks for your answer - I am using Stim's inbuilt surface code circuits so both types of stabilisers are being measured. I have updated my question to clarify this"], "link": "https://quantumcomputing.stackexchange.com//questions/32877/inverted-memory-x-and-memory-z-logical-error-rates-for-unrotated-surface-code-in?r=SearchResults"}