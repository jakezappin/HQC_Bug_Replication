{"question": "\nI'm using pennylane.\nWhat I want to do is\n\nCreate a qnode with the 2*2 density matrix of a single qubit one. It has the parameter as phi\n\n\nGiven density matrix:\n1\u03b3cos(\u03c6)+(\u03b3\u22122)ett2((\u03b3\u22121)(ett2+cos(\u03c6))i\u221a1\u2212\u03b3sin(\u03c6)\u2212i\u221a1\u2212\u03b3sin(\u03c6)cos(\u03c6)\u2212ett2)1\u03b3cos(\u03c6)+(\u03b3\u22122)ett2\u239b\u239d\u239c(\u03b3\u22121)(ett2+cos(\u03c6))\u2212i1\u2212\u03b3\u2212\u2212\u2212\u2212\u221asin(\u03c6)i1\u2212\u03b3\u2212\u2212\u2212\u2212\u221asin(\u03c6)cos(\u03c6)\u2212ett2\u239e\u23a0\u239f\n\n\nPass is to qml.qinfo.classical_fisher(). I want to calculate classical fisher information respect to phi.\n\nBut the problem is that when I create qnode with density matrix and pass it to qml.qinfo.classical_fisher() it shows the following error:\nDeviceError: Gate QubitDensityMatrix not supported on device default.qubit.autograd\n\nIs there any possible method to define a qnode with a custom density matrix available to use with autograd?\nI tried to convert it to a state vector but since the density matrix is a mixed state it can't be converted to state vector.\nHere is my code:\nimport pennylane as qml\nfrom pennylane import numpy as np\n\nt1, t2, gamma = 1, 1, 0.5\n\n# Define the density matrix\ndef rho_ps(phi):\n    density_matrix_ps = np.array([\n        [(gamma - 1)*(np.exp(t1/t2) + np.cos(phi)), 1.j * np.sqrt(1-gamma)*np.sin(phi)],\n        [-1.j * np.sqrt(1-gamma)*np.sin(phi), np.cos(phi) - np.exp(t1/t2)]]) / (gamma*np.cos(phi) + (gamma-2)*np.exp(t1/t2))\n\n    return density_matrix_ps\n\nn_wires = 1\ndev = qml.device(\"default.qubit\", wires=n_wires)\n\n# Define the qnode with density matrix\n@qml.qnode(dev)\ndef circ(params):\n    density_matrix = rho_ps(params)\n    qml.QubitDensityMatrix(density_matrix, wires=0)  # Initialize the qubit with the density matrix\n\n    return qml.expval(qml.PauliZ(0))\n\n# Generate parameters used in classical fisher information\nparams = np.array([np.pi])\nCFIM = qml.qinfo.classical_fisher(circ)\n\nprint(CFIM)\n```\n\n", "answers": ["\nMy previous answer mistakenly read quantum_fisher instead of classical_fisher. It is actually possible to compute the latter with mixed states, but not the former.\nIt seems that there are three problems in your code:\n\nThe device you use should be default.mixed, since the density matrix you care about is mixed.\nparams should be differentiable, and should thus be created with requires_grad=True\nCFIM must be called on params, as it's a function\n\nAll in all, the following code gives you what you want (If I'm not mistaken):\nimport pennylane as qml\nfrom pennylane import numpy as np\n\nt1, t2, gamma = 1, 1, 0.5\n\n# Define the density matrix\ndef rho_ps(phi):\n    density_matrix_ps = np.array([\n        [(gamma - 1)*(np.exp(t1/t2) + np.cos(phi)), 1.j * np.sqrt(1-gamma)*np.sin(phi)],\n        [-1.j * np.sqrt(1-gamma)*np.sin(phi), np.cos(phi) - np.exp(t1/t2)]]) / (gamma*np.cos(phi) + (gamma-2)*np.exp(t1/t2))\n\n    return density_matrix_ps\n\ndev = qml.device(\"default.mixed\", wires=[0])\n\n@qml.qnode(dev)\ndef circ(params):\n    density_matrix = rho_ps(params)\n    qml.QubitDensityMatrix(density_matrix, wires=0)\n\n    return qml.expval(qml.PauliZ(0))\n\nparams = np.array([np.pi], requires_grad=True)\nCFIM = qml.qinfo.transforms.classical_fisher(circ)\nprint(CFIM(params))\n\n"], "comments": ["Thanks. I posted it on github link", "@Dongukkim I've realized that my previous answer wasn't right for your use case, as you want to use classical_fisher, and not the quantum one. I think it is doable in this case, please see my edited answer", "I just changed  \"defualt.qubit\" -> \"default.mixed\" as you mentioned and it just perfectly works. Thanks for excellent job!!!", "@Dongukkim Glad that helped!"], "link": "https://quantumcomputing.stackexchange.com//questions/34065/create-qnode-with-density-matrix-on-pennylane?r=SearchResults"}