{"question": "\nI like to use as custom Mixer Hamiltonian for solving the TSP using QAOA.\nThe mixer and cost hamiltonians are described here: https://arxiv.org/pdf/1709.03489.pdf - Chapter 5.1.\nTherefore I need to write the custom mixer hamiltonian from equations 54 -58.\nHere is the code:\nimport numpy as np\nfrom qiskit import Aer\nfrom qiskit.aqua import QuantumInstance\nfrom qiskit.quantum_info.operators import Operator, Pauli\nfrom qiskit.aqua.operators.list_ops import SummedOp\nfrom qiskit.aqua.algorithms import QAOA\nfrom qiskit.aqua.components.optimizers import SPSA\nfrom qiskit.optimization.applications.ising importtsp\n\n\ndef pauli(pos, num_qubits, label):\n    label = 'I'*(pos) + label + 'I'*(num_qubits-pos-1)\n    assert(len(label) == num_qubits)\n    return Operator(Pauli(label=label))\n\ndef s_plus(number_of_nodes, city, time):\n    num_qubits = number_of_nodes**2\n    qubit = time * number_of_nodes + city\n    return pauli(qubit, num_qubits, \"X\") + pauli(qubit, num_qubits, \"Y\")\n\ndef s_minus(number_of_nodes, city, time):\n    num_qubits = number_of_nodes**2\n    qubit = time * number_of_nodes + city\n    return pauli(qubit, num_qubits, \"X\") - pauli(qubit, num_qubits, \"Y\")\n\ndef create_mixer_operators(n):\n    \"\"\"\n    Creates mixer operators for the QAOA.\n    It's based on equations 54 - 58 from https://arxiv.org/pdf/1709.03489.pdf\n    Indexing here comes directly from section 4.1.2 from paper 1709.03489, equations 54 - 58.\n    \"\"\"\n    mixer_operators = []\n    for t in range(n - 1):\n        for city_1 in range(n):\n            for city_2 in range(n):\n                i = t\n                u = city_1\n                v = city_2\n                first_part = 1\n                first_part *= s_plus(n, u, i)\n                first_part *= s_plus(n, v, i+1)\n                first_part *= s_minus(n, u, i+1)\n                first_part *= s_minus(n, v, i)\n\n                second_part = 1\n                second_part *= s_minus(n, u, i)\n                second_part *= s_minus(n, v, i+1)\n                second_part *= s_plus(n, u, i+1)\n                second_part *= s_plus(n, v, i)\n                mixer_operators.append(first_part + second_part)\n    return mixer_operators\n\nseed = 10598\nn = 3\np = 2\nnum_qubits = n ** 2\n\n# Generate random tsp\nins = tsp.random_tsp(n, seed=seed)\n\nqubitOp, offset = tsp.get_operator(ins)\n\n# Running in quantum simulation\naqua_globals.random_seed = np.random.default_rng(seed)\nbackend = Aer.get_backend('qasm_simulator')\nquantum_instance = QuantumInstance(backend, seed_simulator=seed, seed_transpiler=seed)\nmixer = create_mixer_operators(n)\nmixer_op = SummedOp(mixer)\n\nspsa = SPSA(maxiter=300)\nqaoa = QAOA(operator=qubitOp, mixer=mixer_op, p=p, optimizer=spsa, quantum_instance=quantum_instance)\n\ncircuits = qaoa.construct_circuit([0]*(2*p))\n\nWhen runnning it I get:\n    ---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n<ipython-input-113-bd68aaa30bfc> in <module>\n----> 1 circuits = qaoa.construct_circuit([0]*(2*p))\n\n~/masterarbeit/code/venv/lib/python3.6/site-packages/qiskit/aqua/algorithms/minimum_eigen_solvers/vqe.py in construct_circuit(self, parameter)\n    358             A list of the circuits used to compute the expectation value.\n    359         \"\"\"\n--> 360         expect_op = self.construct_expectation(parameter).to_circuit_op()\n    361 \n    362         circuits = []\n\n~/masterarbeit/code/venv/lib/python3.6/site-packages/qiskit/aqua/algorithms/minimum_eigen_solvers/vqe.py in construct_expectation(self, parameter)\n    331             wave_function = self.var_form.assign_parameters(param_dict)\n    332         else:\n--> 333             wave_function = self.var_form.construct_circuit(parameter)\n    334 \n    335         # Expectation was never created, try to create one\n\n~/masterarbeit/code/venv/lib/python3.6/site-packages/qiskit/aqua/algorithms/minimum_eigen_solvers/qaoa/var_form.py in construct_circuit(self, parameters, q)\n     96 \n     97         evolution = EvolutionFactory.build(self._cost_operator)\n---> 98         circuit = evolution.convert(circuit)\n     99         return circuit.to_circuit()\n    100 \n\n~/masterarbeit/code/venv/lib/python3.6/site-packages/qiskit/aqua/operators/evolutions/pauli_trotter_evolution.py in convert(self, operator)\n    100         #     # Sort into commuting groups\n    101         #     operator = self._grouper.convert(operator).reduce()\n--> 102         return self._recursive_convert(operator)\n    103 \n    104     def _recursive_convert(self, operator: OperatorBase) -> OperatorBase:\n\n~/masterarbeit/code/venv/lib/python3.6/site-packages/qiskit/aqua/operators/evolutions/pauli_trotter_evolution.py in _recursive_convert(self, operator)\n    127                 return operator.primitive.__class__(converted_ops, coeff=operator.coeff)\n    128         elif isinstance(operator, ListOp):\n--> 129             return operator.traverse(self.convert).reduce()\n    130 \n    131         return operator\n\n~/masterarbeit/code/venv/lib/python3.6/site-packages/qiskit/aqua/operators/list_ops/list_op.py in traverse(self, convert_fn, coeff)\n    161             return ListOp([convert_fn(op) for op in self.oplist],  # type: ignore\n    162                           combo_fn=self.combo_fn, coeff=coeff, abelian=self.abelian)\n--> 163         return self.__class__([convert_fn(op) for op in self.oplist],  # type: ignore\n    164                               coeff=coeff, abelian=self.abelian)\n    165 \n\n~/masterarbeit/code/venv/lib/python3.6/site-packages/qiskit/aqua/operators/list_ops/list_op.py in <listcomp>(.0)\n    161             return ListOp([convert_fn(op) for op in self.oplist],  # type: ignore\n    162                           combo_fn=self.combo_fn, coeff=coeff, abelian=self.abelian)\n--> 163         return self.__class__([convert_fn(op) for op in self.oplist],  # type: ignore\n    164                               coeff=coeff, abelian=self.abelian)\n    165 \n\n~/masterarbeit/code/venv/lib/python3.6/site-packages/qiskit/aqua/operators/evolutions/pauli_trotter_evolution.py in convert(self, operator)\n    100         #     # Sort into commuting groups\n    101         #     operator = self._grouper.convert(operator).reduce()\n--> 102         return self._recursive_convert(operator)\n    103 \n    104     def _recursive_convert(self, operator: OperatorBase) -> OperatorBase:\n\n~/masterarbeit/code/venv/lib/python3.6/site-packages/qiskit/aqua/operators/evolutions/pauli_trotter_evolution.py in _recursive_convert(self, operator)\n    104     def _recursive_convert(self, operator: OperatorBase) -> OperatorBase:\n    105         if isinstance(operator, EvolvedOp):\n--> 106             if not {'Pauli'} == operator.primitive_strings():\n    107                 logger.warning('Evolved Hamiltonian is not composed of only Paulis, converting to '\n    108                                'Pauli representation, which can be expensive.')\n\n~/masterarbeit/code/venv/lib/python3.6/site-packages/qiskit/aqua/operators/evolutions/evolved_op.py in primitive_strings(self)\n     53 \n     54     def primitive_strings(self) -> Set[str]:\n---> 55         return self.primitive.primitive_strings()  # type: ignore\n     56 \n     57     @property\n\n~/masterarbeit/code/venv/lib/python3.6/site-packages/qiskit/aqua/operators/list_ops/list_op.py in primitive_strings(self)\n    126 \n    127     def primitive_strings(self) -> Set[str]:\n--> 128         return reduce(set.union, [op.primitive_strings() for op in self.oplist])\n    129 \n    130     @property\n\n~/masterarbeit/code/venv/lib/python3.6/site-packages/qiskit/aqua/operators/list_ops/list_op.py in <listcomp>(.0)\n    126 \n    127     def primitive_strings(self) -> Set[str]:\n--> 128         return reduce(set.union, [op.primitive_strings() for op in self.oplist])\n    129 \n    130     @property\n\nAttributeError: 'Operator' object has no attribute 'primitive_strings'\n\nHow do I resolve the error? This is my first project with qiskit and I am not sure where to start.\n", "answers": ["\nOperator is part of Qiskit-Terra's module quantum-info. You should use PrimitiveOp from Qiskit-Aqua.\nfrom qiskit.aqua.operators import PrimitiveOp\n\ndef pauli(pos, num_qubits, label):\n    label = 'I'*(pos) + label + 'I'*(num_qubits-pos-1)\n    assert(len(label) == num_qubits)\n    return PrimitiveOp(Pauli(label=label))\n\nNote however that for composing an Operator in Aqua with another you should use @ and * for multiplying with a scalar.\nEdit: Trying to explain the new error you are getting, i think the following is happening: At some point, the QAOA algorithm tries to build the parameterized circuit corresponding to your variatonal form as specified by the cost Hamiltonian and the mixer operator. However, the mixer is composite (defined with sums and compositions) and tries to reduce it. This causes the coeff (all Operators in Aqua have a coefficient) field to be a complex number. But then, since multiplication of a Parameter with a complex is not supported, an error is raising.\nA simpler example may be helpful in order to see what's going wrong.\nLet's say, we want to build a parameterized circuit corresponding to the evolution of X\u2297XX\u2297X operator (i.e e\u2212i\u03b2(X\u2297X)e\u2212i\u03b2(X\u2297X)). We will try two different ways. The second one will fail.\nfrom qiskit.circuit import Parameter\nfrom qiskit.aqua.operators import X, I, EvolutionFactory, EvolvedOp\n\ndef evolve(H):\n    beta = Parameter('\u03b2')\n    \n    evolution = EvolutionFactory.build(operator=beta * H)\n    eop = EvolvedOp(beta * H)\n    \n    return evolution.convert(eop)\n\n\nH = X ^ X\nprint(H.coeff)\nprint(type(H.coeff))\nevolve(H)\n---\n1.0\nfloat\nWorks\n\n\nH = (X ^ I) @ (I ^ X)\nprint(H.coeff)\nprint(type(H.coeff))\nevolve(H)\n---\n1+0j\ncomplex\nTypeError: unsupported operand type(s) for *: 'complex' and 'Parameter'\n\nPutting all this aside, as a workaround you could do the calculations on eq.58 (as already briefly explained on the orginal paper) and after eliminating some terms you get:\n12Hi,u,v=Xu,iXv,i+1Xu,i+1Xv,i\u2212Xu,iXv,i+1Yu,i+1Yv,i+Xu,iYv,i+1Xu,i+1Yv,i+Xu,iYv,i+1Yu,i+1Xv,i+Yu,iXv,i+1Xu,i+1Yv,i+Yu,iXv,i+1Yu,i+1Xv,i\u2212Yu,iYv,i+1Xu,i+1Xv,i+Yu,iYv,i+1Yu,i+1Yv,i12Hi,u,v=Xu,iXv,i+1Xu,i+1Xv,i\u2212Xu,iXv,i+1Yu,i+1Yv,i+Xu,iYv,i+1Xu,i+1Yv,i+Xu,iYv,i+1Yu,i+1Xv,i+Yu,iXv,i+1Xu,i+1Yv,i+Yu,iXv,i+1Yu,i+1Xv,i\u2212Yu,iYv,i+1Xu,i+1Xv,i+Yu,iYv,i+1Yu,i+1Yv,i\nand implement this operator as your mixer (sum of 8 PauliOps).\nFor convenience, here is my implementation.\nfrom itertools import combinations\n\ndef mixer_operators(n):\n    \n    mixer = []\n    n_qubits = pow(n, 2)\n    \n    for i in range(n - 1):\n        for u, v in combinations(range(n), 2):\n                \n                qu = i * n + u\n                qv = i * n + v\n                \n                x = [0] * n_qubits\n                x[qu] = x[qv] = x[qu + n] = x[qv + n] = 1\n                \n                Hi = 0\n                \n                # XXXX term\n                z = [0] * n_qubits\n                pauli = Pauli(z, x)\n                pauli = PrimitiveOp(pauli)\n                \n                Hi += pauli\n                \n                \n                # YYYY term\n                z = [0] * n_qubits\n                z[qu] = z[qv] = z[qu + n] = z[qv + n] = 1\n                pauli = Pauli(z, x)\n                pauli = PrimitiveOp(pauli)\n                \n                Hi += pauli\n                \n                \n                # XXYY and similar terms (two Ys)\n                for q0, q1 in combinations([qu, qv, qu + n, qv + n], 2):\n                    z = [0] * n_qubits\n                    z[q0] = z[q1] = 1\n                    pauli = Pauli(z, x)\n                    \n                    coeff = 1\n                    if (q0, q1) in [(qu, qv), (qu + n, qv + n)]:\n                        coeff = -1                \n                    pauli = PrimitiveOp(pauli, coeff)\n                    \n                    Hi += pauli\n                \n                \n                mixer.append(2 * Hi)\n                \n    return SummedOp(mixer)\n\n"], "comments": ["You didn't define tsp  anywhere in your code. Could you also post complete error message?", "I updated the post as requested", "Thank you, changing the code according to your solution worked, however I run into the next error I dont understand. When running      result = qaoa.run(quantum_instance)  I get      TypeError: unsupported operand type(s) for *: 'complex' and 'ParameterExpression'", "This error usually comes from an invalid mixer. Check e.g if your exponents are all imaginary.", "@NiklasPirnay In an effort to explain and overcome the new error, i edited my answer. Please, check if it's helpful.", "@Cryoris Your opinion would be valuable here. Maybe Aqua needs some improvement on this?"], "link": "https://quantumcomputing.stackexchange.com//questions/13992/custom-mixer-for-qaoa-error-operator-object-has-no-attribute-primitive-strin/13993?r=SearchResults#13993"}