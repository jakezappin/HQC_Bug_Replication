{"question": "\nBefore I start, I would like to say sorry for this possibly stupid question of mine.\nI just recently got into the topic of quantum computing and try me there.\nI'm currently trying to display a SU(2) rotation using Qiskit.\nfrom ibm_quantum_widgets import CircuitComposer\n\nfrom qiskit.quantum_info import Statevector\nfrom qiskit.visualization import plot_bloch_multivector\n\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\nfrom numpy import pi\nimport numpy as np\nfrom qiskit.quantum_info.operators import Operator, Pauli\n\n\n\nqreg_q = QuantumRegister(1, 'q')\ncircuit = QuantumCircuit(qreg_q)\n\nclreg = ClassicalRegister(1)\n\n...\n\nAfter the implementations, I tried to achieve such a rotation with some matrices.\nThis is one of them:\n\ndef rn_su2_5(theta, n1,n2,n3):\n    #This represents a matrix operator that will evolve() a Statevector by matrix-vector multiplication and will evolve() a DensityMatrix by left and right multiplication\n    return Operator([\n    [np.cos(theta/2)- 1j*n3*np.sin(theta/2), -1j*(n1-1j*n2)*np.sin(theta/2)],\n    [-1j*(n1+1j*n2)*np.sin(theta/2), np.cos(theta/2)+1j*n3*np.sin(theta/2)]\n    ],input_dims=(2, 1), output_dims=(2, 1))\n\nprint(rn_su2_5(pi,1,1,1))\ncircuit.unitary(rn_su2_5(pi,1,1,1),0)\n\nOutput:\nOperator([[ 6.123234e-17-1.j, -1.000000e+00-1.j],\n          [ 1.000000e+00-1.j,  6.123234e-17+1.j]],\n         input_dims=(2, 1), output_dims=(2, 1))\n\n**ExtensionError: 'Input matrix is not unitary.'**\n\nI would be very happy if you could help me with this problem.\nLater the rotation should also be visible on a Blochsphere.\nIf the code is not sufficient, I will submit it later if necessary.\n", "answers": ["\nThe problem is that the vector n=[n1,n2,n3] must have an magnitude (length) of 11, see for example this document (page 8, equation 50).\nI implemented a debug line that shows you wether the matrix is unitary or not. When choosing n=[0,0,1] or n=[1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)] the matrix becomes unitary.\n# Matrix taken from\n# https://docplayer.org/117986458-Die-symmetriegruppen-so-3-und-su-2.html (p. 11, equation 46)\n# https://www.uni-muenster.de/Physik.TP/archive/fileadmin/lehre/teilchen/ws1011/SO3SU2.pdf (p. 8, equation 50)\n\ndef rn_su2(theta, n):\n    n1 = n[0]\n    n2 = n[1]\n    n3 = n[2]\n    return Operator([\n        [np.cos(theta/2) - 1j*n3*np.sin(theta/2), -1j*(n1 - 1j*n2)*np.sin(theta/2)],\n        [-1j*(n1 + 1j*n2)*np.sin(theta/2), np.cos(theta/2) + 1j*n3*np.sin(theta/2)]\n    ], input_dims=(2, 1), output_dims=(2, 1))\n\n# Magnitude of the vector n must be 1\nn = [0,0,1]\nn = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]\n\n# Debug: check if the matrix is unitary\nmat = np.array(rn_su2(5, n))\n# Compute A^dagger.A and see if it is identity matrix\nmat = np.conj(mat.T).dot(mat)\nprint(mat)\n\n# construct the operator\nrotated = circuit.unitary(rn_su2(pi, n), 0)\n\nI checked in the notebook here at Github.\nThe rotation by \u03c04\u03c04 around the zz-axis can be performed as follows (for this I oriented myself to this lecture note):\nrot_angle = pi/4\nn = [0, 0, 1]\nrot_operator = rn_su2(rot_angle, n)\nrot_matrix = np.array(rot_operator)\nstart_vec = [1, 0, 0]\n\n_bloch = Bloch()\n_bloch.vector_color = ['blue', 'red']\n\nsv = []\nvec = start_vec\nsv.append(vec)\n\nspherical_vec = to_spherical(vec)\n\u03d5 = spherical_vec[1]\n\u03b8 = spherical_vec[2]\nprint(spherical_vec)\n\nsx = msigma(1)\nsy = msigma(2)\nsz = msigma(3)\nM_q = (np.sin(\u03b8)*np.cos(\u03d5)*sx + np.sin(\u03b8)*np.sin(\u03d5)*sy + np.cos(\u03b8)*sz)\nU_n = np.eye(2)*np.cos(rot_angle/2) -1j*(n[0]*sx+n[1]*sy+n[2]*sz)*np.sin(rot_angle/2)\nM_q_rotated = U_n*M_q*np.matrix(U_n).H\nprint(M_q_rotated)\ncos_\u03b8_rotated = float(N(re(M_q_rotated[0,0])))\n\u03b8_rotated = np.arccos(cos_\u03b8_rotated)\nprint(\u03b8_rotated)\n\n#e^(ix) = cos(x) + i*sin(x)\n#see https://en.wikipedia.org/wiki/Euler%27s_identity\ntemp = float(N(re(M_q_rotated[1,0])))\ntemp = temp/np.sin(\u03b8_rotated)\n\u03d5_rotated = np.arccos(temp)\nprint(\u03d5_rotated)\n\nvec = np.array(to_cartesian([1, \u03b8_rotated, \u03d5_rotated]))\nsv.append(vec)\n\n_bloch.add_vectors(sv)\n_bloch.render()\n\nwhich looks as follows:\n\nNote that in the code above some polishing still need to be done such as exception handling of corner cases (e.g. in trigonometric functions).\n"], "comments": ["For single qubits (representable in a Bloch sphere), you can use the usual rotation gates rx,ry,rz to perform special unitary rotations.", "@Fation: It seems that your question has an academic background investigating physical properties under the hood. You should mention that you are aware of the possibilities to use out-of-the-box gates, but you want investigate SU(2)SU(2) matrices.", "In fact, my question is specifically related to the use of SU(2) matrices. I know there are out-of-the-box options. But I can't use this for my further development.", "It might be helpful to check what the is_unitary_matrix function does. It computes A^dagger.A and checks if it is identity matrix: See Code here."], "link": "https://quantumcomputing.stackexchange.com//questions/26548/how-to-implement-su2-rotation-with-qiskit/26572?r=SearchResults#26572"}