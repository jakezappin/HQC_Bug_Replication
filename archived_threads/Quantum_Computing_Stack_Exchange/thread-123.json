{"question": "\nI tried to make a cirq program calculating an eigenvalue of the observable by VQE. Inspired by the qulacs VQE tutorial, I defined a cost function from the expectation value of the observable with hardware efficient ansatz.\nimport cirq\nimport sympy\nimport numpy as np\n\ndef hea_multilayer(qubits, depth):\n    n_qubits = len(qubits)\n    n_params = 2*n_qubits*(depth + 1)\n    theta = sympy.symbols(f'a:{n_params}')\n    for j in range(depth):\n        for i in range(n_qubits):\n            yield cirq.ry(theta[2*j*n_qubits + i])(qubits[i])\n            yield cirq.rz(theta[2*j*n_qubits + i + n_qubits])(qubits[i])\n\n        for i in range(n_qubits - 1):\n            yield cirq.CNOT(qubits[i], qubits[i+1])\n\n    for i in range(n_qubits):\n        yield cirq.ry(theta[2*depth*n_qubits + i])(qubits[i])\n        yield cirq.rz(theta[2*depth*n_qubits + n_qubits + i])(qubits[i])\n\nn_qubits = 2\ndepth = 1\nqubits = cirq.LineQubit.range(n_qubits)\nqc = cirq.Circuit()\nqc.append(hea_multilayer(qubits, depth))\n\nobservable = cirq.PauliSum.from_pauli_strings([\n    cirq.PauliString(1.0, cirq.I(qubits[0]), cirq.I(qubits[1])),\n    cirq.PauliString(1.0, cirq.X(qubits[0]), cirq.X(qubits[1])),\n    cirq.PauliString(-1.0, cirq.Y(qubits[0]), cirq.Y(qubits[1])),\n    cirq.PauliString(1.0, cirq.Z(qubits[0]), cirq.Z(qubits[1]))\n])\nprint(observable)\nprint(qc)\n\nsim = cirq.Simulator()\ndef cost(parameter):\n    subs = {}\n    for i in range(2*n_qubits*(depth+1)):\n        subs[f'a{i}'] = parameter[i]\n\n    result = sim.simulate_expectation_values(qc, observable, subs)\n    return result[0].real\n\n\nAfter that, I minimized this cost function using scipy minimize function.\nnp.random.seed(2023)\nparameter = np.random.random(8)\n\nfrom scipy.optimize import minimize\ncost_history = []\ncost_history.append(cost(parameter))\nmin_result = minimize(cost, parameter, method=\"BFGS\", callback=lambda x: cost_history.append(cost(x)))\nprint(min_result)\nprint(cost_history)\n\nHowever, this minimization did not work with the following message:\n  message: Desired error not necessarily achieved due to precision loss.\n  success: False\n   status: 2\n      fun: 0.2531989514827728\n        x: [ 3.220e-01  8.904e-01  5.881e-01 -1.969e-01 -6.673e-01\n             6.296e-01  2.209e-02  2.421e-01]\n      nit: 7\n      jac: [ 0.000e+00  0.000e+00  0.000e+00  0.000e+00  0.000e+00\n             2.000e+00  0.000e+00  0.000e+00]\n hess_inv: [[ 1.000e+00  0.000e+00 ...  0.000e+00  0.000e+00]\n            [ 0.000e+00  1.000e+00 ...  0.000e+00  0.000e+00]\n            ...\n            [ 0.000e+00  0.000e+00 ...  2.805e-06 -5.530e-06]\n            [ 0.000e+00  0.000e+00 ... -5.530e-06  1.104e-05]]\n     nfev: 993\n     njev: 109\n[0.36777588725090027, 0.25321047008037567, 0.2532104179263115, 0.25321032106876373, 0.2532094195485115, 0.25320935994386673, 0.2532089278101921, 0.2531989514827728]\n\nI implemented this program using qiskit, and compared the result to the qiskit VQE solver:\nfrom qiskit.primitives import Estimator\nfrom qiskit.quantum_info import SparsePauliOp\nfrom qiskit.circuit.library import EfficientSU2\nimport numpy as np\n\nnp.random.seed(2023)\n\nqc = EfficientSU2(2, reps = 1, insert_barriers=True, flatten=True)\n\nobservable = SparsePauliOp([\"II\", \"XX\", \"YY\", \"ZZ\"], coeffs = [1, 1, -1, 1])\n\nestimator = Estimator()\n\nparameter = np.random.random(8)\njob = estimator.run(qc, observable, parameter_values = parameter)\nprint(f'Parameter: {parameter}')\nprint(f'Circuit:\\n{qc}')\nprint(f'Job result: {job.result()}')\n\ndef cost(parameter):\n    job = estimator.run(qc, observable, parameter_values=parameter)\n    return job.result().values[0]\n\nfrom scipy.optimize import minimize\ncost_history = []\ncost_history.append(cost(parameter))\nmin_result = minimize(cost, parameter, method=\"L-BFGS-B\", callback=lambda x: cost_history.append(cost(x)))\nprint(min_result)\nprint(cost_history)\n\nfrom qiskit.algorithms.minimum_eigensolvers import VQE\nfrom qiskit.algorithms.optimizers import L_BFGS_B\n\ncost_history = []\ncost_history.append(cost(parameter))\nvqe = VQE(estimator=estimator, ansatz=qc, optimizer=L_BFGS_B(), initial_point=parameter)\nresult = vqe.compute_minimum_eigenvalue(observable)\nprint(result)\nprint(cost_history)\n\nAnd my result is similar to the qiskit VQE solver result.\nJob result: EstimatorResult(values=array([1.43214656]), metadata=[{}])\n  message: CONVERGENCE: NORM_OF_PROJECTED_GRADIENT_<=_PGTOL\n  success: True\n   status: 0\n      fun: 5.907418998418734e-11\n        x: [ 2.681e-01  1.710e+00  8.852e-01  1.201e-02 -1.934e-01\n             1.231e+00  3.499e-01  1.055e+00]\n      nit: 6\n      jac: [-2.187e-06 -9.281e-06 -2.776e-06 -4.619e-06  6.217e-06\n            -9.692e-06 -1.099e-06 -1.099e-06]\n     nfev: 63\n     njev: 7\n hess_inv: <8x8 LbfgsInvHessProduct with dtype=float64>\n[1.432146558079639, 0.2513704685300491, 0.15156282475910865, 0.0019124923978873776, 3.6796306554398583e-05, 1.1992205672939349e-08, 5.907418998418734e-11]\n/home/wleelinux/sources/qiskit_expect/hea_estimator.py:31: DeprecationWarning: ``qiskit.algorithms`` has been migrated to an independent package: https://github.com/qiskit-community/qiskit-algorithms. The ``qiskit.algorithms`` import path is deprecated as of qiskit-terra 0.25.0 and will be removed no earlier than 3 months after the release date. Please run ``pip install qiskit_algorithms`` and use ``import qiskit_algorithms`` instead.\n  from qiskit.algorithms.minimum_eigensolvers import VQE\n{   'aux_operators_evaluated': None,\n    'cost_function_evals': 63,\n    'eigenvalue': 2.642741581126984e-11,\n    'optimal_circuit': <qiskit.circuit.library.n_local.efficient_su2.EfficientSU2 object at 0x7ff1ac903590>,\n    'optimal_parameters': {   ParameterVectorElement(\u03b8[0]): -0.08608117349727416,\n                              ParameterVectorElement(\u03b8[1]): 1.9438040339495675,\n                              ParameterVectorElement(\u03b8[2]): 1.1497492983826083,\n                              ParameterVectorElement(\u03b8[3]): -0.1815167532084752,\n                              ParameterVectorElement(\u03b8[4]): -0.23455036012933897,\n                              ParameterVectorElement(\u03b8[5]): 1.413331393301791,\n                              ParameterVectorElement(\u03b8[6]): 0.7537967436651564,\n                              ParameterVectorElement(\u03b8[7]): 1.4589817775219438},\n    'optimal_point': array([-0.08608117,  1.94380403,  1.1497493 , -0.18151675, -0.23455036,\n        1.41333139,  0.75379674,  1.45898178]),\n    'optimal_value': 2.642741581126984e-11,\n    'optimizer_evals': None,\n    'optimizer_result': <qiskit.algorithms.optimizers.optimizer.OptimizerResult object at 0x7ff1a92233d0>,\n    'optimizer_time': 0.2594926357269287}\n\nWhy my cirq code failed? Is it wrong to use simulate_expectation_values method and should I implement the expectation value from the measure of the quantum circuit in cirq?\n", "answers": [], "comments": ["Inspired another cirq vqe implementation (github.com/mafaldaramoa/VQE/blob/main/CIRQ_VQE.ipynb), I changed the minimization method to Nelder-Mead, and the optimization terminated successfully. The minimum was -1.2246891856193542e-07 at x: [ 9.571e-03  2.241e+00  8.869e-01 1.190e-01  1.241e-01 9.869e-01 -4.678e-03  7.675e-01]. I think that the calculation of derivative in cirq would have an error."], "link": "https://quantumcomputing.stackexchange.com//questions/34446/variational-quantum-eigensolver-vqe-by-scipy-minimize-in-cirq-does-not-work?r=SearchResults"}