{"question": "\nI'm trying to implement the same Jupyter notebook Jin-Sung Kim gave in his YouTube video The Variational Quantum Eigensolver \u2014 Programming on Quantum Computers \u2014 Coding with Qiskit S2E4; however, I'm facing the error as below:\nError:\nstep 0\n/Users/bambrozi/.local/share/virtualenvs/ibm-quantum-challenge-2020-ZWRg31rS/lib/python3.8/site-packages/qiskit/chemistry/core/hamiltonian.py:91: DeprecationWarning: The ChemistryOperator is deprecated as of Qiskit Aqua 0.8.0 and will be removed no earlier than 3 months after the release date. Instead, the FermionicTransformation can be used to transform QMolecules and construct ground state result objects.\n  super().__init__()\n/Users/bambrozi/.local/share/virtualenvs/ibm-quantum-challenge-2020-ZWRg31rS/lib/python3.8/site-packages/qiskit/chemistry/core/hamiltonian.py:415: DeprecationWarning: Processing a dictionary result is deprecated, pass a (minimum) eigensolver result now.\n  warnings.warn('Processing a dictionary result is deprecated,'\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-3-66becf9098c9> in <module>\n     13     # exact classical result\n     14     exact_result = NumPyMinimumEigensolver(qubit_op, aux_operators=aux_ops)\n---> 15     exact_result = operator.process_algorithm_result(exact_result)\n     16 \n     17     # VQE\n\n~/.local/share/virtualenvs/ibm-quantum-challenge-2020-ZWRg31rS/lib/python3.8/site-packages/qiskit/chemistry/core/chemistry_operator.py in process_algorithm_result(self, algo_result)\n     88             return self._process_algorithm_result(algo_result)\n     89         else:\n---> 90             lines, result = self._process_algorithm_result(algo_result)\n     91             result['algorithm_retvals'] = algo_result\n     92             return lines, result\n\n~/.local/share/virtualenvs/ibm-quantum-challenge-2020-ZWRg31rS/lib/python3.8/site-packages/qiskit/chemistry/core/hamiltonian.py in _process_algorithm_result(self, algo_result)\n    374             # TODO return self._process_algorithm_result_excited_states(algo_result)\n    375         else:\n--> 376             return self._process_algorithm_result_deprecated(algo_result)\n    377 \n    378     def _process_algorithm_result_ground_state(self, algo_result: MinimumEigensolverResult) \\\n\n~/.local/share/virtualenvs/ibm-quantum-challenge-2020-ZWRg31rS/lib/python3.8/site-packages/qiskit/chemistry/core/hamiltonian.py in _process_algorithm_result_deprecated(self, algo_result)\n    419 \n    420         # Ground state energy\n--> 421         egse = algo_result['energy'] + self._energy_shift + self._ph_energy_shift\n    422         result['energy'] = egse\n    423         lines = ['=== GROUND STATE ENERGY ===']\n\nTypeError: 'NumPyMinimumEigensolver' object is not subscriptable\n\nSource-code:\n# %%\nimport numpy as np \nimport pylab \nimport copy\nfrom qiskit import BasicAer \nfrom qiskit.aqua import aqua_globals, QuantumInstance\nfrom qiskit.aqua.algorithms import NumPyMinimumEigensolver, VQE \nfrom qiskit.aqua.components.optimizers import SLSQP \nfrom qiskit.chemistry.components.initial_states import HartreeFock\nfrom qiskit.chemistry.components.variational_forms import UCCSD\nfrom qiskit.chemistry.drivers import PySCFDriver \nfrom qiskit.chemistry.core import Hamiltonian, QubitMappingType\n# %%\nmolecule = 'H .0 .0 -{0}; Li .0 .0 {0}'\ndistances = np.arange(0.5, 4.25, 0.25)\nvqe_energies = []\nhf_energies = []\nexact_energies = []\n# %%\nfor i, d in enumerate(distances):\n    print('step', i)\n\n    # set up experiment:\n    driver = PySCFDriver(molecule.format(d/2), basis='sto3g')\n    qmolecule = driver.run()\n    operator = Hamiltonian(qubit_mapping=QubitMappingType.PARITY,\n                           two_qubit_reduction=True, \n                           freeze_core=True,\n                           orbital_reduction=[-3, -2])\n    qubit_op, aux_ops = operator.run(qmolecule)\n\n    # exact classical result\n    exact_result = NumPyMinimumEigensolver(qubit_op, aux_operators=aux_ops)\n    exact_result = operator.process_algorithm_result(exact_result)\n\n    # VQE\n    optimzer = SLSQP(maxiter=1000)\n    initial_state = HartreeFock(operator.molecule_info['num_orbitals'],\n                                 operator.molecule_info['num_particles'],\n                                 qubit_mapping=operator._qubit_mapping,\n                                 two_qubit_reduction=operator._two_qubit_reduction)\n    var_form = UCCSD(num_orbitals=operator.molecule_info['num_orbitals'],\n                     num_particles=operator.molecule_info['num_particles'],\n                     initial_state=initial_state,\n                     qubit_mapping=operator._qubit_mapping,\n                     two_qubit_reduction=operator._two_qubit_reduction)\n    algo = VQE(qubit_op, var_form, optimzer, aux_operators=aux_ops)\n\n    vqe_result = algo.run(QuantumInstance(BasicAer.get_backend('statevector_simulator')))\n    vqe_result = operator.process_algorithm_result(vqe_result)\n\n    exact_energies.append(exact_result.energy)\n    vqe_energies.append(vqe_result.energy)\n    hf_energies.append(vqe_result.hartree_fock_energy)\n\nThanks for the help!\n", "answers": ["\nThe line:\nexact_result = NumPyMinimumEigensolver(qubit_op, aux_operators=aux_ops)\nshould be\nexact_result = NumPyMinimumEigensolver(qubit_op, aux_operators=aux_ops).run()\n\nHere is the full code that I ran and its output:\n# %%\nimport numpy as np \nimport pylab \nimport copy\nfrom qiskit import BasicAer \nfrom qiskit.aqua import aqua_globals, QuantumInstance\nfrom qiskit.aqua.algorithms import NumPyMinimumEigensolver, VQE \nfrom qiskit.aqua.components.optimizers import SLSQP \nfrom qiskit.chemistry.components.initial_states import HartreeFock\nfrom qiskit.chemistry.components.variational_forms import UCCSD\nfrom qiskit.chemistry.drivers import PySCFDriver \nfrom qiskit.chemistry.core import Hamiltonian, QubitMappingType\nimport matplotlib.pyplot as plt\n%matplotlib inline\n%config InlineBackend.figure_format = 'svg' # Makes the images look nice\n\n\nmolecule = 'H .0 .0 -{0}; Li .0 .0 {0}'\ndistances = np.arange(0.5, 4.25, 0.25)\nvqe_energies = []\nhf_energies = []\nexact_energies = []\n# %%\nfor i, d in enumerate(distances):\n    print('step', i)\n\n    # set up experiment:\n    driver = PySCFDriver(molecule.format(d/2), basis='sto3g')\n    qmolecule = driver.run()\n    operator = Hamiltonian(qubit_mapping=QubitMappingType.PARITY,\n                           two_qubit_reduction=True, \n                           freeze_core=True,\n                           orbital_reduction=[-3, -2])\n    qubit_op, aux_ops = operator.run(qmolecule)\n\n    # exact classical result\n    exact_result = NumPyMinimumEigensolver(qubit_op, aux_operators=aux_ops).run()\n    exact_result = operator.process_algorithm_result(exact_result)\n\n    # VQE\n    optimzer = SLSQP(maxiter=1000)\n    initial_state = HartreeFock(operator.molecule_info['num_orbitals'],\n                                 operator.molecule_info['num_particles'],\n                                 qubit_mapping=operator._qubit_mapping,\n                                 two_qubit_reduction=operator._two_qubit_reduction)\n    var_form = UCCSD(num_orbitals=operator.molecule_info['num_orbitals'],\n                     num_particles=operator.molecule_info['num_particles'],\n                     initial_state=initial_state,\n                     qubit_mapping=operator._qubit_mapping,\n                     two_qubit_reduction=operator._two_qubit_reduction)\n    algo = VQE(qubit_op, var_form, optimzer, aux_operators=aux_ops)\n\n    vqe_result = algo.run(QuantumInstance(BasicAer.get_backend('statevector_simulator')))\n    vqe_result = operator.process_algorithm_result(vqe_result)\n\n    exact_energies.append(exact_result.energy)\n    vqe_energies.append(vqe_result.energy)\n    hf_energies.append(vqe_result.hartree_fock_energy)\n    \nfig = plt.figure()\nplt.plot(distances,vqe_energies, label ='Mean Values')\nplt.show()\n\n\n"], "comments": ["Hi @kaj226 - thank you very much. In the end, I fixed it changing the same line you pointed out; however, calling the .compute_minimum_eigenvalue() instead of .run(). Here's the whole line: exact_result = NumPyMinimumEigensolver(qubit_op, aux_operators=aux_ops).compute_minimum_eigenvalue(). Jack Woehr was who helped me on this one via Qiskit Slack. Thank you both!"], "link": "https://quantumcomputing.stackexchange.com//questions/14537/typeerror-numpyminimumeigensolver-object-is-not-subscriptable?r=SearchResults"}