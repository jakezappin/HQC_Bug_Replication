{"question": "\nI am trying to implement Quantum Teleportation Algorithm on an actual device, I am using IBM-Q Jupyter notebook for the same purpose. \nThe code is as follows:\nimport qiskit as qk\nfrom qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit\nfrom qiskit import execute, Aer\nfrom qiskit import IBMQ\nfrom qiskit.visualization import plot_histogram\n%config InlineBackend.figure_format = 'svg'\n\ndef apply_secret_unitary(secret_unitary, qubit, quantum_circuit, dagger):\n  functionmap = {\n    'x': quantum_circuit.x,\n    'y': quantum_circuit.y,\n    'z': quantum_circuit.z,\n    'h': quantum_circuit.h,\n    't': quantum_circuit.t\n  }\n  if dagger == 1:\n    functionmap['t'] = quantum_circuit.tdg\n\n  if dagger:\n    [functionmap[unitary](qubit) for unitary in secret_unitary]\n  else:\n    [functionmap[unitary](qubit) for unitary in secret_unitary[::-1]]\n\nsecret_unitary = 'hzxhzhx'\n\nqc = QuantumCircuit(3, 1)\n'''\nqc[0] -> The qubit to be teleported\nqc[1] -> entangled state, possessed by alice\nqc[2] -> entangled state, possessed by bob\n'''\n\napply_secret_unitary(secret_unitary, qc.qubits[0], qc, dagger = 0) \nqc.barrier()\nqc.h(1)\nqc.cx(1, 2)\nqc.barrier()\nqc.cx(0, 1)\nqc.h(0)\nqc.cx(1, 2)\nqc.cz(0, 2)\napply_secret_unitary(secret_unitary, qc.qubits[0], qc, dagger = 1)\nqc.barrier()\nqc.measure(2, 0);\nqc.draw(output= 'mpl')\n\nIBMQ.load_account()\nprovider = IBMQ.get_provider(hub='ibm-q')\nprovider.backends()\n\nfrom qiskit.providers.ibmq import least_busy\nbackend = least_busy(provider.backends(filters = lambda b: b.configuration().n_qubits >= 3 and \n                                       not b.configuration().simulator and \n                                       b.status().operational == True))\njob_exp = execute(qc, backend = backend, shots = 8192)\nexp_result = job_exp.result()\n\nexp_measurement_result = exp_result.get_counts()\nprint(exp_measurement_result)\nplot_histogram(exp_measurement_result)\n\nThe error which the following code gives is:\nIBMQJobApiError: \"'400 Client Error: Bad Request for url: https://api.quantum-computing.ibm.com/api/Network/ibm-q/Groups/open/Projects/main/Jobs/5e73033786653e0018a2364e/resultDownloadUrl. Cannot get presigned download url., Error code: 3202.'\"\n\nI've tried deleting my account and load a new account using a newly generated token but that doesn't seem to work either.\nClicking the link in the error gives the following error:\nOPERATION_NOT_AVAILABLE\n404 Shared class \"Hub\" has no method handling GET /ibm-q/Groups/open/Projects/main/Jobs/5e72ff01121d5e0018bfe775/resultDownloadUrl.\ncode: 2411\n\nperhaps, I am using a method which is now deprecated. How can I tackle this situation?\n", "answers": ["\nI'm not sure what had caused the problem but I was able to solve it and most likely know what the problem was.\nConsider these two lines from my code above:\njob_exp = execute(qc, backend = backend, shots = 8192)\nexp_result = job_exp.result()\n\nProblem with the above lines is that we are not waiting for the actual quantum device to compute and send over the data. To avoid this, we can use a method called job_monitor from qiskit.tools.monitor which when called, let us know whether the job is complete or not. \nAfter it displays that the job has successfully run we should expect value from result \nFollowing is the code for the same purpose:\nIBMQ.load_account()\nprovider = IBMQ.get_provider(hub = 'ibm-q')\nbackend = least_busy(provider.backends(filters = lambda x: x.configuration().n_qubits >= 3\n                                      and not x.configuration().simulator\n                                      and x.status().operational == True))\nprint('least busy backend: ', backend)\n\nfrom qiskit.tools.monitor import job_monitor\njob = execute(qc, backend = backend, shots = 8192)\njob_monitor(job)\n\nProceed further only after the output to the above cell becomes 'Job Status: job has successfully run' which may take some time depending upon the value of shots.\nAfter that, you can call result() and get_counts() to get the values:\nresult = job.result()\ncounts = result.get_counts()\n\n", "\nEDIT: I believe this is solved in @IEIrodov's answer below.\nI'm not sure what's causing the issue, but based on similar issues on the qiskit slack channel, I don't think it's something you're doing.\nAs a workaround, try running:\nexp_result = job_exp.result()\nexp_measurement_result = exp_result.get_counts()\nprint(exp_measurement_result)\nplot_histogram(exp_measurement_result)\n\nSeparately in a new cell.\n(also, if you're trying to verify teleportation, you need to apply_secret_unitary on line 42 to qc.qubits[2] instead of qc.qubits[0]).\n", "\nError 3202 is a networking error when trying to get the requested page. In this case the results for your job. \n"], "comments": ["Can you try removing the barriers?", "It remains the same.", "That's what I think as well, it doesn't seem to work that way either. Also, you're right about using qubit_2, that's a silly mistake on my side. thanks!", "Okay, sorry I wasn't able to help more. Hopefully the issue will be fixed soon.", "I've added a solution that worked for me, check it out!", "@IEIrodov, I can't comment on your answer, but I'm glad you've solved it! Maybe I had just been waiting long enough between running the cells that the job could complete."], "link": "https://quantumcomputing.stackexchange.com//questions/10228/error-while-running-quantum-teleportation-algorithm-on-real-device-using-qiskit?r=SearchResults"}