{"question": "\nI'm trying to build a new instruction for my circuit. This instruction needs both a controller qubit qctl and an arbitrary register qreg. When qctl is set then the Qiskit's initialize function is applied to qreg. \nThe original Initialize gate (version 10.5) can be found in the official documentation or locally at path: /anaconda3/envs/<environment name>/lib/python3.7/site-packages/qiskit/extensions/initializer.py. It follows a particular procedure which consists of applying a sequence of RY and RZ gates in order to match the desired state. \nThe idea is:\n\ncopy the Initialize instruction, naming it ControlledInitialize;\npass an additional single qubit register qctl to ControlledInitialize;\nchange all RZ, RY gates with CRZ, CRY gates (the first one is already available, the second one have to be made from scratch).\n\nThe problem\nIt seems that I have passed qctl register in the wrong way, in fact the below minimum example throws the error:\nDAGCircuitError: '(qu)bit qctl[0] not found'\n\nMinimum example\nimport numpy as np\nfrom qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\nfrom qiskit import BasicAer, execute\n\n# copy here CRY and ControlledInitialize implementation\n\ndesired_vector = [ 1 / math.sqrt(2), 0, 0, 1 / math.sqrt(2) ]\nqctl = QuantumRegister(1, \"qctl\")\nqreg = QuantumRegister(2, \"qreg\")\ncreg = ClassicalRegister(2, \"creg\")\ncircuit = QuantumCircuit(qctl, qreg, creg)\n\ncircuit.x(qctl)\ncircuit.controlled_initialize(qctl, desired_vector, qreg)\ncircuit.measure(qreg, creg)\n\njob = execute(circuit, BasicAer.get_backend('qasm_simulator'), shots=10000)\nprint('Counts: ', job.result().get_counts(circuit))\n\nThe implementation\nThe whole code can be seen here as .py and here as Jupyter notebook.\nCRZ, CRY gates\nCRZ is a standard gate, you can use it with \nfrom qiskit.extensions.standard.crz import CrzGate\n\nCRY is present in Aqua module as a function but not as a subclass of Gate class. You can easily derive the gate implementation:\nfrom qiskit.circuit import CompositeGate\nfrom qiskit.circuit import Gate\nfrom qiskit.circuit import QuantumCircuit\nfrom qiskit.circuit import QuantumRegister\nfrom qiskit.circuit.decorators import _op_expand, _to_bits\nfrom qiskit.extensions.standard.u3 import U3Gate\nfrom qiskit.extensions.standard.cx import CnotGate\n\nclass CryGate(Gate):\n    \"\"\"controlled-rz gate.\"\"\"\n\n    def __init__(self, theta):\n        \"\"\"Create new cry gate.\"\"\"\n        super().__init__(\"cry\", 2, [theta]) # 2 = number of qubits\n\n    def _define(self):\n        \"\"\"\n        self.u3(theta / 2, 0, 0, q_target)\n        self.cx(q_control, q_target)\n        self.u3(-theta / 2, 0, 0, q_target)\n        self.cx(q_control, q_target)\n        \"\"\"\n        definition = []\n        q = QuantumRegister(2, \"q\")\n        rule = [\n            (U3Gate(self.params[0] / 2, 0, 0), [q[1]], []),\n            (CnotGate(), [q[0], q[1]], []),\n            (U3Gate(-self.params[0] / 2, 0, 0), [q[1]], []),\n            (CnotGate(), [q[0], q[1]], [])\n        ]\n        for inst in rule:\n            definition.append(inst)\n        self.definition = definition\n\n    def inverse(self):\n        \"\"\"Invert this gate.\"\"\"\n        return CrzGate(-self.params[0])\n\n\n@_to_bits(2)\n@_op_expand(2)\ndef cry(self, theta, ctl, tgt):\n    \"\"\"Apply crz from ctl to tgt with angle theta.\"\"\"\n    return self.append(CryGate(theta), [ctl, tgt], [])\n\n\nQuantumCircuit.cry = cry\nCompositeGate.cry = cry\n\nControlledInitialize instruction\nAny modification of original Initialize instruction is denoted with WATCH ME comment. Here an overview:\n\nin __init__ I just save the single qubit control register;\nin _define, gates_to_uncompute, multiplexer the temporary circuit built will have also qctl register;\nin _define, gates_to_uncompute, multiplexer any append function call is enriched with qctl register in the list of qubits taken as second parameter;\nin gates_to_uncompute just substitute RYGate/RZGate with CryGate/CrzGate.\nclass ControlledInitialize(Instruction):\n\n\"\"\"Complex amplitude initialization.\n\nClass that implements the (complex amplitude) initialization of some\nflexible collection of qubit registers (assuming the qubits are in the\nzero state).\n\"\"\"\n\ndef __init__(self, controlled_qubit, params):\n    \"\"\"Create new initialize composite.\n\n    params (list): vector of complex amplitudes to initialize to\n    \"\"\"\n\n    # WATCH ME: save controlled qubit register\n    self.controlled_qubit = controlled_qubit\n\n    num_qubits = math.log2(len(params))\n\n    # Check if param is a power of 2\n    if num_qubits == 0 or not num_qubits.is_integer():\n        raise QiskitError(\"Desired statevector length not a positive power of 2.\")\n\n    # Check if probabilities (amplitudes squared) sum to 1\n    if not math.isclose(sum(np.absolute(params) ** 2), 1.0,\n                        abs_tol=_EPS):\n        raise QiskitError(\"Sum of amplitudes-squared does not equal one.\")\n\n    num_qubits = int(num_qubits)\n\n    super().__init__(\"controlledinitialize\", num_qubits, 0, params) # +1 per il controllo\n\ndef _define(self):\n    \"\"\"Calculate a subcircuit that implements this initialization\n\n    Implements a recursive initialization algorithm, including optimizations,\n    from \"Synthesis of Quantum Logic Circuits\" Shende, Bullock, Markov\n    https://arxiv.org/abs/quant-ph/0406176v5\n\n    Additionally implements some extra optimizations: remove zero rotations and\n    double cnots.\n    \"\"\"\n    # call to generate the circuit that takes the desired vector to zero\n    disentangling_circuit = self.gates_to_uncompute()\n\n    # invert the circuit to create the desired vector from zero (assuming\n    # the qubits are in the zero state)\n    initialize_instr = disentangling_circuit.to_instruction().inverse()\n\n    q = QuantumRegister(self.num_qubits, 'q')\n    initialize_circuit = QuantumCircuit(self.controlled_qubit, q, name='init_def')\n    for qubit in q:\n        initialize_circuit.append(Reset(), [qubit])\n\n    # WATCH ME: cambiati registri\n    temp_qubitsreg = [ self.controlled_qubit[0] ] + q[:]\n    # initialize_circuit.append(initialize_instr, q[:])\n    initialize_circuit.append(initialize_instr, temp_qubitsreg)\n\n    self.definition = initialize_circuit.data\n\ndef gates_to_uncompute(self):\n    \"\"\"\n    Call to create a circuit with gates that take the\n    desired vector to zero.\n\n    Returns:\n        QuantumCircuit: circuit to take self.params vector to |00..0>\n    \"\"\"\n    q = QuantumRegister(self.num_qubits)\n    # WATCH ME: aggiunto registro controlled_qubit\n    circuit = QuantumCircuit(self.controlled_qubit, q, name='disentangler')\n\n    # kick start the peeling loop, and disentangle one-by-one from LSB to MSB\n    remaining_param = self.params\n\n    for i in range(self.num_qubits):\n        # work out which rotations must be done to disentangle the LSB\n        # qubit (we peel away one qubit at a time)\n        (remaining_param,\n         thetas,\n         phis) = ControlledInitialize._rotations_to_disentangle(remaining_param)\n        # WATCH ME: Initialize._rotations_to_disentangle diventa ControlledInitialize._rotations_to_disentangle\n\n        # perform the required rotations to decouple the LSB qubit (so that\n        # it can be \"factored\" out, leaving a shorter amplitude vector to peel away)\n\n        # WATCH ME: substitute RZ with CRZ\n        # rz_mult = self._multiplex(RZGate, phis)\n        rz_mult = self._multiplex(CrzGate, phis)\n\n        # WATCH ME: substitute RY with CRY\n        # ry_mult = self._multiplex(RYGate, thetas)\n        ry_mult = self._multiplex(CryGate, thetas)\n\n        # WATCH ME: cambiati registri\n        temp_qubitsreg = [ self.controlled_qubit[0] ] + q[i:self.num_qubits]\n        # circuit.append(rz_mult.to_instruction(), q[i:self.num_qubits])\n        # circuit.append(ry_mult.to_instruction(), q[i:self.num_qubits])\n        circuit.append(rz_mult.to_instruction(), temp_qubitsreg)\n        circuit.append(ry_mult.to_instruction(), temp_qubitsreg)\n\n        print(\"Z: \", phis, \" | Y: \", thetas)\n\n    return circuit\n\n@staticmethod\ndef _rotations_to_disentangle(local_param):\n    \"\"\"\n    Static internal method to work out Ry and Rz rotation angles used\n    to disentangle the LSB qubit.\n    These rotations make up the block diagonal matrix U (i.e. multiplexor)\n    that disentangles the LSB.\n\n    [[Ry(theta_1).Rz(phi_1)  0   .   .   0],\n     [0         Ry(theta_2).Rz(phi_2) .  0],\n                                .\n                                    .\n      0         0           Ry(theta_2^n).Rz(phi_2^n)]]\n    \"\"\"\n    remaining_vector = []\n    thetas = []\n    phis = []\n\n    param_len = len(local_param)\n\n    for i in range(param_len // 2):\n        # Ry and Rz rotations to move bloch vector from 0 to \"imaginary\"\n        # qubit\n        # (imagine a qubit state signified by the amplitudes at index 2*i\n        # and 2*(i+1), corresponding to the select qubits of the\n        # multiplexor being in state |i>)\n        (remains,\n         add_theta,\n         add_phi) = ControlledInitialize._bloch_angles(local_param[2 * i: 2 * (i + 1)])\n        # WATCH ME: Initialize._bloch_angles diventa ControlledInitialize._bloch_angles\n\n        remaining_vector.append(remains)\n\n        # rotations for all imaginary qubits of the full vector\n        # to move from where it is to zero, hence the negative sign\n        thetas.append(-add_theta)\n        phis.append(-add_phi)\n\n    return remaining_vector, thetas, phis\n\n@staticmethod\ndef _bloch_angles(pair_of_complex):\n    \"\"\"\n    Static internal method to work out rotation to create the passed in\n    qubit from the zero vector.\n    \"\"\"\n    [a_complex, b_complex] = pair_of_complex\n    # Force a and b to be complex, as otherwise numpy.angle might fail.\n    a_complex = complex(a_complex)\n    b_complex = complex(b_complex)\n    mag_a = np.absolute(a_complex)\n    final_r = float(np.sqrt(mag_a ** 2 + np.absolute(b_complex) ** 2))\n    if final_r < _EPS:\n        theta = 0\n        phi = 0\n        final_r = 0\n        final_t = 0\n    else:\n        theta = float(2 * np.arccos(mag_a / final_r))\n        a_arg = np.angle(a_complex)\n        b_arg = np.angle(b_complex)\n        final_t = a_arg + b_arg\n        phi = b_arg - a_arg\n\n    return final_r * np.exp(1.J * final_t / 2), theta, phi\n\ndef _multiplex(self, target_gate, list_of_angles):\n    \"\"\"\n    Return a recursive implementation of a multiplexor circuit,\n    where each instruction itself has a decomposition based on\n    smaller multiplexors.\n\n    The LSB is the multiplexor \"data\" and the other bits are multiplexor \"select\".\n\n    Args:\n        target_gate (Gate): Ry or Rz gate to apply to target qubit, multiplexed\n            over all other \"select\" qubits\n        list_of_angles (list[float]): list of rotation angles to apply Ry and Rz\n\n    Returns:\n        DAGCircuit: the circuit implementing the multiplexor's action\n    \"\"\"\n    list_len = len(list_of_angles)\n    local_num_qubits = int(math.log2(list_len)) + 1\n\n    q = QuantumRegister(local_num_qubits)\n    # WATCH ME: aggiunto registro controlled_qubit\n    circuit = QuantumCircuit(self.controlled_qubit, q, name=\"multiplex\" + local_num_qubits.__str__())\n\n    lsb = q[0]\n    msb = q[local_num_qubits - 1]\n\n    # case of no multiplexing: base case for recursion\n    if local_num_qubits == 1:\n        temp_qubitsreg = [ self.controlled_qubit[0], q[0] ]\n        circuit.append(target_gate(list_of_angles[0]), temp_qubitsreg)\n        return circuit\n\n\n    # calc angle weights, assuming recursion (that is the lower-level\n    # requested angles have been correctly implemented by recursion\n    angle_weight = scipy.kron([[0.5, 0.5], [0.5, -0.5]],\n                              np.identity(2 ** (local_num_qubits - 2)))\n\n    # calc the combo angles\n    list_of_angles = angle_weight.dot(np.array(list_of_angles)).tolist()\n\n    # recursive step on half the angles fulfilling the above assumption\n    multiplex_1 = self._multiplex(target_gate, list_of_angles[0:(list_len // 2)])\n    temp_qubitsreg =  [ self.controlled_qubit[0] ] + q[0:-1]\n    circuit.append(multiplex_1.to_instruction(), temp_qubitsreg)\n\n    # attach CNOT as follows, thereby flipping the LSB qubit\n    circuit.append(CnotGate(), [msb, lsb])\n\n    # implement extra efficiency from the paper of cancelling adjacent\n    # CNOTs (by leaving out last CNOT and reversing (NOT inverting) the\n    # second lower-level multiplex)\n    multiplex_2 = self._multiplex(target_gate, list_of_angles[(list_len // 2):])\n    temp_qubitsreg = [ self.controlled_qubit[0] ] + q[0:-1]\n    if list_len > 1:\n        circuit.append(multiplex_2.to_instruction().mirror(), temp_qubitsreg)\n    else:\n        circuit.append(multiplex_2.to_instruction(), temp_qubitsreg)\n\n    # attach a final CNOT\n    circuit.append(CnotGate(), [msb, lsb])\n\n    return circuit\n\n\nQiskit version\nLatest version is used:\nimport qiskit\nqiskit.__qiskit_version__\n\n{'qiskit': '0.10.5',\n 'qiskit-terra': '0.8.2',\n 'qiskit-ignis': '0.1.1',\n 'qiskit-aer': '0.2.1',\n 'qiskit-ibmq-provider': '0.2.2',\n 'qiskit-aqua': '0.5.2'}\n\n", "answers": ["\nThis is occurring because you declare your definition rule on two registers, but the way nodes are added to the DAG, only one register will be added. It is defined over both the QuantumRegister \"q\" you define in the method, and also the register passed in to self.params.\nTo fix this therefore you need to update your definition to work on only one register. For example, the first qubit could be the control and the other qubits can be initialised.\n"], "comments": ["Just a comment to congratulate you for this question! You included everything and the whole question is well structured! I hope you will have a good answer.", "If anybody stumbles upon this: The CRYGate is a circuit method by now and you can do circuit.cry.", "Thank you for your comment. I need some time to test it."], "link": "https://quantumcomputing.stackexchange.com//questions/6755/controlled-initialize-instruction?r=SearchResults"}