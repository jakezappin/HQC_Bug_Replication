{"question": "\nI am trying to measure the number operator, together with the ground state energy with the built-in VQE on Qiskit. However, if I pick the backend to be Aer.get_backend('qasm_simulator'), it seems to give an error 'numpy.float64' object is not iterable. Please see the minimal working code and the error message below. This is rather confusing, because the backend BasicAer.get_backend('statevector_simulator') works perfectly fine. Thanks for the help!\nfrom qiskit.aqua.algorithms import VQE, NumPyEigensolver\n\nfrom qiskit.chemistry.components.variational_forms import UCCSD\nfrom qiskit.chemistry.components.initial_states import HartreeFock\nfrom qiskit.chemistry.drivers import PySCFDriver, UnitsType\nfrom qiskit import Aer, BasicAer\nfrom qiskit.chemistry import FermionicOperator\nfrom qiskit.aqua.operators import Z2Symmetries\nfrom qiskit.aqua.components.optimizers import L_BFGS_B\n\noptimizer = L_BFGS_B()\nbackend = Aer.get_backend('qasm_simulator')\n# backend = BasicAer.get_backend('statevector_simulator')\n\natom='H .0 .0 .0; H .0 .0 0.74'\nmap_type = 'parity'\n\ndriver = PySCFDriver(atom=atom, unit=UnitsType.ANGSTROM, basis='sto3g')    \nmolecule = driver.run()\n\nnum_alpha = molecule.num_alpha \nnum_beta = molecule.num_beta     \n#     num_particles = molecule.num_alpha + molecule.num_beta\nnum_particles = [ num_alpha , num_beta ] \nnum_spin_orbitals = molecule.num_orbitals * 2\nferOp = FermionicOperator(h1=molecule.one_body_integrals, h2=molecule.two_body_integrals)\n\nnumOp = ferOp.total_particle_number()        \n\nqubitOp = ferOp.mapping(map_type=map_type)\n\nqubitNumOp = numOp.mapping(map_type=map_type )\n\nqubitOp = Z2Symmetries.two_qubit_reduction(qubitOp, num_particles)    \nqubitNumOp = Z2Symmetries.two_qubit_reduction(qubitNumOp, num_particles)\n\nprint('Ground state energy without shift is ' , NumPyEigensolver( qubitOp , k=2 ).run().eigenvalues.real )\n\n\ninit_state = HartreeFock( num_spin_orbitals , num_particles , map_type )\nprint( 'HF =  ' , init_state.bitstr )\n\n# setup the variational form for VQE\n\n\n\nvar_form_vqe = UCCSD(\n        num_orbitals=num_spin_orbitals,\n        num_particles=num_particles,\n        initial_state=init_state,\n        qubit_mapping=map_type , \n        two_qubit_reduction = True , \n    )\n\n\nalgorithm_vqe = VQE(qubitOp, var_form_vqe, optimizer , aux_operators = [qubitNumOp] )\n\nresult_vqe = algorithm_vqe.run(backend)\n\n\nprint( 'para_vqe = ' , result_vqe['optimal_point' ] )\n\nprint( 'eigenvalue_vqe = ' , result_vqe['eigenvalue' ].real )\n\nprint( result_vqe  )\n\nerror message is attached below\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-1-5fb4d9ac0b3c> in <module>\n     59 algorithm_vqe = VQE(qubitOp, var_form_vqe, optimizer , aux_operators = [qubitNumOp] )\n     60 \n---> 61 result_vqe = algorithm_vqe.run(backend)\n     62 \n     63 \n\n~/<redacted>/qiskit/aqua/algorithms/quantum_algorithm.py in run(self, quantum_instance, **kwargs)\n     68                 self.quantum_instance = quantum_instance\n     69 \n---> 70         return self._run()\n     71 \n     72     @abstractmethod\n\n~/<redacted>/qiskit/aqua/algorithms/minimum_eigen_solvers/vqe.py in _run(self)\n    425 \n    426         if self.aux_operators:\n--> 427             self._eval_aux_ops()\n    428             # TODO remove when ._ret is deprecated\n    429             result.aux_operator_eigenvalues = self._ret['aux_ops'][0]\n\n~/<redacted>/qiskit/aqua/algorithms/minimum_eigen_solvers/vqe.py in _eval_aux_ops(self, threshold)\n    445         # Deal with the aux_op behavior where there can be Nones or Zero qubit Paulis in the list\n    446         self._ret['aux_ops'] = [None if is_none else [result]\n--> 447                                 for (is_none, result) in zip(self._aux_op_nones, aux_op_results)]\n    448         self._ret['aux_ops'] = np.array([self._ret['aux_ops']])\n    449 \n\nTypeError: 'numpy.float64' object is not iterable\n```\n\n", "answers": ["\nI agree that the code you provided only work with statevector_simulator. I ran it, get the output of particle number to be 2 on the statevector_simulator.\nInterestingly, you can get around this problem by just running another VQE execution with the found optimal parameters and not doing any optimization (by set the max_iteration =0 in the optimizer ), to get the particle number...  so essentially you are just calculating \u27e8\u03c8optimal|Oparticle\u00a0number|\u03c8optimal\u27e9\u27e8\u03c8optimal|Oparticle\u00a0number|\u03c8optimal\u27e9.\nThe code below does what I just mentioned above. I kept it as you wrote it, just added the VQE energy to the end of what you wrote, and the part to find the particle number from what I described.\nfrom qiskit.aqua.algorithms import VQE, NumPyEigensolver\n\nfrom qiskit.chemistry.components.variational_forms import UCCSD\nfrom qiskit.chemistry.components.initial_states import HartreeFock\nfrom qiskit.chemistry.drivers import PySCFDriver, UnitsType\nfrom qiskit import Aer, BasicAer\nfrom qiskit.chemistry import FermionicOperator\nfrom qiskit.aqua.operators import Z2Symmetries\nfrom qiskit.aqua.components.optimizers import L_BFGS_B\n\noptimizer = L_BFGS_B()\nbackend = Aer.get_backend('qasm_simulator')\n# backend = BasicAer.get_backend('statevector_simulator')\n\natom='H .0 .0 .0; H .0 .0 0.74'\nmap_type = 'parity'\n\ndriver = PySCFDriver(atom=atom, unit=UnitsType.ANGSTROM, basis='sto3g')    \nmolecule = driver.run()\n\nnum_alpha = molecule.num_alpha \nnum_beta = molecule.num_beta     \n#     num_particles = molecule.num_alpha + molecule.num_beta\nnum_particles = [ num_alpha , num_beta ] \nnum_spin_orbitals = molecule.num_orbitals * 2\nferOp = FermionicOperator(h1=molecule.one_body_integrals, h2=molecule.two_body_integrals)\n\nnumOp = ferOp.total_particle_number()        \n\nqubitOp = ferOp.mapping(map_type=map_type)\n\nqubitNumOp = numOp.mapping(map_type=map_type )\n\nqubitOp = Z2Symmetries.two_qubit_reduction(qubitOp, num_particles)    \nqubitNumOp = Z2Symmetries.two_qubit_reduction(qubitNumOp, num_particles)\n\nprint('Ground state energy without shift is ' , NumPyEigensolver( qubitOp , k=2 ).run().eigenvalues.real )\n\n\ninit_state = HartreeFock( num_spin_orbitals , num_particles , map_type )\nprint( 'HF =  ' , init_state.bitstr )\n\n# setup the variational form for VQE\n\n\n\nvar_form_vqe = UCCSD(\n        num_orbitals=num_spin_orbitals,\n        num_particles=num_particles,\n        initial_state=init_state,\n        qubit_mapping=map_type , \n        two_qubit_reduction = True , \n    )\n\n\nalgorithm_vqe = VQE(qubitOp, var_form_vqe, optimizer ,  include_custom = True )\nfrom qiskit.aqua import QuantumInstance\nquantum_instance = QuantumInstance(backend = backend, shots= 10000, optimization_level= 3)\nresult_vqe = algorithm_vqe.run(quantum_instance)\n\n\nprint( 'para_vqe = ' , result_vqe['optimal_point' ] )\nprint('VQE energy =', result_vqe['optimal_value'] )\nprint('eigenstate:', result_vqe['eigenstate'])\n\nprint('**************** Finding Particle Number *************************')\nfrom qiskit.aqua.components.optimizers import COBYLA\noptimizer = COBYLA(maxiter= 0,tol=0.0001)   \ninitial_point = result_vqe['optimal_point' ]\nparticle_number_vqe = VQE(qubitNumOp, var_form_vqe, optimizer , include_custom = True, initial_point = initial_point )\nparticle_number = particle_number_vqe.run(quantum_instance)\nprint( 'Particle_number = ' , particle_number['optimal_value'] )\n\nThe output would be something like:\nGround state energy without shift is  [-1.85238817 -1.2458777 ]\nHF =   [False  True]\npara_vqe =  [-7.22409784e-09  1.35083082e-08 -1.12782817e-01]\nVQE energy = -1.852388173569581\neigenstate: {'01': 9888, '10': 112}\n**************** Finding Particle Number *************************\nParticle_number =  1.999999999999998\n\n"], "comments": ["Yes. I don't see why not. If you can evaluate \u27e8\u03c8|H|\u03c8\u27e9\u27e8\u03c8|H|\u03c8\u27e9 on qasm_simulator then why not \u27e8\u03c8|O|\u03c8\u27e9\u27e8\u03c8|O|\u03c8\u27e9 for some other operators... you just need to make sure the operator get mapped to qubit operator correctly.", "@KAJ226 I think the number operator is mapped correctly, because 'statevector_simulator' works fine. Also, if I get rid of the number operator, then \"qasm_simulator\" also works fine...", "interesting. I need to look into it a little more careful but in the mean time I posted a quick way to side-step this issue... probably not the best but just a quick way to side step the issue for the moment :)", "LOL... That is a really smart work-around. I don't know we can run VQE zero times. Thanks a lot, you really help me twice!", "@fagd no problem! Glad I was able to help. :)", "One further related question. I notice \"qasm_simulator\" is significantly slower than \"statevector_simulator\". Is it something normal?", "@fagd I never compare them directly but one thing for sure, if you simulate something really large, like more than 15 qubits (and also depending on what local machine you have but I am speaking in term of average machine) you will find statevector to be a problem as it tries to save all the data of the density matrix, which grows exponentially. In qasm_simulator you can use the snap-shot mode. By setting  include_custom = True in your VQE execution and shots = 1 in your quantum instance. This will makes it run much faster!!", "quantum_instance = QuantumInstance(backend = backend, shots= 1, optimization_level= 3) and algorithm_vqe = VQE(qubitOp, var_form_vqe, optimizer ,  include_custom = True )", "I am gonna try it out. Thanks!", "two more questions. If I set shots=1, will that sacrifice the accuracy of the results? Also how did you determine optimization_level?", "If you set shots =1 and include_custom = True then it won't sacrifice the result as it doing something similar to statevector_simulator. Ah the optimization level which I set to 3 is more for the hardware transpilation process. You don't need that for the simulators.", "Thanks for the clarification. Since I do want to run the simulation on the actual hardware later, should I be careful about some of the parameters here?", "In hardware, you only submit 8192 shots at a time so keep that in mind. Also, you might want to define your quantum_instance so it also do read-out error mitigation to improve upon your result.", "Got it. Thanks!"], "link": "https://quantumcomputing.stackexchange.com//questions/15154/is-it-possible-to-measure-aux-operators-in-built-in-vqe-with-backend-qasm-sim"}