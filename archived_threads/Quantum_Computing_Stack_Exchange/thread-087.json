{"question": "\nSuppose you are given the following quantum circuit in Qiskit:\nfrom numpy import pi\nfrom qiskit import QuantumCircuit\n\nangle = pi / 3\n\nqc = QuantumCircuit(1)\nqc.ry(angle, 0)\nqc.ry(-angle, 0)\n\nqc.draw('mpl')\n\n\nThe circuit simply performs two rotations around the yy-axis with angle \u03b8=\u03c0/3\u03b8=\u03c0/3 and then \u2212\u03b8\u2212\u03b8. These operations should be resolved in a simple identity because I=Ry(\u2212\u03b8)Ry(\u03b8)I=Ry(\u2212\u03b8)Ry(\u03b8). However, the Qiskit transpile function seems not to do the job as expected in this case:\nfrom qiskit import transpile\n\ntqc = transpile(qc, optimization_level=3)\ntqc.draw('mpl')\n\n\nMoreover, trying exactly the same thing with RxRx (qc.rx) or RzRz (qc.rz) rotations, the transpilation runs perfectly returning an empty circuit. Is this a bug in Qiskit? Or maybe I'm missing something?\n", "answers": ["\nIt was a bug, now fixed in release 0.40.0.\nIn the release notes, you can read:\n\nFixed an issue with the transpile() function when run with optimization_level=3 and no backend, basis_gates, or target argument specified. If the input circuit contained any 2 qubit blocks which were equivalent to an identity matrix the output circuit would not be as optimized as possible and and would still contain that identity block. This could have been corrected previously by specifying either the backend, basis_gates, or target arguments on the transpile() call, but now the output will be as simplified as it can be without knowing the target gates allowed. Fixed #9217\n\n"], "comments": ["It was a bug. Please, try qiskit 0.40.0. With this version, it works.", "@MicheleAmoretti This should be an answer. Ideally, it would include a reference to the bug, release notes etc."], "link": "https://quantumcomputing.stackexchange.com//questions/29894/why-is-the-qiskit-transpiler-not-resolving-the-equivalence-i-r-y-theta-r-y?r=SearchResults"}