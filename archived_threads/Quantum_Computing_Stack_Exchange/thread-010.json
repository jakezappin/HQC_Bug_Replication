{"question": "\nI am executing the following code.\n[ins] In [1]: from qiskit.opflow.primitive_ops import PrimitiveOp\n     ...: from qiskit.quantum_info import Pauli\n     ...: import numpy as np\n     ...: x = 3.5*np.sqrt(3.0/2)\n     ...: print(x)\n     ...: annih_op=PrimitiveOp(Pauli('X')) + 1.0j*PrimitiveOp(Pauli('Y'))\n     ...: creat_op = PrimitiveOp(Pauli('X')) - 1.0j*PrimitiveOp(Pauli('Y'))\n     ...: my_op = x*creat_op.compose(annih_op, front=True)\n     ...: print('type(my_op) = ', type(my_op))\n     ...: print('my_op)= ', my_op)\n\nIt gives a warning and a very deeply nested numpy array.\n    4.286607049870561\n<ipython-input-1-583b34f24f0c>:8: VisibleDeprecationWarning: Creating an ndarray from nested sequences exceeding the maximum number of dimensions of 32 is deprecated. If you mean to do this, you must specify 'dtype=object' when creating the ndarray.\n  my_op = x*creat_op.compose(annih_op, front=True)\ntype(my_op) =  <class 'numpy.ndarray'>\nmy_op)=  [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[PauliSumOp(SparsePauliOp(['I'],\n                                              coeffs=[4.28660705+0.j]), coeff=1.0)]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[PauliSumOp(SparsePauliOp(['Z'],\n                                              coeffs=[4.28660705+0.j]), coeff=1.0)]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[PauliSumOp(SparsePauliOp(['Z'],\n                                              coeffs=[4.28660705+0.j]), coeff=1.0)]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[PauliSumOp(SparsePauliOp(['I'],\n                                              coeffs=[4.28660705+0.j]), coeff=1.0)]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]\n\nBut if I set x to be something else for example 2.0, I am getting the expected output and no warning.\n[nav] In [2]: from qiskit.opflow.primitive_ops import PrimitiveOp\n         ...: from qiskit.quantum_info import Pauli\n         ...: import numpy as np\n         ...: #x = 3.5*np.sqrt(3.0/2)\n         ...: x=2.0\n         ...: print(x)\n         ...: annih_op=PrimitiveOp(Pauli('X')) + 1.0j*PrimitiveOp(Pauli('Y'))\n         ...: creat_op = PrimitiveOp(Pauli('X')) - 1.0j*PrimitiveOp(Pauli('Y'))\n         ...: my_op = x*creat_op.compose(annih_op, front=True)\n         ...: print('type(my_op) = ', type(my_op))\n         ...: print('my_op)= ', my_op)\n2.0\ntype(my_op) =  <class 'qiskit.opflow.primitive_ops.pauli_sum_op.PauliSumOp'>\nmy_op)=  2.0 * I\n+ 2.0 * Z\n+ 2.0 * Z\n+ 2.0 * I\n\nIs it a possible bug in Qiskit?\n", "answers": ["\nIf you checked the type of your coefficient x, you will find that its value is numpy.float64.\nAnd if you checked how multiplication by scalar is implemented in PauliSumOp class [1], you will notice that only scalars of type int, float, and complex are supported. Otherwise, the multiplication by scalar will be handled by the primitive class (SparsePauliOp in our case) which inherits __rmul__ from MultiplyMixin[2]. This is where the issue happens.\nSo, to avoid the issue, just cast your coefficient,\nx = float(3.5 * np.sqrt(3.0/2))\n\nOr change the order of multiplication,\nmy_op = creat_op.compose(annih_op, front=True) * x\n\n"], "comments": ["Is this a bug? Should this be reported to Qiskit developers?", "It should be considered as a bug.", "I raised an issue. github.com/Qiskit/qiskit/issues/1452"], "link": "https://quantumcomputing.stackexchange.com//questions/25699/qiskit-primitiveop-compose-function-giving-weird-output?r=SearchResults"}