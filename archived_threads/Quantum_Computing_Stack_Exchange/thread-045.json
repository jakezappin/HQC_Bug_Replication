{"question": "\nI am trying to develop a customized VQE algorithm in which I am making use of the class UCC of qiskit_nature. I am having trouble understanding the outputs of the methods of the class. I have elaborated it below.\nThe UCC operator is given by, U=eT\u2212T\u2020U=eT\u2212T\u2020 where TT is the cluster operator. TT is written as a linear combination of excitation operators with respect to a reference state, say the HartreeFock state. It is a function of many parameters that act as coefficients of these excitation operators. First, I would like to obtain UU, preferably in the form of a QuantumCircuit. I believe this is definitely achievable through the class UCC but I am having a little hard time trying to understand how, or trying to see what I have obtained is actually correct. Here is what I did.\nI imported the relevant modules and called the UCC with num_orbitlas = 4 and num_particles = (1,1) as follows.\nfrom qiskit_nature.circuit.library.ansatzes import UCC\nfrom qiskit_nature.mappers.second_quantization import JordanWignerMapper\n\nUCC_operator = UCC(qubit_converter=QubitConverter(mapper=JordanWignerMapper()), num_particles=(1,1), num_spin_orbitals=4, excitations='s')\n\nOnce I obtained the UCC_operator object, I used the excitation_ops method of the UCC class to extract the excitation operators. The code:\nferm_ops = UCC_operator.excitation_ops()\nprint (ferm_ops)\n\nand the output:\n[FermionicOp([('+-II', 1j), ('-+II', 1j)], register_length=4, display_format='dense'), FermionicOp([('II+-', 1j), ('II-+', 1j)], register_length=4, display_format='dense')]\n\nMy first two questions concern the form of the output of this particular method.\n1. Does the above output correspond to the operator T\u2212T\u2020T\u2212T\u2020 in the exponential of the conventional UCC operator? If so, am I correct in saying that the above form basically implies T\u2212T\u2020=t0(c\u20200c1\u2212c\u20201c0)+t1(c\u20202c3\u2212c\u20203c2)T\u2212T\u2020=t0(c0\u2020c1\u2212c1\u2020c0)+t1(c2\u2020c3\u2212c3\u2020c2) ? Where t0t0 & t1t1 are just some parameters although not present in the above output but I believe are still contained in the UCC_operator.\n2. Now, is it that the additional imaginary factor is multiplied to the above operators because Trotterization in qiskit somehow considers the evolution operators to be of the form e\u2212iO^e\u2212iO^ which for our case would be like e\u2212i\u22c5i(T\u2212T\u2020)e\u2212i\u22c5i(T\u2212T\u2020) and hence the ferm_op printed above actually corresponds to i(T\u2212T\u2020)i(T\u2212T\u2020) and not just T\u2212T\u2020T\u2212T\u2020? (I saw in the source code of UCC that the sign is due to PauliTrotterEvolution.convert but I was not sure if this is what it meant.)\nNow, I wanted to convert this operator from second quantized form to a Pauli string. I used the map method of the JordanWignerMapper as follows,\nJW = JordanWignerMapper()\nprint ([JW.map(second_q_op=ferm_ops[i]) for i in range (len(ferm_ops))])\n\nto obtain,\n[PauliSumOp(SparsePauliOp(['IIXY', 'IIYX'], coeffs=[ 0.5+0.j, -0.5+0.j]), coeff=1.0), PauliSumOp(SparsePauliOp(['XYII', 'YXII'], coeffs=[ 0.5+0.j, -0.5+0.j]), coeff=1.0)]\n\n3. Am I then correct in interpreting the above result to mean i(T\u2212T\u2020)=0.5\u22c5t0[IIXY\u2212IIYX]+0.5\u22c5t1[XYII\u2212YXII]i(T\u2212T\u2020)=0.5\u22c5t0[IIXY\u2212IIYX]+0.5\u22c5t1[XYII\u2212YXII] under the Jordan-Wigner transformation?\nFinally, I drew the circuit using the following code:\nUCC_operator.decompose().draw(output='mpl', filename='my_circuit.png')\n\nto obtain,\n\nThe image seems to be of the Trotterized UCC anstaz with Trotter step = 1. This I believe is due to the reps parameter of UCC which by default is equal to one. Then,\n4. Why is there a \"+\" sign instead of a \"-\" sign between IIXY & IIYX and XYII & YXII in the above circuit if what I have written in question 3 is correct?\n5. Also, are the factors of half present in the expression of question 3 are now absorbed in the constant parameters t[0]t[0] and t[1]t[1] given in the above circuit?\nThese are the questions I encountered while trying to understand the class UCC. Since I am trying to develop a modified VQE, it was essential for me to get these doubts clarified before heading on. Any hints or answers are greatly appreciated. Thank you.\n", "answers": ["\nFrom my understanding:\n\naccording to UCC docs here\nyou should do UCC_operator.operators, not excitation_ops(), where you can see UCC operator:(becasue excitation_ops is, parses the excitations and generates the list of operators.)\n\n[PauliSumOp(SparsePauliOp(['IIXY', 'IIYX'],\n               coeffs=[ 0.5+0.j, -0.5+0.j]), coeff=1.0),\n PauliSumOp(SparsePauliOp(['XYII', 'YXII'],\n               coeffs=[ 0.5+0.j, -0.5+0.j]), coeff=1.0)]\n\n2.yes, you are right, it will have imaginary factor after PauliTrotterEvolution, where EvolvedOpcome in.\n3.yes, you are right, check PauliTrotterEvolution docs here,\n4.A easy example in circuit why there is +, because they are adding together in SparsePauliOp where ['IIXY', 'IIYX'] :\nUCC_operator.decompose().decompose().draw(output='mpl')# if you decompose second time\n\n5. yes, example which will giving the same circuit, but contain only 1 parameter(t),and coeffs for simplicity: (which you can understand more about it.)\ntrotter with second order error equation:\n x=t learn more here\n# Import Pauli operators (I, X, Y, Z), other things\nfrom qiskit.circuit.library import PauliEvolutionGate\nfrom qiskit.opflow import X, Y, Zero, I, PauliTrotterEvolution, Suzuki, CircuitStateFn\nfrom qiskit.synthesis import SuzukiTrotter\nimport numpy as np\n\nJ = 0.5\n\n# tight-binding Hamiltonian\ndef H_tb():\n    # Interactions (I is the identity matrix; X and Y are Pauli matricies; ^ is a tensor product)\n    XXs = (I^I^X^Y) + (I^I^Y^X)\n    YYs = (X^Y^I^I) + (Y^X^I^I)\n    \n    # Sum interactions\n    H = J*(XXs+YYs)\n    \n    # Return Hamiltonian\n    return H\n\n#parameter\nfrom qiskit.circuit import Parameter\nt = Parameter('t')\n\n# Unitary evolution under the tight-binding Hamiltonian\ndef U_tb(t):\n    H = H_tb()\n    return (t * H).exp_i()\n\n#Example\ndisplay(U_tb(1))\n#output:\n#EvolvedOp(PauliSumOp(SparsePauliOp(['IIXY', 'IIYX', 'XYII', 'YXII'],\n#              coeffs=[0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j]), coeff=1), coeff=1.0)\n\n\nop = H_tb()\nevo_ham = U_tb(t)\nreps = 1\n\n#SuzukiTrotter 1st order is the same with LieTrotter, \nevo_gate = PauliTrotterEvolution(trotter_mode=Suzuki(order=1, reps=1)).convert(evo_ham)\nevo_gate.to_circuit().draw()\noutput:\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\nq_0: \u25240                                             \u251c\n     \u2502                                              \u2502\nq_1: \u25241                                             \u251c\n     \u2502  exp(-it (IIXY + IIYX + XYII + YXII))(1.0*t) \u2502\nq_2: \u25242                                             \u251c\n     \u2502                                              \u2502\nq_3: \u25243                                             \u251c\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n"], "comments": ["welcome, accept answer if it solve your problem, it will help a lot.", "Please edit the question to limit it to a specific problem with enough detail to identify an adequate answer.", "1 Thank you for pointing out the operators attribute, I had somehow missed it.", "@Kurious accept answer will help alot, thank you", "Sorry for not completing the comment. I still have doubts with 4 and 5. In 4 I do not understand where did the - sign disappear. Because, the coeffs of the SparsePauliOp were (0.5+0.j,\u22120.5+0.j)(0.5+0.j,\u22120.5+0.j) by which I though it corresponds to saying 0.5\u22c5IIXY\u22120.5\u22c5IIYX0.5\u22c5IIXY\u22120.5\u22c5IIYX. Hence, I was expecting the circuit to have the evolution operator exp(\u2212it\u22c50.5(IIXY\u2212IIYX))exp\u2061(\u2212it\u22c50.5(IIXY\u2212IIYX))  but this does not seem to be the case. Can you please clarify why is this negative sign is replaced by a positive sign in the final circuit?", "In 5 I still do not see where did the 0.5 factor disappear.  Because, even with the code you provided, if J=0.5, the final circuit seems to have an additional multiple of 2 in the exponential which is being multiplied to this J. Or in other words, if you put J=2, the final circuit will actually have 4*t as the coefficient. Can you please explain why is this so?", "in 4 the - sign can't show up because the pint method problem, making the coeffs disappearm if you print it in text it should be fine. in 5, it multiply with the 2.0, thats why it is showing 1.0. @Kurious", "I recommend you can learn more about it with ibm quantum challenge 2022 spring ex1 and ex2", "the reason there is always 2.0 is because RZ gate matrices contain divide 2 @Kurious", "I think I understood what you mean. Thank you for the clarification and suggestion.", "@Kurious you can decompose to till the basic gate set, and you can see the coeff * t"], "link": "https://quantumcomputing.stackexchange.com//questions/27145/clarification-on-the-usage-of-class-ucc-of-qiskit-nature/27146?r=SearchResults#27146"}