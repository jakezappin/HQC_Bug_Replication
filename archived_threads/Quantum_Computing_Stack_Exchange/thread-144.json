{"question": "\nI'm using qiskit with the online IBM Quantum Lab and when I run the following code\nfrom qiskit import QuantumCircuit, Aer, execute\nfrom qiskit.visualization import plot_bloch_multivector\n\nqc = QuantumCircuit(1) \n\nqc.h(0)\nqc.h(0)\nqc.h(0)\n\nout = execute(qc,Aer.get_backend('statevector_simulator')).result().get_statevector()\nprint(out)\nplot_bloch_multivector(out)\n\n... it results in the following state vector for the qubit:\n[0.70710678+0.00000000e+00j 0.70710678+1.57009246e-16j]\nAs you can see there's a very small imaginary component in the |1> amplitude.\nThese imaginary values pop up often with qiskit, such as:\nqc.x(0)\nqc.h(0)\n--> [ 0.70710678+0.00000000e+00j -0.70710678+8.65956056e-17j]\n\nor even very small non-imaginary numbers, such as:\nqc.x(0)\nqc.h(0)\nqc.h(0)\n--> [6.123234e-17+0.00000000e+00j 1.000000e+00-2.22044605e-16j]\n\nIs this something unique to quantum mechanics/computing that actually has practical consequences when doing computation, or perhaps simply a quirk of Python's scientific notation implementation.\n", "answers": ["\nThis is just a quirk of how complex numbers are implemented in Python/Numpy, etc. At the end of the day, these are represented as floating-point numbers within the target simulator. These are then transformed via various mathematical operations to implement the simulation and this eventually leads to an accumulation of round off error. For all intents and purposes, e-16 is zero, but a computer doesn't know that.\n", "\nAs mentioned by @user47787\nThis is yet another case of floating-point representation error at the machine level.\nThis behaviour is language agnostic and has nothing to do with Python or Numpy or Qiskit.\nRelated Reads:\n\nA very old post on stackoverflow discussing this issue - Is Floating Point Math broken ?\n\nPython docs describing the same - Floating Point Arithmetic: Issues and Limitations\n\n\n"], "comments": ["These are just precision errors.  The calculations are using doubles, and 12\u221a12 has no exact representation as a double.", "That's why the real parts are imprecise, but how are nonzero imaginary parts creeping in? The initial state vector and the gates are purely real, and the sum and product of complex numbers with exactly-zero imaginary parts have exactly zero imaginary part, even by IEEE rules.", "I'm uncertain about this. This is likely related to a peculiarity related to the implementation of Aer's statevector simulator."], "link": "https://quantumcomputing.stackexchange.com//questions/17298/why-does-applying-a-hadamard-gate-three-times-to-0-rangle-result-in-a-tiny-im?r=SearchResults"}