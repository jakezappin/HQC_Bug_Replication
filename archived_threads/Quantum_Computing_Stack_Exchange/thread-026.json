{"question": "\nI've been working on a code to run VQE with a grouped measurement. For some reason, my expectation values are slightly off from those computed by pennylane, the software I decided to use for this little project. I've been staring at my expectation value function exp_val, and I can't tell why it's wrong.\nThis is the code:\nimport pennylane as qml\nfrom pennylane import qchem\nimport numpy as np\n\nsymbols = [\"H\", \"H\"]\ncoordinates = np.array([0.0, 0.0, -0.6614, 0.0, 0.0, 0.6614])\nh2_ham, n_qubits = qchem.molecular_hamiltonian(symbols, coordinates)\nn_shots = 1000\n\ndev_noisy = qml.device('default.qubit', wires = n_qubits, shots = n_shots)\n\n@qml.qnode(dev_noisy)\ndef VQE_circuit(params, group = None, n_qubits = None):\n        qml.StronglyEntanglingLayers(params, wires = range(n_qubits))\n        rotations = qml.grouping.diagonalize_qwc_pauli_words(group)[0]\n        return qml.probs(wires=range(n_qubits))\n\n\nimport autograd.numpy as agnp\ndrawer = qml.draw(VQE_circuit)\n\ndef exp_val(results, coeffs, groupings):\n        E = 0\n        for i, result in enumerate(results):\n                #Process each list of counts (probs)\n                ops = groupings[i]\n                coeff_list = coeffs[i]\n                #print(drawer(params, group = groupings[i], n_qubits = n_qubits))\n                for op_idx, op in enumerate(ops):\n                        ##calculate expval for each operator in group\n                        if op.name == 'Identity':\n                                E += coeff_list[op_idx]\n                        else:\n                                exp_val = 0\n                                for c_idx, count in enumerate(result):\n                                        #process bitstring in result\n                                        idxs = op.wires.toarray()\n                                        bits = format(c_idx, \"b\").zfill(n_qubits)\n                                        sub_bits = [bits[i] for i in idxs]\n                                        par = sub_bits.count('1')%2\n                                        sign = (-1)**par\n                                        exp_val += sign*count\n                                exp_val *= coeff_list[op_idx]\n                                E += exp_val\n        return E\nprint(\"\\n\", h2_ham, \"\\n\")\ngroupings, coeffs = qml.grouping.group_observables(h2_ham.terms[1], h2_ham.terms[0], grouping_type = 'qwc', method = 'rlf')\nparam_shape = qml.templates.StronglyEntanglingLayers.shape(n_layers=3, n_wires=n_qubits)\nparams = np.random.normal(scale=0.1, size=param_shape)\nresults = [VQE_circuit(params, group = group, n_qubits = n_qubits) for group in groupings]\nprint(exp_val(results, coeffs, groupings))\n\n\n##VQE execution:\ndef naive_cost(params):\n    results = [VQE_circuit(params, group = group, n_qubits = n_qubits) for group in groupings]\n    return exp_val(results, coeffs, groupings)    \nsparse = qml.utils.sparse_hamiltonian(h2_ham).toarray()\ngs_E = np.linalg.eigvalsh(sparse)[0]\nprint(\"GSE: \", gs_E)\nimport scipy.optimize as opt\nparam_shape = qml.templates.StronglyEntanglingLayers.shape(n_layers=5, n_wires=n_qubits)\nparams = np.random.normal(scale=0.1, size=param_shape)\nopt = qml.AdagradOptimizer(0.05)\n\nmax_iteration = 100\nconv_tol = 1e-6\nenergy = [naive_cost(params)]\nfor n in range(max_iteration):\n        params, prev_E = opt.step_and_cost(naive_cost, params)\n        energy.append(naive_cost(params))\n        conv = np.abs(energy[-1]-prev_E)\n        if n % 2 == 0:\n                print(f\"Step = {n},  Energy = {energy[-1]:.8f} Ha\")\n\n        if conv <= conv_tol:\n                break\n#print(energy)\nprint(\"FOUND GROUND STATE E: \", np.min(energy))\nprint(\"FINAL params: \", params)\nprint(\"REAL GROUND STATE E: \", gs_E)\n\n\nAm I doing something obviously wrong? I've checked to ensure the endianness of the bits is correct, I made sure to calculate parities based on the active qubit indices for the desired observable, I made sure not to include a parity calculation when computing expected value of identity operators. I've triple checked that the coefficients are being applied to the correct operators, that the circuits are appended with the correct measurement circuits for the given operator in the group. Amongst these checks, I can't seem to find the flaw in my programming logic. Having an extra pair of eyes on this would be extremely helpful.\nAll the best,\ncuhrazatee\nPS:\nHere's the code using Pennylane's built in exp_val.\nfrom openfermion.ops.operators.qubit_operator import QubitOperator\nimport pennylane as qml\nfrom pennylane import qchem\nimport numpy as np\nfrom functools import partial\nfrom pennylane.measure import state\nfrom pennylane.ops.qubit import observables\nfrom pennylane.templates import UCCSD\nimport matplotlib.pyplot as plt\n\nsymbols = [\"H\", \"H\"]\ncoordinates = np.array([0.0, 0.0, -0.6614, 0.0, 0.0, 0.6614])\nh2_ham, n_qubits = qchem.molecular_hamiltonian(symbols, coordinates)\nn_electrons = 2\nsingles, doubles = qchem.excitations(n_electrons, n_qubits)\ns_wires, d_wires = qchem.excitations_to_wires(singles, doubles)\nref_state = qchem.hf_state(n_electrons, n_qubits)\nansatz = partial(UCCSD, init_state = ref_state, s_wires = s_wires, d_wires = d_wires)\ngroupings, coeffs = qml.grouping.group_observables(h2_ham.terms[1], h2_ham.terms[0], grouping_type = 'qwc', method = 'rlf')\n\nn_shots = 10000\ndev_noisy = qml.device('default.qubit', wires = n_qubits, shots = n_shots)\n\nsparse = qml.utils.sparse_hamiltonian(h2_ham).toarray()\ngs_E = np.linalg.eigvalsh(sparse)[0]\n\nprint(\"GSE: \", gs_E)\nparam_shape = qml.templates.StronglyEntanglingLayers.shape(n_layers=5, n_wires=n_qubits)\nparams = np.random.normal(scale=0.1, size=param_shape)\noptimal_params = [[[0.15300575748799206, 0.0802866250748122, 0.6612327808749161],\n  [-0.012197292985330403, 1.0054708209216188, -0.5031298708940922],\n  [0.4871116388974964, 0.8755791036972337, 0.15300349217856668],\n  [0.2125674641016197, -0.3988028820299284, -0.5903810690276766]],\n [[-0.26227065702483116, 0.7762008921102848, 0.20421958031876591],\n  [-0.11210374173720475, -0.7158851608015426, -0.945090563307313],\n  [-0.20041447281024863, -0.43875447105339715, -0.10552844761324888],\n  [0.017868138476782234, -0.4067704016345291, 0.19911933547123295]],\n [[-0.1170885274951583, -0.40203947157121894, -0.44851762637470327],\n  [-0.2715291337140317, 0.6888494094283752, 0.5389027752311034],\n  [-0.5191082830999312, 0.4426962606005164, -0.25932474764548114],\n  [0.8138172470220708, -0.54678942509227, 0.4102491578027457]],\n [[0.7676993827422776, -0.47721469081406376, 0.6337393057184456],\n  [-0.6553402727229024, 0.8955375499127577, 0.5789282160827474],\n  [0.6570560582613835, -0.8518341967262695, -0.6023881439081624],\n  [0.040387149769954125, 0.3040045252649316, -0.38193967606295326]],\n [[0.42336490227621815, -0.3869902716443922, 0.27822533007353994],\n  [1.2170710775127433, 0.6959673154584948, -0.11538272838636159],\n  [0.33436903989516936, -0.7268804688737179, 0.49919014014531526],\n  [0.818911996077618, -0.6280017753881122, 0.553169606547251]]]\n\ncost = qml.ExpvalCost(qml.StronglyEntanglingLayers, h2_ham, dev_noisy, optimize=True)\n\nopt = qml.AdagradOptimizer(0.06)\n\n\n\nmax_iteration = 100\nconv_tol = 1e-6\nenergy = [cost(params)]\nfor n in range(max_iteration):\n        params, prev_E = opt.step_and_cost(cost, params)\n        energy.append(cost(params))\n        conv = np.abs(energy[-1]-prev_E)\n        if n % 2 == 0:\n                print(f\"Step = {n},  Energy = {energy[-1]:.8f} Ha\")\n\n        if conv <= conv_tol:\n                break\n#print(energy)\nprint(\"FOUND GROUND STATE E: \", np.min(energy))\nprint(\"REAL GROUND STATE E: \", gs_E)\n\n```\n\n", "answers": ["\nHaving tested your code locally, I actually don't believe there are any errors. But, there are a few reasons that you are not getting the exact expectation value.\nThe first is just that the device is set to use 1000 shots, so there will always be some fluctuation due to the probabilistic nature of measurement.\nThe second has to do with the number of optimization steps and convergence criteria. With 1000 shots, the fluctuation between the cost at each optimization step is going to be significantly larger than the 1e-6 convergence threshold; here are a couple examples from my local run:\nStep = 66,  Energy = -0.82500835 Ha\nStep = 68,  Energy = -0.83819441 Ha\nStep = 70,  Energy = -0.84052676 Ha\nStep = 72,  Energy = -0.85156650 Ha\nStep = 74,  Energy = -0.89118294 Ha\nStep = 76,  Energy = -0.88678496 Ha\n\nThe convergence criteria will never be met, and so instead the optimization will end when it reaches the maximum number of iterations. At 100 steps, the energy is floating around -1.0, so it actually just needs more time to approach the true value (~250 steps). A good way to sanity check is to use the analytic mode by not setting a shot number for the device; this will give a clearer picture of how the optimization will progress, and how many iterations might be needed (and, additionally, if the parameters of the Optimizer need to be tweaked).\n"], "comments": ["Could you add in the code to obtain pennylane's solution, and also the actual output from your code? (I don't use pennylane and might not be able to help, but there's a better chance if I can see everything!)", "Yep, just added the VQE execution code + the pennylane \"cookie cutter\" implementation. The behavior of exp_val is the most important in the code above. The way the execution works is for each set of compatible observables there is a probability distribution in results corresponding to the statistics of the prepared wavefunction. Then I do parity averaging on the operators in that set to compute their individual expectation values. This is done for every set of compatible observables, and is added together to produce the expected value of the entire hamiltonian."], "link": "https://quantumcomputing.stackexchange.com//questions/22014/vqe-from-scratch-what-have-i-got-wrong"}