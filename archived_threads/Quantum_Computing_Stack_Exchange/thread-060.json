{"question": "\nI am trying to perform a simulation using Qasm in order to see how the readout error actually affects my circuit. The circuit I am implementing is a trivial one, the three qubit one that implements the GHZ state: https://qiskit.org/documentation/tutorials/circuits/01_circuit_basics.html\nBelow I attach the code:\nimport numpy as np\nfrom qiskit import QuantumCircuit \n\ncirc = QuantumCircuit(3)\ncirc.h(0)\ncirc.cx(0, 1)\ncirc.cx(0, 2)\n# Create a Quantum Circuit\nmeas = QuantumCircuit(3, 3)\nmeas.barrier(range(3))\n# map the quantum measurement to the classical bits\nmeas.measure(range(3), range(3))\n\n# The Qiskit circuit object supports composition.\n# Here the meas has to be first and front=True (putting it before)\n# as compose must put a smaller circuit into a larger one.\nqc = meas.compose(circ, range(3), front=True)\n\n#drawing the circuit\nqc.draw('mpl');\n\n\nNext, I create the Readout Error model:\nfrom qiskit.providers.aer.noise import NoiseModel\nfrom qiskit.providers.aer.noise import QuantumError, ReadoutError\n\n# Create noise model\nreadout_noise_model = NoiseModel()\n\n# Create the readout error matrix\n\nP = np.array([[0.9,0.02,0.02,0.02,0.02,0.01,0.01,0.0],\n             [0.02,0.9,0.02,0.02,0.02,0.01,0.01,0.0],\n             [0.02,0.02,0.9,0.02,0.02,0.01,0.01,0.0],\n             [0.02,0.02,0.02,0.9,0.02,0.01,0.01,0.0],\n             [0.02,0.02,0.02,0.02,0.9,0.01,0.01,0.0],\n             [0.02,0.02,0.02,0.01,0.01,0.9,0.01,0.01],\n             [0.01,0.02,0.02,0.02,0.03,0.04,0.84,0.02],\n             [0.02,0.02,0.02,0.02,0.04,0.04,0.04,0.8]])\n\n# Add readout error to the qubits\n\nreadout_noise_model.add_readout_error(P,[0,1,2])\nprint(readout_noise_model)\n\nAnd now run the simulation:\nfrom qiskit import transpile\nfrom qiskit.providers.aer import AerSimulator\n\nbackend = AerSimulator()\n\n# First we have to transpile the quantum circuit\n# to the low-level QASM instructions used by the\n# backend\nqc_compiled = transpile(qc, backend)\n\n# Execute the circuit on the qasm simulator.\n# We've set the number of repeats of the circuit\n# to be 1024, which is the default.\njob_sim = backend.run(qc_compiled, shots=1024, noise_model=readout_noise_model)\n\n    # Grab the results from the job.\n\n    result_sim = job_sim.result()\ncounts = result_sim.get_counts(qc_compiled)\nprint(counts)\n\nAnd obtain the histogram:\nfrom qiskit.visualization import plot_histogram\nplot_histogram(counts);\n\nNow, without noise I would expect indeed, as in the Qiskit link provided, that about 50% of the times I get the first state and about 50% the other one. For example something like this:\n\nHowever, I would assume that since I am biasing the noise (observe the last two or three rows of the P matrix) I should get slightly offset result. I do not seem to get offset results favoring the |000\u27e9 state for example (of the opposite).\nMy questions are:\n\nIs my Readout Error properly implemented?\nHow can I force a bias in such a circuit?\n\n", "answers": ["\nReplace\nmeas.measure(range(3), range(3))\n\nwith:\nmeas.append(Instruction(\"measure\", 3, 3, []), range(3), range(3))\n\nThis makes a custom measurement instruction that measures the 3 qubits together, as per https://github.com/Qiskit/qiskit-aer/issues/319.\nAfter doing this, you will find it both favors 000 over 111 and also there will be sporadic instances of the other computational basis states:\n\n"], "comments": [], "link": "https://quantumcomputing.stackexchange.com//questions/26655/implementing-readout-error-in-my-circuit-seems-to-have-no-effect-whatsoever?r=SearchResults"}