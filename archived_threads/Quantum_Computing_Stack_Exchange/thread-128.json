{"question": "\nI try to apply QAOA algorithm to find minimal energy state of the Hamiltonian:\nHA=12\u03c31z+12\u03c31z\u03c32zHA=12\u03c31z+12\u03c31z\u03c32z\nIt is expected that with p=2 my  variational should satisfy the eigenstate of the smallest eigenvalue.\nThe problem is that something went wrong in my code and I cannot find mistake.\nfrom qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\nfrom qiskit.aqua.operators import WeightedPauliOperator\nfrom qiskit.aqua.operators.state_fns import CircuitStateFn\nfrom qiskit.aqua.algorithms import NumPyEigensolver\n#from qiskit import BasicAer, execute\nfrom qiskit import Aer\nfrom qiskit.aqua import QuantumInstance\nfrom qiskit.aqua.operators import PauliExpectation, CircuitSampler, StateFn\nimport itertools\nimport math\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\nimport numpy as np\n\nHBHB\ndef prepare_Hb(a,b):\n  pauli_dict = {\n    'paulis': [\n               {\"coeff\": {\"imag\": 0.0, \"real\": a}, \"label\": \"XI\"},\n               {\"coeff\": {\"imag\": 0.0, \"real\": b}, \"label\": \"IX\"}\n              ]}\n  return WeightedPauliOperator.from_dict(pauli_dict)\n\nHAHA\ndef prepare_Ha(a, b):enter preformatted text here    \npauli_dict = {\n    'paulis': [\n               {\"coeff\": {\"imag\": 0.0, \"real\": a}, \"label\": \"ZI\"},\n               {\"coeff\": {\"imag\": 0.0, \"real\": b}, \"label\": \"ZZ\"},\n              ]\n}\nreturn WeightedPauliOperator.from_dict(pauli_dict)\n\nAnsatz\ndef add_ansatz_layer(circuit, gamma, beta):\n    q = circuit.qregs[0]\n    circuit = add_U_Ha(circuit, gamma)\n    circuit = add_U_Hb(circuit, beta)\n    return circuit\n\ndef ansatz(arr_gamma, arr_beta):\n    \n    p = len(arr_gamma)\n      \n    q = QuantumRegister(2)\n    circuit = QuantumCircuit(q)\n    \n    # quantum state preparation\n    circuit.h(q[0])\n    circuit.h(q[1])\n    \n    \n    for ind in range(p):\n        circuit = add_ansatz_layer(circuit, arr_gamma[ind], arr_beta[ind])\n    return circuit\n\nExpectation calculation\ndef expectation(ansatz,Hamiltonian):\n    H_operator = Hamiltonian.to_opflow()\n    psi = CircuitStateFn(ansatz)\n   \n    backend = Aer.get_backend('qasm_simulator') \n    q_instance = QuantumInstance(backend, shots=1024)\n\n    measurable_expression = StateFn(H_operator, is_measurement=True).compose(psi) \n    expectation = PauliExpectation().convert(measurable_expression)  \n    sampler = CircuitSampler(q_instance).convert(expectation) \n\n    # evaluate\n    result = sampler.eval().real\n    \n    return result\n\n\n\n\n\ndef evaluation2(variables,p=1):\n    if p not in [1,2]:\n        print(\"Invalid p\")\n        return\n    if len(variables) != 2:\n        variables = [[variables[0],variables[1]],[variables[2],variables[3]]]\n   \n    gamma = variables[0]\n    beta  = variables[1]\n    #print(variables,'-----')\n    if p != 2:\n        gamma = [gamma]\n        beta = [beta]\n    Ha = prepare_Ha(0.5, 0.5)\n    test = ansatz(gamma,beta)\n    \n    res = expectation(test, Ha)\n    return res\n\n1)Compute the expectation value of the energy <\u03b3,\u03b2|H|\u03b3,\u03b2><\u03b3,\u03b2|H|\u03b3,\u03b2>  and plot it as a function of the variational parameters \u03b3\u03b3 and \u03b2\u03b2 ;\ngamma = np.arange(-np.pi, np.pi, 0.05)\nbeta = np.arange(-np.pi, np.pi, 0.05)\nfunc = np.zeros( (gamma.size, beta.size) )\nprint(gamma.shape, beta.shape)\ncounter_y = 0\n\nfor j in beta:\n    counter_x = 0\n    for i in gamma:\n        func[counter_x, counter_y] = evaluation2([i,j],1)\n        counter_x += 1\n    counter_y += 1\n\nX, Y = np.meshgrid(beta, gamma)\n\nfig = plt.figure(figsize=(15,15))\nax = fig.gca(projection='3d')\n#ax = fig.add_subplot(111, projection = '3d')\nax.plot_surface(X, Y, func, cmap=cm.coolwarm,\n                       linewidth=0, antialiased=False)\n\nplt.xlabel('gamma')\nplt.ylabel('beta')\nplt.show()\n\n\n2)Minimize the energy. What are the optimal angles \ud835\udefe\u2217\n, \ud835\udefd\u2217\n bound_g1 = (0,np.pi)\nbound_b1 = (0,np.pi)\ninitial_guess = (0, np.pi/2)\nresult = optimize.minimize(evaluation2,  x0=initial_guess , bounds=[bound_g1,bound_b1])\n\n3)Compute the variational state obtained for the optimal angles |\u03b3\u2217,\u03b2\u2217>|\u03b3\u2217,\u03b2\u2217>\ncircuit_opt = ansatz([opt_angles[0]],[opt_angles[1]])\ncircuit_opt.draw(output='mpl')\n\n\n4)Compute the success probability |<1,0|\u03b3\u2217,\u03b2\u2217>|2|<1,0|\u03b3\u2217,\u03b2\u2217>|2;\n# one-zero state\nq10 = QuantumRegister(2)\none_zero_circuit = QuantumCircuit(q10)\none_zero_circuit.x(q10[0])\none_zero_state = CircuitStateFn(one_zero_circuit)\npsi = CircuitStateFn(circuit_opt)\nresult = (abs(one_zero_state.adjoint().compose(psi).eval()))**2\nprint('Probability =',result)\n\nAnswer: Probability = 0.24999999175977444\n5)Show numerically that with p=2 a success probability of 100% is obtained.\n#Gradient based optimization\ninitial_guess = (np.pi, 0, 0, 0)\nbound_g1 = (0,np.pi)\nbound_g2 = (0,np.pi)\nbound_b1 = (0,np.pi)\nbound_b2 = (0,np.pi)\nresult = optimize.minimize(evaluation2,  x0=initial_guess, args=(2), bounds=[bound_g1,bound_g2,bound_b1,bound_b2])\nopt_angles_p2 = result.x\n\n'''\n# Annealing\nimport scipy.optimize as spo\ninitial_guess = (np.pi, 0, 0, 0)\nanneal_solution = spo.dual_annealing(evaluation2, x0=initial_guess, maxiter = 100, args=(2,), bounds=[bound_g1,bound_g2,bound_b1,bound_b2])\n#print(anneal_solution)\nopt_angles_p2 = anneal_solution.x\nprint(opt_angles_p2)\n'''\n\nopt_g1 = opt_angles_p2[0]\nopt_g2 = opt_angles_p2[1]\nopt_b1 = opt_angles_p2[2]\nopt_b2 = opt_angles_p2[3]\ncircuit_opt_p2 = ansatz([opt_g1 ,opt_g2],[opt_b1 ,opt_b2])\ncircuit_opt_p2.draw(output='mpl')\n\n\nchi = CircuitStateFn(circuit_opt_p2)\nresult = (abs(one_zero_state.adjoint().compose(chi).eval()))**2\nprint('Probability =',result)\n\nAnswer: Probability = 0.2500000000000261\nThe graph in 1) seems to be strange\nIn 2)and 5) minimization doesn't work. Minimizer returns initial guess.\nIt is expected 100% success probability in 5) but I got 25% and even worse.\nAny help would be appreciated.\n", "answers": [], "comments": ["Hello, I looked at your code and I have a few questions: first why do you only consider the real part of the absolute value when calculating the result for your probabilities? I think you should remove the '.real', it seems wrong. Next, did you try to solve the problem with the QAOA already implemented in Qiskit?", "@Lena, thank you for pointing that out. I have fixed the absolute value but it didn't solve the problem. I want to do it from scratch.", "Sorry I should have been clearer, I meant did you try the QAOA already implemented just to check whether you have the same behaviour or not, so that you can know if the problem comes from your code or maybe the asked problem. Do you see what I mean?"], "link": "https://quantumcomputing.stackexchange.com//questions/15416/implemented-qaoa-returns-wrong-result"}