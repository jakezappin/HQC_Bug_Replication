{"question": "\nI have a simple 2 qubit circuit which I am trying to protect from errors using the measurement error mitigation technique laid out here:\nhttps://qiskit.org/textbook/ch-quantum-hardware/measurement-error-mitigation.html. My circuit is\nqr=QuantumRegister(2)\ncircuit2 = QuantumCircuit();\ncircuit2.add_register(qr)\ncr=ClassicalRegister(2)\ncircuit2.add_register(cr)\n\ncircuit2.measure(0,0);\ncircuit2.measure(1,1);\nnoise_model = NoiseModel()\nnoise_model.add_all_qubit_readout_error([[1 - Er0,Er0], [Er1, 1 - Er1]])\nresult = execute(circuit2,backend=Aer.get_backend('qasm_simulator'),shots=maxShot,noise_model=noise_model).result()\ncounts = result.get_counts(0)\n\nI then get the counts for each outcome and store it in a vector\nn00=counts.get('00')\netc..\nn2qvec=np.array([n00,n01,n10,n11])\n\nAs is laid out in the tutorial I obtain the calibration matrix and filter\naer_sim = Aer.get_backend('aer_simulator')\nqr2q = QuantumRegister(2)\nmy_layout2q={qr2q[0]:0,qr2q[1]:1}\nmeas_calibs2q, state_labels2q = complete_meas_cal(qr=qr2q, circlabel='mcal2q')\nt_qc = transpile(meas_calibs2q, aer_sim)\nqobj = assemble(t_qc, shots=10000)\nnoise_model = NoiseModel()\nnoise_model.add_all_qubit_readout_error([[1 - Er0,Er0], [Er1, 1 - Er1]])    \ncal_results2q = aer_sim.run(qobj, shots=10000,noise_model=noise_model).result()\nmeas_fitter2q = CompleteMeasFitter(cal_results2q, state_labels2q, circlabel='mcal2q')\nmeas_filter2q = meas_fitter2q.filter\ncalmat2q=meas_fitter2q.cal_matrix\nimport scipy.linalg as la\ncalmatinv2q = la.inv(calmat2q)\n\nI then apply this to the earlier results to account for the noise\nmitigated_results2q = meas_filter2q.apply(res2q[1])\nmitigated_counts2q = mitigated_results2q.get_counts()\nprint(mitigated_counts2q)\n\nThis works sensibly. However I thought that this is equivalent to applying the inverse of the calibration matrix to the vector of results that I have:\nprint(np.dot(calmatinv2q,n2qvec))\nprint(min(np.dot(calmatinv2q,n2qvec)))\n\nHowever sometimes this returns a negative counts. Obviously this isn't sensible so I assume that the measurement filter takes care of this somehow. Does anyone know how this is done? I wish to be able to do this manually because ideally I will run multiple two qubit circuits in parallel on the same quantum computer. So rather than running 2n2n calibration circuits I will run 4 calibration circuits for each pair of qubits in isolation.\n", "answers": ["\nUnfortunately, the Qiskit textbook does not cover this topic correctly. In general you do get negative values when inverting the calibration matrix. These are called quasiprobabilities. You can use these directly for computing expectation values. Alternatively you can use a bounded least squares method to get the maximum likelihood estimate for the nearest probability distribution. In your case Qiskit is doing the latter.\n"], "comments": [], "link": "https://quantumcomputing.stackexchange.com//questions/18343/manual-measurement-error-mitigation-returning-a-negative-number-of-counts"}