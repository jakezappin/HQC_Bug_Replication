{"question": "\nI wrote this code that uses a swap test to find if 2 pairs of sides are equal.\nFirst, amplitude encoding the 4 sides on 3 qubits then performing the swap test. I'm not sure where my logic went faulty, especially that I'm not very familiar with the logic of swap test yet.\nHere is the code\nimport math\n\ndef is_rectangle(A: int, B: int, C: int, D: int) -> int:\n    # Define quantum circuit with 3 qubits and 1 classical bit\n    qr = QuantumRegister(3)\n    cr = ClassicalRegister(1)\n    qc = QuantumCircuit(qr, cr)\n\n    # Encode the input integers into the state of the first 2 qubits using amplitude encoding\n    alpha = math.acos(math.sqrt(A/float(A**2 + B**2)))\n    beta = math.acos(math.sqrt(B/float(A**2 + B**2)))\n    qc.ry(2*alpha, qr[0])\n    qc.ry(2*beta, qr[1])\n\n    gamma = math.acos(math.sqrt(C/float(C**2 + D**2)))\n    delta = math.acos(math.sqrt(D/float(C**2 + D**2)))\n    qc.ry(2*gamma, qr[2])\n    qc.ry(2*delta, qr[1])\n\n    # Apply a series of SWAP gates to create the entangled state needed for the swap test\n    qc.cx(qr[1], qr[2])\n    qc.cx(qr[0], qr[1])\n    qc.cx(qr[1], qr[2])\n    qc.cx(qr[0], qr[1])\n    qc.cx(qr[1], qr[2])\n\n    # Apply the swap test to determine if the input integers satisfy any of the conditions\n    qc.h(qr[2])\n    qc.cx(qr[2], qr[1])\n    qc.h(qr[2])\n\n    # Measure the third qubit and return the measurement result as the output of the function\n    qc.measure(qr[2], cr[0])\n\n    # Run the quantum circuit using the Qiskit simulator\n    simulator = Aer.get_backend('qasm_simulator')\n    result = execute(qc, simulator, shots=1).result()\n    counts = result.get_counts()\n    if '1' in counts:\n        return 1\n    else:\n        return 0```\n\n", "answers": ["\nI think you may want to change a few things. I've coded up the experiment like this (which should be easy to port to Qiskit and/or use it to correct your circuit):\nFirst - the function signature, the hopefully identical sides should be a1 and a2, as well a b1 and b2. For experimentation, use values in the range of 0.0 - 1.0:\ndef run_experiment(a1: np.complexfloating, a2: np.complexfloating,\n                   b1: np.complexfloating, b2: np.complexfloating) -> float:\n  \"\"\"Construct swap test circuit and measure.\"\"\"\n\n  # The swap circuit is quite simple:\n  #\n  # |0> --- H --- o --- H --- Measure\n  #               |\n  # a1  --------- x ---------\n  #               |\n  # a2  ----------x ---------\n\nCreate a circuit and a few registers, 1 register for each side (I use 2 registers of size 2 below) as well as 2 ancillas:\n  qc = circuit.qc()\n  ab = qc.reg(2, 0)\n  cd = qc.reg(2, 0)\n  anc = qc.reg(2, 0)\n\nNow encode the length into rotations on each of the 4 qubits corresponding to the 4 sides:\n  qc.ry(ab[0], 2 * np.arcsin(a1))\n  qc.ry(ab[1], 2 * np.arcsin(a2))\n  qc.ry(cd[0], 2 * np.arcsin(b1))\n  qc.ry(cd[1], 2 * np.arcsin(b2))\n\nNow, 2 swap tests (from anc[0] and anc[1] to the qubits corresponding to the sides, bracketed by Hadamards:\n  qc.h(anc)\n  qc.cswap(anc[0], ab[0], ab[1])\n  qc.cswap(anc[1], cd[0], cd[1])\n  qc.h(anc)\n\nNow - measurement. In my infra I can just get the probabilities of the ancillas. If the sides were identical, the corresponding probability will be 1.0. If the sides were, for example, maximally different as 0.0 and 1.0, the probability would be 0.5:\n  p0_ab, _ = ops.Measure(qc.psi, anc[0], 0, collapse=False)\n  p0_cd, _ = ops.Measure(qc.psi, anc[1], 0, collapse=False)\n\n  print(f'a1: {a1:.3f} a1: {a2:.3f} b1: {b1:.3f} b2: {b2:.3f}')\n  print(f'p0_ab: {p0_ab:.2f} p0_cd: {p0_cd:.2f} ')\n\nAnd to test:\ndef main(argv):\n  if len(argv) > 1:\n    raise app.UsageError('Too many command-line arguments.')\n\n  run_experiment(1.0, 1.0, 0.5, 0.5)\n\n>>\na1: 1.000 a1: 1.000 b1: 0.500 b2: 0.500\np0_ab: 1.00 p0_cd: 1.00 \n\nOr\n  run_experiment(0.5, 0.6, 0.2, 0.6)\n\n>>\na1: 0.500 a1: 0.600 b1: 0.200 b2: 0.600\np0_ab: 0.99 p0_cd: 0.91 \n```\n\n"], "comments": ["Could you please be more specific about what you're asking? Also its probably better if you edit your original question asking about this instead of opening a new one (quantumcomputing.stackexchange.com/questions/30262/\u2026).", "@forky40 since the user has accepted an answer (admittedly only 7 hours ago, which is after that comment), I don't think this question \"needs more details or clarity\" so I am vote to leave it open. It's a new user and they got what they came for, which make me happy :)", "Thanks a lot for an explanation as thorough and detailed. however, qc() seems to be a custom function and nothing provided by qiskit.circuit, how can I possibly build qc()", "You are right. My implementation is completely independent of Qiskit. Yet, it is similar enough for you to reimplement this with Qiskit. Well, hopefully."], "link": "https://quantumcomputing.stackexchange.com//questions/30279/a-quantum-circuit-to-find-if-4-given-sides-can-form-a-rectangle?r=SearchResults"}