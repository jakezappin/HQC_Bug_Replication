{"question": "\nYou can find a minimal working example below.\nIn particular, I want to replace the scipy.linalg.expm() matrix exponential by a Runge Kutta time evolution method as this becomes quite slow for a larger system size VQEs.\nimport numpy as np\nimport scipy\n\nfrom qiskit import QuantumRegister\nfrom qiskit.circuit import Gate, QuantumCircuit, ParameterVector\n\n\n\n# creates a unitary gate from a list of hamiltonians and parameters\nclass my_hamiltonian_gate(Gate):\n    def __init__(self, num_qubits, hamiltonian_list, theta, label = None):\n        self.hamiltonian_list = hamiltonian_list\n        super().__init__('my_hamiltonian_gate', num_qubits, theta, label=label)\n        \n        \n    def _define(self):\n        qr = QuantumRegister(self.num_qubits)\n        qc = QuantumCircuit(qr)\n        \n        all_qubits = [qr[i] for i in range(self.num_qubits)]\n        \n        time_evolution_unitary = self.to_matrix()\n        qc.unitary(time_evolution_unitary, all_qubits)\n        \n        self.definition = qc\n        \n    def to_matrix(self):\n        \n        hamiltonian = np.zeros(np.shape(self.hamiltonian_list[0]), dtype = np.complex_)\n        \n        for l in range(len(self.params)):\n            curr_param = float(self.params[l])\n            curr_hamiltonian = self.hamiltonian_list[l]\n            \n            hamiltonian += curr_param * curr_hamiltonian\n        \n        unitary = scipy.linalg.expm(-1j * hamiltonian)\n\n        return unitary\n\n\n\nN = 2\nqc = QuantumCircuit(N)\n\nparam = ParameterVector('a', 1)\nparam = [param[0]]\nhamiltonian = [np.ones((4,4), 'float')]\n\nqc.append(my_hamiltonian_gate(N, hamiltonian, param), list(range(N)))\n\nprint(qc)\n```\n\n", "answers": [], "comments": ["Are you asking about Runge-Kutta method in particular? Or any efficient way to represent Hamiltonian evolution as a gate?"], "link": "https://quantumcomputing.stackexchange.com//questions/34431/efficient-gate-executing-the-time-evolution-of-a-hamiltonian-using-runge-kutta-m"}