{"question": "\nI am new of this field.\nI want to make custom Unitary transform. I make a test matrix with Identity matrix.\nIf I use UnitaryGate and append it to main circuit, it would not work.\nHere is my code.\nI know that main_circuit.unitary(matrix_U) works well.\nBut why main_circuit.append(U) does not work?\nfrom qiskit import*\nfrom qiskit.extensions import UnitaryGate\n\nmatrix_U=[[1,0],[0,1]]\nU=UnitaryGate(matrix_U)\nmain_circuit=QuantumCircuit(2,2)\nmain_circuit.append(U)\n%matplotlib inline\nmain_circuit.draw(output='mpl')\n\n\n", "answers": ["\nIn addition to the quantum instruction, append() method expects the qubits to attach the instruction to.\nSo, in your case you should call it as follows:\nmain_circuit.append(U, [0])\n\nHere, I applied the unitary to the first qubit, you can specify another qubit if you want. And if your unitary is a multi-qubit unitary, the list should contain log2(N)log2(N) qubits where NN is the matrix dimension.\n", "\nFor this small case, you dont need to use the UnitaryGate class (which is used with the append method as Egretta.Thula described: append(GateClass, [qubits])). It is possible to give the matrix directly to QuantumCircuit.unitary and the amount of arguments are log2(len(main_circuit)log2(len(main_circuit)):\nfrom qiskit import QuantumCircuit\n\nmatrix_U=[[1,0],[0,1]]\nmain_circuit=QuantumCircuit(1)\nmain_circuit.unitary(matrix_U, 0)\nmain_circuit.draw(output='mpl')\n\n\n"], "comments": ["Welcome to quantum computing StackExchange!", "Thanks, Now main_circuit.append(U,[0]) is working.", "That is a good alternative. Thanks"], "link": "https://quantumcomputing.stackexchange.com//questions/29374/why-circuit-error-when-i-use-appendu?r=SearchResults"}