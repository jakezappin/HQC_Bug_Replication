{"question": "\nI am running the code, which gets the ground state energy with different atomic distances of LiH. However, I encountered this error. The code is as follow\nimport numpy as np import pylab import copy\nfrom qiskit import BasicAer\nfrom qiskit.aqua import QuantumInstance\nfrom qiskit.aqua.algorithms import NumPyMinimumEigensolver, VQE\nfrom qiskit.aqua.components.optimizers import SLSQP\nfrom qiskit.chemistry.components.initial_states import HartreeFock\nfrom qiskit.chemistry.components.variational_forms import UCCSD\nfrom qiskit.chemistry.drivers import PySCFDriver\nfrom qiskit.chemistry.algorithms.ground_state_solvers import GroundStateEigensolver\nfrom qiskit.chemistry.algorithms.ground_state_solvers.minimum_eigensolver_factories import VQEUCCSDFactory\nfrom qiskit.chemistry.transformations import (FermionicTransformation,\n                                              FermionicTransformationType,\n                                              FermionicQubitMappingType)\nfrom qiskit.chemistry.algorithms.ground_state_solvers.minimum_eigensolver_factories import VQEUCCSDFactory\n\nmolecule = 'H .0 .0 -{0}; Li .0 .0 {0}'\ndistances = np.arange(0.5,4.25,0.25)\nvqe_energies = []\nhf_energies = []\nexact_energies = []\nfor i,d in enumerate(distances):\n    print('step', i)\n    #set up the experiment\n    driver = PySCFDriver(molecule.format(d/2), basis='sto3g')\n    fermionic_transformation = FermionicTransformation(\n            transformation=FermionicTransformationType.FULL,\n            qubit_mapping=FermionicQubitMappingType.JORDAN_WIGNER,\n            two_qubit_reduction=False,\n            freeze_core=False)\n    qubit_op, aux_ops = fermionic_transformation.transform(driver)\n    #VQE\n    optimizer = SLSQP(maxiter=1000)\n    initial_state = HartreeFock(fermionic_transformation.molecule_info['num_orbitals'],\n                                        fermionic_transformation.molecule_info['num_particles'],\n                                        qubit_mapping=fermionic_transformation.qubit_mapping,\n                                        two_qubit_reduction=fermionic_transformation._two_qubit_reduction)\n    #VQE\n    vqe_solver = VQEUCCSDFactory(QuantumInstance(BasicAer.get_backend('statevector_simulator')),\n                                 optimizer,\n                                 initial_state)\n    calc = GroundStateEigensolver(fermionic_transformation, vqe_solver)\n    res = calc.solve(driver)\n    print(res)\n\nThe traceback is here\n  File \"/home/ironmanaudi/research/VQE/VQE_tutorial/LiH_VQE.py\", line 76, in <module>\n    res = calc.solve(driver)\n  File \"/home/ironmanaudi/anaconda3/lib/python3.8/site-packages/qiskit/chemistry/algorithms/ground_state_solvers/ground_state_eigensolver.py\", line 102, in solve\n    raw_mes_result = solver.compute_minimum_eigenvalue(operator, aux_operators)\n  File \"/home/ironmanaudi/anaconda3/lib/python3.8/site-packages/qiskit/aqua/algorithms/minimum_eigen_solvers/vqe.py\", line 494, in compute_minimum_eigenvalue\n    return self._run()\n  File \"/home/ironmanaudi/anaconda3/lib/python3.8/site-packages/qiskit/aqua/algorithms/minimum_eigen_solvers/vqe.py\", line 429, in _run\n    vqresult = self.find_minimum(initial_point=self.initial_point,\n  File \"/home/ironmanaudi/anaconda3/lib/python3.8/site-packages/qiskit/aqua/algorithms/vq_algorithm.py\", line 172, in find_minimum\n    if initial_point is not None and len(initial_point) != nparms:\nTypeError: object of type 'HartreeFock' has no len()\n\nWhen change the syntax of getting the result to\nres = calc.solve(driver, aux_ops)\n\nthe error becomes\nFile \"/home/ironmanaudi/research/VQE/VQE_tutorial/LiH_VQE.py\", line 70, in <module>\n    res = calc.solve(driver, aux_ops)\n  File \"/home/ironmanaudi/anaconda3/lib/python3.8/site-packages/qiskit/chemistry/algorithms/ground_state_solvers/ground_state_eigensolver.py\", line 90, in solve\n    operator, aux_operators = self.transformation.transform(driver, aux_operators)\n  File \"/home/ironmanaudi/anaconda3/lib/python3.8/site-packages/qiskit/chemistry/transformations/fermionic_transformation.py\", line 152, in transform\n    ops, aux_ops = self._do_transform(q_molecule, aux_operators)\n  File \"/home/ironmanaudi/anaconda3/lib/python3.8/site-packages/qiskit/chemistry/transformations/fermionic_transformation.py\", line 358, in _do_transform\n    _add_aux_op(aux_op, name)\n  File \"/home/ironmanaudi/anaconda3/lib/python3.8/site-packages/qiskit/chemistry/transformations/fermionic_transformation.py\", line 289, in _add_aux_op\n    aux_qop = FermionicTransformation._map_fermionic_operator_to_qubit(\n  File \"/home/ironmanaudi/anaconda3/lib/python3.8/site-packages/qiskit/chemistry/transformations/fermionic_transformation.py\", line 645, in _map_fermionic_operator_to_qubit\n    qubit_op = fer_op.mapping(map_type=qubit_mapping, threshold=0.00000001)\nAttributeError: 'SummedOp' object has no attribute 'mapping'\n\nCan anybody tell me how to work this out?\n", "answers": ["\nAgain here you are mixing some things. The initial_state in the VQE (that again you assign in the initial_points) is the starting values of the variational parameters. You have already specified the initial_state in the var_form. Then you should provide a solver in the calc and not run the solver manually. The code that works is here:\nimport numpy as np\nimport pylab\nimport copy\nfrom qiskit import BasicAer\nfrom qiskit.aqua import QuantumInstance\nfrom qiskit.aqua.algorithms import NumPyMinimumEigensolver, VQE\nfrom qiskit.aqua.components.optimizers import SLSQP\nfrom qiskit.chemistry.components.initial_states import HartreeFock\nfrom qiskit.chemistry.components.variational_forms import UCCSD\nfrom qiskit.chemistry.drivers import PySCFDriver, UnitsType, Molecule\nfrom qiskit.chemistry.algorithms.ground_state_solvers import GroundStateEigensolver\nfrom qiskit.chemistry.algorithms.ground_state_solvers.minimum_eigensolver_factories import VQEUCCSDFactory\nfrom qiskit.chemistry.transformations import (FermionicTransformation,\n                                              FermionicTransformationType,\n                                              FermionicQubitMappingType)\nfrom qiskit.chemistry.algorithms.ground_state_solvers.minimum_eigensolver_factories import VQEUCCSDFactory\n\n\ndistances = np.arange(0.5,4.25,0.25)\nvqe_energies = []\nhf_energies = []\nexact_energies = []\n\n\nfor i,d in enumerate(distances):\n    print('step', i)\n    \n    #set up the experiment\n    molecule = Molecule(geometry=[['H', [0., 0., -1*(d/2)]],\n                              ['H', [0., 0., (d/2)]]],\n                     charge=0, multiplicity=1)\n    driver = PySCFDriver(molecule = molecule, unit=UnitsType.ANGSTROM, basis='sto3g')\n    fermionic_transformation = FermionicTransformation(\n            transformation=FermionicTransformationType.FULL,\n            qubit_mapping=FermionicQubitMappingType.JORDAN_WIGNER,\n            two_qubit_reduction=False,\n            freeze_core=False)\n    \n    qubit_op, aux_ops = fermionic_transformation.transform(driver)\n\n    #VQE\n    optimizer = SLSQP(maxiter=1)\n    initial_state = HartreeFock(fermionic_transformation.molecule_info['num_orbitals'],\n                                        fermionic_transformation.molecule_info['num_particles'],\n                                        qubit_mapping=fermionic_transformation.qubit_mapping,\n                                        two_qubit_reduction=fermionic_transformation._two_qubit_reduction)\n    var_form = UCCSD(num_orbitals=fermionic_transformation.molecule_info['num_orbitals'],\n                              num_particles=fermionic_transformation.molecule_info['num_particles'],\n                              initial_state=initial_state,\n                              qubit_mapping=fermionic_transformation.qubit_mapping,\n                              two_qubit_reduction=fermionic_transformation._two_qubit_reduction)\n    \n    vqe_solver = VQE(qubit_op,var_form,optimizer, quantum_instance=QuantumInstance(BasicAer.get_backend('statevector_simulator')))\n    \n    calc = GroundStateEigensolver(fermionic_transformation, vqe_solver)\n    \n    res = calc.solve(driver)\n    \n    vqe_energies.append(res.computed_energies[0])\n\nI also removed the double definition of the driver. Maybe consider the tutorials here: Ground_state_solver\n", "\nSeems like you are mixing a couple of things here. The VQEUCCSDFactory uses the HartreeFock state as an initial_state by default. See also here VQEUCCSDFactory. The initial_point that you are specifying is the initial values of the variational parameters to start the optimization from.\nOne more point, seeing you snippet seems like you want to calculate a PES and you may want to take a look also to our BOPES Sampler tutorials here BOPES tutorial\n.\nHope this helps.\n", "\nThe first method is as the following\nimport numpy as np\nimport pylab\nimport copy\nfrom qiskit import BasicAer\nfrom qiskit.aqua import QuantumInstance\nfrom qiskit.aqua.algorithms import NumPyMinimumEigensolver, VQE\nfrom qiskit.aqua.components.optimizers import SLSQP\nfrom qiskit.chemistry.components.initial_states import HartreeFock\nfrom qiskit.chemistry.components.variational_forms import UCCSD\nfrom qiskit.chemistry.drivers import PySCFDriver, UnitsType, Molecule\nfrom qiskit.chemistry.algorithms.ground_state_solvers import GroundStateEigensolver\nfrom qiskit.chemistry.algorithms.ground_state_solvers.minimum_eigensolver_factories import VQEUCCSDFactory\nfrom qiskit.chemistry.transformations import (FermionicTransformation,\n                                              FermionicTransformationType,\n                                              FermionicQubitMappingType)\nfrom qiskit.chemistry.algorithms.ground_state_solvers.minimum_eigensolver_factories import VQEUCCSDFactory\n\n\ndistances = np.arange(0.5,4.25,0.25)\nvqe_energies = []\nhf_energies = []\nexact_energies = []\n\n\nfor i,d in enumerate(distances):\n    print('step', i)\n    \n    #set up the experiment\n    molecule = Molecule(geometry=[['H', [0., 0., -1*(d/2)]],\n                              ['H', [0., 0., (d/2)]]],\n                     charge=0, multiplicity=1)\n    driver = PySCFDriver(molecule = molecule, unit=UnitsType.ANGSTROM, basis='sto3g')\n    fermionic_transformation = FermionicTransformation(\n            transformation=FermionicTransformationType.FULL,\n            qubit_mapping=FermionicQubitMappingType.JORDAN_WIGNER,\n            two_qubit_reduction=False,\n            freeze_core=False)\n    \n    # qubit_op, aux_ops = fermionic_transformation.transform(driver)\n    driver = PySCFDriver(molecule = molecule, unit=UnitsType.ANGSTROM, basis='sto3g')\n\n    #VQE\n    optimizer = SLSQP(maxiter=1000)\n    vqe_solver = VQEUCCSDFactory(QuantumInstance(BasicAer.get_backend('statevector_simulator')), optimizer)\n    \n    calc = GroundStateEigensolver(fermionic_transformation, vqe_solver)\n    res = calc.solve(driver)\n    vqe_energies.append(res.computed_energies[0])\n\nThe second method :\nimport numpy as np\nimport pylab\nimport copy\nfrom qiskit import BasicAer\nfrom qiskit.aqua import QuantumInstance\nfrom qiskit.aqua.algorithms import NumPyMinimumEigensolver, VQE\nfrom qiskit.aqua.components.optimizers import SLSQP\nfrom qiskit.chemistry.components.initial_states import HartreeFock\nfrom qiskit.chemistry.components.variational_forms import UCCSD\nfrom qiskit.chemistry.drivers import PySCFDriver, UnitsType, Molecule\nfrom qiskit.chemistry.algorithms.ground_state_solvers import GroundStateEigensolver\nfrom qiskit.chemistry.algorithms.ground_state_solvers.minimum_eigensolver_factories import VQEUCCSDFactory\nfrom qiskit.chemistry.transformations import (FermionicTransformation,\n                                              FermionicTransformationType,\n                                              FermionicQubitMappingType)\nfrom qiskit.chemistry.algorithms.ground_state_solvers.minimum_eigensolver_factories import VQEUCCSDFactory\n\n\ndistances = np.arange(0.5,4.25,0.25)\nvqe_energies = []\nhf_energies = []\nexact_energies = []\n\n\nfor i,d in enumerate(distances):\n    print('step', i)\n    \n    #set up the experiment\n    molecule = Molecule(geometry=[['H', [0., 0., -1*(d/2)]],\n                              ['H', [0., 0., (d/2)]]],\n                     charge=0, multiplicity=1)\n    driver = PySCFDriver(molecule = molecule, unit=UnitsType.ANGSTROM, basis='sto3g')\n    fermionic_transformation = FermionicTransformation(\n            transformation=FermionicTransformationType.FULL,\n            qubit_mapping=FermionicQubitMappingType.JORDAN_WIGNER,\n            two_qubit_reduction=False,\n            freeze_core=False)\n    \n    qubit_op, aux_ops = fermionic_transformation.transform(driver)\n    driver = PySCFDriver(molecule = molecule, unit=UnitsType.ANGSTROM, basis='sto3g')\n\n\n    vqe_solver = VQEUCCSDFactory(QuantumInstance(BasicAer.get_backend('statevector_simulator')))\n    \n    #VQE\n    optimizer = SLSQP(maxiter=1000)\n    initial_state = HartreeFock(fermionic_transformation.molecule_info['num_orbitals'],\n                                        fermionic_transformation.molecule_info['num_particles'],\n                                        qubit_mapping=fermionic_transformation.qubit_mapping,\n                                        two_qubit_reduction=fermionic_transformation._two_qubit_reduction)\n    var_form = UCCSD(num_orbitals=fermionic_transformation.molecule_info['num_orbitals'],\n                              num_particles=fermionic_transformation.molecule_info['num_particles'],\n                              initial_state=initial_state,\n                              qubit_mapping=fermionic_transformation.qubit_mapping,\n                              two_qubit_reduction=fermionic_transformation._two_qubit_reduction)\n    vqe_solver = VQE(qubit_op,var_form,optimizer,initial_state)\n    vqe_solver = vqe_solver.run(QuantumInstance(BasicAer.get_backend('statevector_simulator')))\n    \n    \n    \n    calc = GroundStateEigensolver(fermionic_transformation, vqe_solver)\n    res = calc.solve(driver)\n    vqe_energies.append(res.computed_energies[0])\n```\n\n"], "comments": ["It seems like the problem is with the initial_state.", "Thanks very much. The problem has been solved.", "Thanks, the answer is very helpful. I notice there are two ways to define a VQE algorithm. The first way is to use the 'VQEUCCSDFactory' object; the second way is to use the VQE object. I correct the code, but find there is still a problem with the second method, could you help me with it? I put the code of both methods in the next answer."], "link": "https://quantumcomputing.stackexchange.com//questions/15777/error-when-running-vqe-in-qiskit"}