{"question": "\nI am running variational algorithms using QuasmSimulator, which means I am performing a classical optimization where the cost function is computed running a quantum circuit. Moreover, for the optimizer to converge I need high accuracy, which implies a large number of shots.\nThese two things combined make a run last for days on my laptop, even for a few qubits. Thus, I am trying to run shots in parallel to save some time. Qiskit has a backend option for this:\nfrom qiskit.providers.aer import QasmSimulator\nbackend = QasmSimulator(method=\"automatic\", max_parallel_threads=6, max_parallel_shots=6)\n\n... the rest of the code...\n\njob = execute(circ, backend, shots=nshots)\n\nHowever, when setting this option I see no difference, neither in runtime nor in CPU usage from Window's task manager. I think the problem could be that normally a python script just uses one core, so when Qiskit runs it \"thinks\" that indeed you have one core only. Any suggestion?\nI am using Qiskit 0.23.0\n(Note that I asking specifically about parallel shots and not parallel circuits, although that might also help with another issue I have)\n", "answers": ["\nThere is a question which is quite alike to your problem in Quantum Computing-stack exchange. I have answered it before, you may see that.\nI think the number of shots nearly does not change the running time(although I have been voted -1), you can see the problem and answers yourself.\nJust for short, I think after qiskit evaluates the state vector, it gives you measurement results based on that state vector, instead of evaluate state vector nn times and gives you one measurement result each time(I guess, since if you import the time package and observe the time consumed about different shots you won't see a pattern that the consumed time grows with the number of shots).\n", "\nCompiling the standalone qasm simulator (https://github.com/Qiskit/qiskit-aer) and feeding it your circuit in QASM format (execution from your command line) should allow you to be free of the Python interpreter process' thread limits.\n"], "comments": ["Not answering your question, this is a comment about simulation for calculating an expectation value. Depending on your circuit (e.g. does it contain intermediate measurements) and what you're looking for (e.g. do you simulate a noisy device), there are cases where you can run a single shot and use the expectation value snapshot, which calculates <psi|O|psi>, where |psi> is the state and O is the obervable.", "Also, you may find the variational solvers in Qiskit Aqua useful", "You can get short runtime indeed if you just use the state vector simulator, which is exact and performs matrix-vector multiplications etc. Perhaps that's what you mean by \"one shot\". However, if you are simulating a QC functioning, obviously it's impossible to get a one-shot result. In that case, you would just get a reading that is 1 or 0 which does not hold any info. You need to sample many times until you have a meaningful ration of 1s/0s. Or did I misunderstood you?", "Yes, you understood correctly", "I am also interested in statistical error introduced by a finite sampling of the expectation value, so, unfortunately, I can't bypass the problem as you suggest.", "I think the number of threads Python is running in shouldn't matter since the simulator itself is implemented in C++.  It looks like the defaults for both max_parallel_threads and shots should be to just use all your cores, so manually setting it to 6 shouldn't matter.   Sorry, know that does not actually suggest a fix.", "It looks like even if a value is explicitly supplied the minimum value between what you supply and the max thread count according to OpenMP is what is used.  So OpenMP might not be detecting the max thread count properly?  (Or OpenMP is not available and parallelization is just disabled entirely...) github.com/Qiskit/qiskit-aer/blob/\u2026", "What you say it's partially true but I don't think it holds for my case because I am running with more than an order of magnitude more shots (order 10^6). For instance, in your example, it's 5 second out of 45 due to the number of shot increase. In my case that would become a 50 seconds increase which effectively doubles the runtime.", "I know what you mean, even you import np.random.random to generate some numbers, the process takes time, right? In my earlier answer, I tested a 10^5 case for about 20 qubits, but if I enlarge the number of shots to 10^6 it can hardly change much because in my case the main part(even the overwhelming part) is still to get the state vector of the 20-qubit state.", "But when you refer to using multiple cores to run multiple codes, I am not familiar with such a thing (like how many cores python use by default), so this answer might just be a bit of tiny advice.", "To your first comment: I am quite sure that's not the case. If you are curious, I invite you to run the same experiment with 1e6 shots and check. When it comes to python, I am no computer scientist myself but you can just check that it uses one processor by opening the task manager while running any intensive task and you'll see what I mean."], "link": "https://quantumcomputing.stackexchange.com//questions/14665/parallel-shots-on-qiskit?r=SearchResults"}