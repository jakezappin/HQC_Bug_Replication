{"question": "\nI made this post a while ago, where I learned I could use qiskit's VQE to calculate (or approximate) the Transverse Field Ising Hamiltonian and other similar Hamiltonians. After working with my code for a while, I managed to write the \"functional programming version\" that I wanted, and I started testing it.\nMy concern comes from the fact that every time I run the VQE, I may get very different results, despite not messing with the ansatz, the optimizer, the initial point or the Hamiltonian. Upon searching about it, I found this thread saying that if you don't set an initial point, it may be chosen at random. I tried to set the seed myself as suggested there, or setting a zero initial point list to pass as the parameter, but neither seemed to change the inconsistency. Is this somehow justified? Can it be fixed or is it something that I'm going to have to deal with? I've tried researching this myself, but there don't seem to be any good sources online that don't require a high-level understanding of the papers they are based on.\nBelow I'm showing you an example, and how different the results I'm getting can be.\nLet's say that I have the following 3-site Ising chain Hamiltonian.\nfrom qiskit.opflow import Z, X, I, Zero\nh = 0\nH = -(Z^Z^I)-(I^Z^Z)-h*((X^I^I)+(I^X^I)+(I^I^X)) #3-site Hamiltonian\n\nFor h=0 (as specified here with great detail) you should expect results that show every spin in the -z direction, that is |000> in this case. So I set up the VQE like so\nfrom qiskit.providers.aer import QasmSimulator  \nfrom qiskit.algorithms import VQE\nfrom qiskit.algorithms.optimizers import COBYLA \nfrom qiskit.circuit.library import EfficientSU2\nfrom qiskit.visualization import plot_histogram\n\nbackend = QasmSimulator()\n\n\noptimizer = COBYLA(maxiter=1000)\nansatz = EfficientSU2(3)\nvqe = VQE(ansatz, optimizer, quantum_instance=backend)\nresult = vqe.compute_minimum_eigenvalue(H)  \n\ngroundstates = probability_calculator(result)\n#this is a function that I wrote to take\n#VQE results and output probabilities with qiskit's histogram functions. It doesn't\n#matter here since I've tested it and know it's not the reason for the\n#inconsistencies\n#(or you can just ignore this if you don't trust me and check the \"raw\" VQE results\n#provided in the screenshots below).\nplot_histogram(groundstates)\n\nNow I run this snippet of code 6-7 times. First and second time, I get the following result (with a bit of a difference in probabilities, obviously)\n\nThe third time, I get the following result, which is a completely \"flipped\" version of the one I'm expecting\n\nThe last time I run it, I get the following results\n\nIt really makes no sense with my knowledge why this happens. I obviously chose a very simple case to demonstrate here, just to prove my point without having to mess with the math. You can do the same for h=100 where you would expect an equal superposition. The results look overall better (statistically speaking), but you will occasionally get a result that makes no sense.\nTo clarify my question once again: The VQE runs a minimum of 1000 times. What I don't get is how it can yield such different results without messing with the code at all, just because you rerun it. I can't find myself if this inconsistency is expected, or if I'm missing something I should have taken into account.\n", "answers": [], "comments": ["But in the code you shared you don't set an initial point, right?", "That is correct, I skipped setting an initial_point or seed in my code because it didn't change my results. Do you think it could still be the root of the inconsistencies? Would you mind suggesting me an (even a simple one) initial point to try? I used np.zeros() for my tests.", "setting the initial point can help with getting consistent answer... but even then you might run into cases where you don't get a truly global minimum answer.. however, you will at least get a more consistent local min solution.... :)", "In this case, any extra sources or info on how to construct a decent initial point is welcome. I tried looking it up but all the info is about quantum chemistry (interatomic distances), which I have no idea about in order to adjust to my problem.", "If you have found a solution for a nearby geometry configuration, for instance you found the right parameters for the geometry configuration of LiH at 1.5 Angstrom, and now you want to perform VQE on the geometry config at 1.6 Angstrom, then you might want to initialize your parameters with the optimal parameters you found from 1.5 Angstrom... this is called \"Bootstrapping\".", "There are 3 seeds that can be set - one for qiskit algorithms, that seeds any random functions it uses, such as computing a random initial point if none is supplied, that you seem to have tried. There are also two others, one is around transpilation of circuits, the other is for simulation such as the result sampling to return counts. For unit testing we set all 3 to ensure that results are reproducible for testing. See this vqe test for instance github.com/Qiskit/qiskit-terra/blob/main/test/python/algorithms/\u2026", "I tried something similar to what KAJ226 said, although I'm not working on chemistry. What I've done is run the vqe once for a random initial_point and then take the optimal point parameters and run the vqe again with them as the initial point. In this case, the least I can confirm is that indeed the results I get are consistent. What I'm not sure about is if this is essentially \"cheating\", since I choose the first optimal parameters knowing that they correspond to an acceptable solution. If no one answers my question, I will write a detailed answer to myself once I've figured out the details."], "link": "https://quantumcomputing.stackexchange.com//questions/17956/are-inconsistent-results-between-different-vqe-runs-justified"}