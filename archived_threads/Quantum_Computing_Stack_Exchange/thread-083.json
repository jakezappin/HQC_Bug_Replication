{"question": "\nI'm coding a 429 element length string to compare to other same length strings, but I keep getting that error. I used ljust to fill the string to a 512 element length. I'm using 2 qubits for coding and 7 for indexing.\nimport numpy as np\nfrom math import ceil, log2\nfrom qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit.extensions import Initialize\n\nbitstring = \"ATGGTGCTGTCTGCGGCTGACAAGACCAACGTCAAGGGTGTCTTCTCCAAAATCGGTGGC\\\nCATGCTGAGGAGTATGGCGCCGAGACCCTGGAGAGGATGTTCATCGCCTACCCCCAGACC\\\nAAGACCTACTTCCCCCACTTTGACCTGCAGCACGGCTCTGCTCAGATCAAGGCCCATGGC\\\nAAGAAGGTGGCGGCTGCCCTAGTTGAAGCTGTCAACCACATCGATGACATTGCGGGTGCT\\\nCTCTCCAAGCTCAGTGACCTCCACGCCCAAAAGCTCCGTGTGGACCCTGTCAACTTCAAA\\\nTTCCTGGGCCACTGCTTCCTGGTGGTGGTTGCCATCCACCACCCCGCTGCCCTGACCCCA\\\nGAGGTCCACGCTTCCCTGGACAAGTTCATGTGCGCCGTGGGTGCTGTGCTGACTGCCAAG\\\nTACCGTTAG\"\nbitstring = bitstring.ljust(512, 'A')\nbitstring_len = len(bitstring)\nbitstring = bitstring.replace(\"A\", \"00\")\nbitstring = bitstring.replace(\"C\", \"01\")\nbitstring = bitstring.replace(\"G\", \"10\")\nbitstring = bitstring.replace(\"T\", \"11\")\nn = ceil(log2(len(bitstring))) + 1\namplitude = np.sqrt(1.0/2**(n-1))\n\ndesired_vector = np.array(list(bitstring))\ndesired_vector = [int(x) for x in desired_vector]\ndesired_vector = np.multiply(desired_vector,amplitude)\n    \nqr = QuantumRegister(n)\ncr = ClassicalRegister(n)\nqc = QuantumCircuit(qr, cr)\n\nqc_init = QuantumCircuit(n) \ninverse_qc_init = QuantumCircuit(n)\n\nIn the last line I get the error\nQiskitError: 'Sum of amplitudes-squared does not equal one.'\nAny help would be appreciated. Thanks\n", "answers": ["\nIn this row:\ndesired_vector = [int(x) for x in desired_vector]\n\nYou set the varibale desired_vector to be a vector with 1024 entries of zeros and ones, something of the form:\n\u23a1\u23a3\u23a2\u23a2\u23a2\u23a2\u23a2\u23a2010\u22ef0\u23a4\u23a6\u23a5\u23a5\u23a5\u23a5\u23a5\u23a5\nAnd then in the row after:\ndesired_vector = np.multiply(desired_vector,amplitude)\n\nYou are trying to normalize the vector by multiplying it with a normalization factor of 11024\u221a. But this normzalization factor is erroneous in that case - It would have been OK if desired_vector\u2018s magnitude would have been 32=1024\u2212\u2212\u2212\u2212\u221a - Like in the case where all the 1024 entries are 1, for example.\nA normalized version of a vector is a vector in the same \"direction\" but of magnitude 1 - Given a vector v of dimension N, its norm is ||v||=v20+v21+\u22ef+v2N\u22121\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u221a, and its normalized version is v||v||.\nA normalized version of a vector is not dividing a vector by its dimension (that's what the code above is doing).\nAs @KAJ226 mentioned - this issue can easily be solved using the np.linalg.norm() method - which calculates the norm for a given vector. Then we normalize by dividing the vector by its norm.\nIn your piece of code, replace this:\namplitude = np.sqrt(1.0/2**(n-1))\ndesired_vector = np.array(list(bitstring))\ndesired_vector = [int(x) for x in desired_vector]\ndesired_vector = np.multiply(desired_vector,amplitude)\n\nwith this:\ndesired_vector = np.array(list(bitstring))\ndesired_vector = [int(x) for x in desired_vector]\nnorm = np.linalg.norm(desired_vector)\ndesired_vector = desired_vector / norm\n\nAnd now desired_vector is properly normalized. If you initialize a quantum circuit of 10 qubits (210=1024) with this vector, it should be fine. For 9 qubits you need a 512-dimensional vector.\n"], "comments": ["Just normalized the state. Just divide the state by its norm. For example: x = x/np.linalg.norm(x)", "It's the entire code", "It seems like it is not the entire code, but anyway I have modified my answer with a proper explanation."], "link": "https://quantumcomputing.stackexchange.com//questions/27652/qiskiterror-sum-of-amplitudes-squared-does-not-equal-one?r=SearchResults"}