{"question": "\nBased on the useful straight-forward answers to both of my former questions, on multiple rotations of a qubit and bloch sphere subplots, I was able to implement the following SU(2)SU(2) rotations:\n\nAt this point it is worth mentioning that (as a learner) I am really grateful for the high-quality support. The code looks as follows (I mainly used the sources \"A Lie Group: Rotations in Quantum Mechanics\", p. 67 from Jean-Marie Normand or equivalently A Representations of SU(2) and Lecture notes: Qubit representations and rotations, p. 3):\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom matplotlib import colors\nfrom qiskit.visualization.bloch import Bloch\nfrom qiskit.visualization import plot_bloch_vector\nfrom sympy.physics.matrices import msigma\nfrom sympy.physics.quantum.dagger import Dagger\nfrom sympy import Matrix\nfrom sympy import I, N, re, exp, sin, cos, pi, eye\nimport numpy as np\n\ndef to_spherical(vec):\n    x = np.real(vec[0])\n    y = np.real(vec[1])\n    z = np.real(vec[2])\n    hxy = np.hypot(x, y)\n    r = np.hypot(hxy, z)\n    \u03d5 = np.arctan2(y, x) #az\n    \u03b8 = np.arctan2(hxy, z) #el\n    return [r, \u03d5, \u03b8]\n\ndef to_cartesian(polar):\n    r = polar[0]\n    \u03d5 = polar[1]\n    \u03b8 = polar[2]\n\n    x = r * np.sin(\u03b8) * np.cos(\u03d5)\n    y = r * np.sin(\u03b8) * np.sin(\u03d5)\n    z = r * np.cos(\u03b8)\n    return [np.real(x), np.real(y), np.real(z)]\n\ndef rn_su2_euler(vec, rx, ry, rz):\n    spherical_vec = to_spherical(vec)\n    \u03d5 = spherical_vec[1]\n    \u03b8 = spherical_vec[2]\n\n    sx = msigma(1)\n    sy = msigma(2)\n    sz = msigma(3)\n    M_q = (np.sin(\u03b8)*np.cos(\u03d5)*sx + np.sin(\u03b8)*np.sin(\u03d5)*sy + np.cos(\u03b8)*sz)\n    U_n = Matrix([[exp(-I*(rx+rz)/2)*cos(ry/2), -exp(-I*(rx-rz)/2)*sin(ry/2)], [exp(I*(rx-rz)/2)*sin(ry/2), exp(I*(rx+rz)/2)*cos(ry/2)]])\n    M_q_rotated = U_n*M_q*Dagger(U_n)\n    return M_q_rotated\n\ndef extract_angles(M_q_rotated):\n    cos_\u03b8_rotated = float(N(re(M_q_rotated[0,0])))\n    \u03b8_rotated = np.arccos(cos_\u03b8_rotated)\n    temp = float(N(re(M_q_rotated[1,0])))\n    temp = temp/np.sin(\u03b8_rotated)\n    \u03d5_rotated = np.arccos(temp)\n    return (\u03d5_rotated, \u03b8_rotated)\n\ndef get_gradient_colors(rgb, n):\n    red=rgb[0] \n    yel=rgb[1]\n    blu=rgb[2]\n    result = [colors.to_hex([red,yel,blu])]\n    cr = red/n\n    cy = yel/n\n    cb = blu/n\n    for i in range(n):\n        if(red!=0):\n            red -= cr \n        if(yel!=0):\n            yel -= cy\n        if(blu!=0):\n            blu -= cb\n        result.append(colors.to_hex([red,yel,blu]))\n    return result\n\nfig, ax = plt.subplots(figsize = [8, 12], nrows=3, ncols=2)\nfig.patch.set_facecolor('white')\n[axis.set_axis_off() for axis in ax.ravel()]\n\nrotations = [[0, 0, pi/8], [0, 0, pi/8], [0, pi/8, 0], [0.00001, -pi/8, 0], [0, pi/8, pi/8], [0, pi/8, -pi/8]]\nstart_vec = [1, 0, 0]\nnum_iterations = 8\n\nfor m, rotation in enumerate(rotations):\n    ax = fig.add_subplot(320+(m+1), axes_class = Axes3D)\n    \n    rot_x = rotation[0]\n    rot_y = rotation[1]\n    rot_z = rotation[2]\n    _bloch = Bloch(axes=ax)\n    _bloch.vector_color = get_gradient_colors([0, 0, 1], num_iterations)\n    _bloch.vector_width = 1\n    sv = []\n    vec = start_vec\n    sv.append(vec)\n    for i in range(num_iterations):\n        M_q_rotated = rn_su2_euler(vec, rot_x, rot_y, rot_z)\n        (\u03d5_rotated, \u03b8_rotated) = extract_angles(M_q_rotated)\n        vec = np.array(to_cartesian([1, \u03d5_rotated, \u03b8_rotated]))\n        sv.append(vec)\n\n    _bloch.add_vectors(sv)\n    _bloch.render()\n\nMy question: How can I achieve that the vectors (mirrored) cover the second half of the hemisphere? Analogous to this: How can I make the vectors in the lower right image cover the other half of the hemisphere? What I understood from the sources is that in the function rn_su2_euler the parameters that are the Euler angles rx can take a value from 00 to 2\u03c02\u03c0 and ry a value from 00 to \u03c0\u03c0 and rz from 00 to 4\u03c04\u03c0, see for example A Representations of SU(2). But somewhere it seems that there is still a minor bug.\nFor the sake of completeness, I uploaded the notebook here to GitHub.\n", "answers": ["\nThe function rn_su2_euler needs some adjustments.\ndef rn_su2_euler(vec, rx, ry, rz, plot=False):\nstabilized_vec = np.array(vec)+0.000001\nspherical_vec = to_spherical(stabilized_vec)\n\u03d5 = spherical_vec[1]\n\u03b8 = spherical_vec[2]\nif plot: print(f'Initial vector: \\t{vec}.')\nif plot: print(f'Spherical coords: \\t{spherical_vec}.')\n\n# https://www.phys.hawaii.edu/~yepez/Spring2013/lectures/Lecture1_Qubits_Notes.pdf (p. 3)\n\nsx = msigma(1)\nsy = msigma(2)\nsz = msigma(3)\nM_q = (np.sin(\u03b8)*np.cos(\u03d5)*sx + np.sin(\u03b8)*np.sin(\u03d5)*sy + np.cos(\u03b8)*sz)\n\nif plot: print(f'#{i}: M_q={M_q}')\nr_hat = np.array([rx, ry, rz])\nr = np.sqrt(float(np.tensordot(r_hat, r_hat, axes=1)))\n\nif plot: print(f'Rotation angle = {r}')\nn_hat = r_hat/(r)\nsigma_hat = np.array([sx, sy, sz])\nn_sigma_product = Matrix(np.tensordot(n_hat,sigma_hat, axes=1))\n\n\nU_n = N(exp(-1j*n_sigma_product*r/2))\n#U_n_syntetic = [[np.cos(r/2), -1j*np.sin(r/2)],[-1j*np.sin(r/2), np.cos(r/2)]]\n\n\nM_q_rotated = N(U_n*M_q*Dagger(U_n))\n# Source: https://en.wikipedia.org/wiki/Pauli_matrices#Pauli_vector\n\nq_1 = re((M_q_rotated[0,1]+M_q_rotated[1,0])/2)\nq_2 = re((M_q_rotated[1,0]-M_q_rotated[0,1])/2j)\nq_3 = re(M_q_rotated[0,0])\nq_rotated = [np.real(N(q_1)), np.real(N(q_2)), np.real(N(q_3))]\nreturn q_rotated\n\nThus, the rotation works in both directions and reaches all parts of the circle.\nThe call of this would have to be revised accordingly.\nThe output at the end can then look like this:\n\nI have provided a possible and working implementation on this GitHub page.\n", "\nTo elaborate the concrete error in my OP, I refer to Fations answer. The key is how he translates the matrix form of a qubit state M_q at the end of his algorithm. The original rotation function is not the problem.\nI ammemded the code as follows:\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom matplotlib import colors\nfrom qiskit.visualization.bloch import Bloch\nfrom sympy.physics.matrices import msigma\nfrom sympy.physics.quantum.dagger import Dagger\nfrom sympy import Matrix\nfrom sympy import I, N, re, exp, sin, cos, sqrt, pi, eye\nimport numpy as np\n\ndef cartesian_to_spherical(vec):\n    x = np.real(vec[0])\n    y = np.real(vec[1])\n    z = np.real(vec[2])\n    hxy = np.hypot(x, y)\n    r = np.hypot(hxy, z)\n    \u03d5 = np.arctan2(y, x) #az\n    \u03b8 = np.arctan2(hxy, z) #el\n    return [r, \u03d5, \u03b8]\n\ndef qubitmatrix_to_cartesian(M_q):\n    M_q = N(M_q)\n    q_1 = re((M_q[0,1] + M_q[1,0]) / 2)\n    q_2 = re((M_q[0,1] - M_q[1,0]) / 2*I)\n    q_3 = re(M_q[0,0])\n    return np.array([q_1, q_2, q_3], dtype=np.float64)\n\ndef get_gradient_colors(rgb, n):\n    red=rgb[0] \n    yel=rgb[1]\n    blu=rgb[2]\n    result = [colors.to_hex([red,yel,blu])]\n    cr = red/n\n    cy = yel/n\n    cb = blu/n\n    for i in range(n):\n        if(red!=0):\n            red -= cr \n        if(yel!=0):\n            yel -= cy\n        if(blu!=0):\n            blu -= cb\n        result.append(colors.to_hex([red,yel,blu]))\n    return result\n\ndef rn_su2_euler(vec, rx, ry, rz):\n    spherical_vec = cartesian_to_spherical(vec)\n    \u03d5 = spherical_vec[1]\n    \u03b8 = spherical_vec[2]\n    sx = msigma(1)\n    sy = msigma(2)\n    sz = msigma(3)\n    M_q = (np.sin(\u03b8)*np.cos(\u03d5)*sx + np.sin(\u03b8)*np.sin(\u03d5)*sy + np.cos(\u03b8)*sz)\n    U_n = Matrix([[exp(-I*(rx+rz)/2)*cos(ry/2), -exp(-I*(rx-rz)/2)*sin(ry/2)], [exp(I*(rx-rz)/2)*sin(ry/2), exp(I*(rx+rz)/2)*cos(ry/2)]])\n    M_q_rotated = U_n*M_q*Dagger(U_n)\n    return M_q_rotated\n\nfig, ax = plt.subplots(figsize = [8, 12], nrows=3, ncols=2)\nfig.patch.set_facecolor('white')\n[axis.set_axis_off() for axis in ax.ravel()]\n\nrotations = [[0, 0, pi/8], [0, 0, -pi/8], [0, pi/8, 0], [0, -pi/8, 0], [0, pi/8, pi/8], [0, -pi/8, -pi/8]]\nstart_vec = [1, 0, 0]\nnum_iterations = 8\n\nfor m, rotation in enumerate(rotations):\n    ax = fig.add_subplot(320+(m+1), axes_class = Axes3D)\n    \n    rot_x = rotation[0]\n    rot_y = rotation[1]\n    rot_z = rotation[2]\n    _bloch = Bloch(axes=ax)\n    _bloch.vector_color = get_gradient_colors([0, 0, 1], num_iterations)\n    _bloch.vector_width = 1\n    sv = []\n    vec = start_vec\n    sv.append(vec)\n    for i in range(num_iterations):\n        M_q_rotated = rn_su2_euler(vec, rot_x, rot_y, rot_z)\n        vec = qubitmatrix_to_cartesian(M_q_rotated)\n        sv.append(vec)\n\n    _bloch.add_vectors(sv)\n    _bloch.render()\n\nThe key was to add  and use the fucntion qubitmatrix_to_cartesian The other code remains almost untouched. The result looks now as follows:\n\nHere ist the complete Notebook on GitHub.\n"], "comments": [], "link": "https://quantumcomputing.stackexchange.com//questions/27015/stepwise-su2-rotations-on-the-bloch-sphere-from-pi-to-2-pi/27034?r=SearchResults#27034"}