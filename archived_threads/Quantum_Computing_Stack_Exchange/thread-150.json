{"question": "\nLet us first introduce two fundamental functions for coordinate transformations:\ndef to_spherical(state):\n    r0 = np.abs(state[0])\n    \u03d50 = np.angle(state[0])\n    r1 = np.abs(state[1])\n    \u03d51 = np.angle(state[1])\n    r = np.sqrt(r0 ** 2 + r1 ** 2)\n    \u03b8 = 2 * np.arccos(r0 / r)\n    \u03d5 = \u03d51 - \u03d50\n    return [r, \u03b8, \u03d5]\n\ndef to_cartesian(polar):\n    r = polar[0]\n    \u03b8 = polar[1]\n    \u03d5 = polar[2]\n    x = r * np.sin(\u03b8) * np.cos(\u03d5)\n    y = r * np.sin(\u03b8) * np.sin(\u03d5)\n    z = r * np.cos(\u03b8)\n    return [x, y, z]\n\nI am rotating stepwise a qubit using the SO(3) group as follows:\nimport qutip as qt\nfrom qutip.qip.operations import rx\nimport numpy as np\n\ndef rn_so3(state, theta, phi, delta):\n    rn_mat = qt.Qobj(\n        [[np.cos(delta/2) - (0+1j)*np.cos(theta)*np.sin(delta/2),\n          -(0+1j)*np.exp(-(0+1j)*phi)*np.sin(delta/2)*np.sin(theta)],\n         [-(0+1j)*np.exp((0+1j)*phi)*np.sin(delta/2)*np.sin(theta),\n          np.cos(delta/2) + (0+1j)*np.cos(theta)*np.sin(delta/2)]]\n        )\n    r_state = (rn_mat*state)*(rn_mat*state).dag()\n    return(r_state)\n\nb = qt.Bloch()\nb.clear()\nb.make_sphere()\n\nstates = []\npoints = []\n\nalpha = 1/np.sqrt(2)\nbeta = 1/np.sqrt(2)\ns = np.array([alpha,beta])\nstate = qt.Qobj(s)\nstates.append(state)\n\n\u03a8 = [complex(alpha, 0), complex(beta, 0)]\npolar = to_spherical(\u03a8)\npnt = to_cartesian(polar)\npoints.append(pnt)\n\nrotated = state\nfor i in range(0,10):\n    rotated = rn_so3(rotated, 0.4, 0.3, 0.2)\n    pnt = [(qt.sigmax()*rotated).tr(), (qt.sigmay()*rotated).tr(), (qt.sigmaz()*rotated).tr()]\n    states.append(rotated)\n    points.append(pnt)\n\nb.add_states(states)\nnp_points = np.array(points)\nb.add_points([np_points[:,0], np_points[:,1], np_points[:,2]])\nb.show()\n\nThis seems to work and the corresponding output looks as follows:\n\nTo retrace elementary relationships and \"mechanics\" that happens under the hood, I am now trying to achieve the same using the SU(2) group and coordinate transformations:\ndef rn_su2(\u03b8, \u03d5):\n    return (np.sin(\u03b8)*np.cos(\u03d5)*qt.sigmax() + np.sin(\u03b8)*np.sin(\u03d5)*qt.sigmay() + np.cos(\u03b8)*qt.sigmaz())\n\nb = qt.Bloch()\nb.clear()\nb.make_sphere()\n\nstates = []\npoints = []\n\nalpha = 1/np.sqrt(2)\nbeta = 1/np.sqrt(2)\ns = np.array([alpha,beta])\nstate = qt.Qobj(s)\nstates.append(state)\n\n\u03a8 = [complex(alpha, 0), complex(beta, 0)]\npolar = to_spherical(\u03a8)\npnt = to_cartesian(polar)\npoints.append(pnt)\n\nrotated = state\nfor i in range(0,10):\n    #\n    # Here seems to go something wrong\n    #\n    rotated = rn_su2(0.2*i, 0.3*i)\n    states.append(rotated)\n\n    #polar = to_spherical(rotated)\n    #pnt = to_cartesian(polar)    \n    points.append(pnt)\n\nb.add_states(states)\n\nnp_points = np.array(points)\nb.add_points([np_points[:,0], np_points[:,1], np_points[:,2]])\nb.show()\n\nHere I have some fundamental error and would appreciate any help or hint. The full notebook is also available here at GitHub.\nUpdate 2022-03-19:\nI implemented the SU(2) rotation according the useful hint in the comment. It looks better, but unfortunatelly the state lies not on the Bloch Sphere anymore:\ndef rn_su2(\u03b8, state, nx, ny, nz):\n    \u03a8 = [state.data[0,0], state.data[1,0]]\n    arr = to_spherical(\u03a8)\n    s_\u03b8 = arr[1]\n    s_\u03d5 = arr[2]\n    M_q = np.sin(s_\u03b8)*np.cos(s_\u03d5)*qt.sigmax() + np.sin(s_\u03b8)*np.sin(s_\u03d5)*qt.sigmay() + np.cos(s_\u03b8)*qt.sigmaz()\n    U_n = qt.qeye(2)*np.cos(\u03b8/2) -1j*(nx*qt.sigmax()+ny*qt.sigmay()+nz*qt.sigmaz())*np.sin(\u03b8/2)\n    r_state = U_n*M_q*U_n.dag()\n    return r_state\n\nUpdate 2022-03-20:\nThanks to the unveiling answer here, the SU(2) rotations look good and correct:\n\nWhat remains is the question: How do you have to rotate so that both point sequences look the same? In the SO(3) implementation case I used rotated = rn_so3(rotated, 0.4, 0.3, 0.2) and to get an almost same looking picture, by trial and error, I obtained for the SU(2) implementation:\nrotated = rn_su2(0.05, rotated, 1, 0, 0)\nrotated = rn_su2(0.02, rotated, 0, 1, 0)\nrotated = rn_su2(0.2, rotated, 0, 0, 1)\n\nHow are the angles to be used related in both cases?\n\n", "answers": ["\nIt seems that you are not evolving your state. Your rn_su2 defines a Hamiltonian H that acts on a qubit by evolving it: |\u03c8rotated\u27e9=e\u2212iH|\u03c80\u27e9. In Qutip you can use the mesolve function for this. If you replace your loop with these two lines, you'll get a list of rotated states plotted:\nevolution_result = qt.mesolve(rn_su2(np.pi/2,np.pi/3), state, range(0,10))\nb.add_states(evolution_result.states)\n\n"], "comments": ["Thank you for that hint. I implemented it, but obtain a different plot: see Notebook"], "link": "https://quantumcomputing.stackexchange.com//questions/24556/how-do-i-stepwise-rotate-a-qubit-on-a-bloch-sphere-using-so3-and-su2-gro?r=SearchResults"}