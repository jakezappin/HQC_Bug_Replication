{"question": "\nI am trying to replace the SPSA optimizer in the VQE tutorial of pennylane by the bayesian optimizer of scikit-opimize.\nWhen running the code below I get the error \"func should return a scalar\".\nI think this is not actually the problem since my func, wrapped_cost, returns a scalar which I also print. But I have no idea what the real problem is.\nimport pennylane as qml\nfrom pennylane import qchem\nfrom pennylane import numpy as np\nfrom skopt import gp_minimize\n\nniter_spsa = 200\ntrue_energy = -1.136189454088\nseednum=10\nnum_params=3\ndevicename=\"default.qubit\"\n\n#setup hamiltonian\nsymbols = [\"H\", \"H\"]\ncoordinates = np.array([0.0, 0.0, -0.6614, 0.0, 0.0, 0.6614])\nh2_ham, num_qubits = qchem.molecular_hamiltonian(symbols, coordinates)\n\n# Variational ansatz for H_2 \ndef circuit(params, wires):  #has 3 parameters\n    qml.BasisState(np.array([1, 1, 0, 0]), wires=wires)\n    for i in wires:\n        qml.Rot(*params[i], wires=i)\n    qml.CNOT(wires=[2, 3])\n    qml.CNOT(wires=[2, 0])\n    qml.CNOT(wires=[3, 1])\n\n\ndev=qml.device(devicename, wires=num_qubits)\n\ndef exp_val_circuit(params):\n    circuit(params, range(dev.num_wires))\n    return qml.expval(h2_ham)\n\n##\ncost_spsa = qml.QNode(exp_val_circuit, dev)\n\ndef wrapped_cost(params):  # Wrapping the cost function and flattening the parameters to be compatible with noisyopt which assumes a flat array of input parameters\n    return cost_spsa(np.asarray(params).reshape(num_qubits, num_params))\n\n\n##callback for documentation =^intermediate_results in (3)\ndef callback_fn(xk):\n    cost_val = wrapped_cost(xk)\n\n##set initial parameters\nnp.random.seed(seednum)\ninit_params = np.random.normal(0, np.pi, (num_qubits, 3), requires_grad=True)\nparams = list(init_params.copy().reshape(num_qubits * num_params)) #flatten and convert to list (func of gp_minimize takes list as input)\n\ntestlist=[i for i in range(12)]\nprint(\"Test for wrapped_cost: \",wrapped_cost(testlist), \" with tensor list params: \",wrapped_cost(params))\n\n##do optimization\nres = gp_minimize(\n        wrapped_cost,\n        [(2.0,4.0),(-5.0,0.0),(-6.0,-4.0),(0.0,6.0),\n        (0.0,2.0),(-3.0,-2.0),(0.0,2.0),(-3.0,0.0),\n        (-2.0,2.0),(-4.0,0.0),(0.0,2.0),(1.0,4.0)], #search space chosen on basis of observed parameters in minimizeSPSA for seed 10 \n        n_calls=20, #number of calls to the function to be evaluated\n        n_initial_points=20, #number of evaluations of the function before approximating it with base_estimator\n        random_state=0, #seed\n        verbose=True,\n        callback=callback_fn\n    )\n```\n\n", "answers": ["\nI was able to reproduce your error. I made several tests on your code and I found that the wrapped_cost function is returning a tensor, not a scalar. However if you try to use something like np.asscalar this causes problems down the line. I don't have a solution to your problem but hopefully this uncovers the root of the problem and you may be able to solve it from here.\n", "\nnp.asscalar as stated by Catalina solves the described problem.\nFurther problems (e.g. error message cannot convert (1,) array into (3,4) at np.asscalar(cost_spsa(np.asarray(params).reshape(num_qubits, num_params)))) arise, because xk used in the callbackfunction is not just the set of current parameters as for the Spsa but gp_minimize is much more verbose. Thus, also the additional evaluation of the costfunction in the callback is not needed but it is enough to just output xk to get all the needed information.\n"], "comments": ["Thank you. This helped to solve the issue."], "link": "https://quantumcomputing.stackexchange.com//questions/26147/why-does-vqe-with-pennylane-and-scikit-optimize-gp-minimize-give-func-must-be-s"}