{"question": "\nI'm trying to construct a quantum circuit with 3 mid-circuit measurements, here's an example:\n qrz = QuantumRegister(2,'q')\n crz = ClassicalRegister(3,'c')\n qc = QuantumCircuit(qrz,crz)\n for i in range (3):\n    qc.append(qc1(...),[0,1]). # qc1 is some circuit segment.\n    qc.measure(1,i)\n    qc.barrier()\n    qc = transpile(qc,backend=backend,optimization_level=2,initial_layout = [0,1])\n\nI'm wondering if I could perform the readout error mitigation in this case. Here's what I'm trying to do:\nimport matplotlib.pyplot as plt\nqlist = [1]    # Suppose we want to perform the mid-circuit measurement on this qubit.\ncal_circuits, state_labels = complete_meas_cal(qubit_list= qlist,circlabel='mcal')\nprint(len(cal_circuits))\ncal_job = execute(cal_circuits, \n                 backend = backend,\n                 shots = 1024,\n                  optimization_level = 0\n                 )\ncal_results = cal_job.result()\nmeas_fitter = CompleteMeasFitter(cal_results, state_labels)  # Generate the complete fitter. \nfig, ax = plt.subplots(figsize=(10, 10))\nmeas_fitter.plot_calibration(ax)\nmeas_filter = meas_fitter.filter\n\nIs there a way I can apply the filter to the qubit that I measured 3 times? Thanks for the help:)\n", "answers": ["\nThat's a very interesting question, I haven't thought about it before, thanks for that!\nNow, the way I see this, you have 2 different potential paths to investigate.\n1\nThe first one would be the same as the other answer, meaning you look independently at each result by using marginal_counts :\nraw_res0 = marginal_counts(results, indices=[0])\nraw_res1 = marginal_counts(results, indices=[1])\nraw_res2 = marginal_counts(results, indices=[2])\n\nAnd the you apply the filter to each raw_res\n#You can do this step only once\nmeas_filter = meas_fitter.filter\n# You do this for each raw_res \nmitigated_results0 = meas_filter.apply(raw_res0)\nmitigated_counts0 = mitigated_results0.get_counts(0)\nplot_histogram([raw_res0.get_counts(), mitigated_counts0], legend=['raw0', 'mitigated0'])\n\nNow, I think that this may be oversimplifying the problem, since they are many cause for errors, and that one measure error can have consequences on the future measurements, but this is still a good place to start and comprehend how to correct the dependencies between everything.\n2\nAnother idea I had would be to do your qc1 segment only once, measure (only once as well) the resulting state, correct via your filter the counts you have, and from that, \"create\" the state you measured (careful with this, of course you'll never be able to reproduce exactly the state you had before measurement, but create something \"similar\"), and start from there for the second round of your qc1 and so on.\nTo be more specific, once you have your mitigated counts, from that, you may take the square root of each probabilities to get \"the amplitudes\", say new_state, and then you can create it on your quantum circuit via the initialize method, for example to initialize 2 qubits :\nqr = QuantumRegister(2)\ncr = ClassicalRegister(2)\nqc = QuantumCircuit(qr,cr)\nqc.initialize(new_state, [0,1])\n#and whatever you want next\n\nOnce again, this is just the beginning of a reflexion, as for the first idea, lots could be wrong, especially the initialization to create the state for the next step, but this could be a first step to develop a nice procedure for this kind of situation.\nI hope all of this will help you on your problem, best of luck! :)\n", "\nYes! You would need 3 times the number of classical registers to store each measurement. Please see this.\nsimp_counts1 = marginal_counts(simp_job.result(), indices=[0]).get_counts()\nsimp_counts2 = marginal_counts(simp_job.result(), indices=[1]).get_counts()\nsimp_counts3 = marginal_counts(simp_job.result(), indices=[3]).get_counts()\n\nThe for each measurement use your filter, for example:\nmeas_filter = meas_fitter.filter\nmitigated_results = meas_filter.apply(sim_counts1)\n\n"], "comments": ["Thank you so much for the helpful answer!", "Thank you for the answer, that's really helpful!"], "link": "https://quantumcomputing.stackexchange.com//questions/17753/apply-readout-error-mitigation-to-mid-circuit-measurement?r=SearchResults"}