{"question": "\nI'm simulating the BB84 protocol using simulaqron. My\nproblem is that when Alice and Bob measure in the same basis, they\ndon't get the same result.\nHow can I fix this error?\n.\nBB84.py \nfrom cqc.pythonLib import CQCConnection, qubit\nimport numpy as np\n\"\"\"\nBB84 protocol \n\"\"\"\n\ndef prepare_qubits(Sender,receiver,key_bit):\n\n   q=qubit(Sender)\n   S_basis=\"\" # The sender basis\n\n   if key_bit == 1:  #prepare qubits in |1> state\n    q.X() #apply X gate\n   else:\n    pass\n   # convert  to  Hadamard  basis randomly\n   if 0.5 < np.random.random(): \n    q.H() #apply hadamard gate\n    S_basis='H'\n   else:\n    S_basis='S'\n    pass\n   Sender.sendQubit(q,receiver)\n\n   return [q,S_basis]\n\ndef receive_qubits(Receiver):\n  #R_basis=[] #Receiver basis\n  # Wait to  receive a qubit\n  q=Receiver.recvQubit()\n  C=\"\" # for basis choice\n  # If we  chose  the  Hadamard  basis\n  # to  measure in, apply H\n  if 0.5 < np.random.random(): \n   q.H()\n   C='H'\n  else:\n   C='S' #S: Standard Basis\n   pass\n  # Measure  the  qubit  in the  standard\n  # basis  and  store  the  outcome  in m\n  m=q.measure ()\n  return [m,C]\n\nAlice.py\nfrom cqc.pythonLib import CQCConnection, qubit\nimport numpy as np\nfrom BB84 import *\nfrom CAC.classical_comm import *\n\n# Establish a connection  to  SimulaQron\nwith CQCConnection(\"Alice\") as Alice:\n\n print(\"***********************BB84 protocol***************************\")\n #Alice.closeClassicalServer()\n m=[] \n B=[]\n S=''\n n=2 #number of qubits\n Alice.sendClassical(\"Bob\",n)#send the number of qubits\n key= np.random.randint(0, high=2**n)#to replace with QRNG() function\n k=np.binary_repr(key,n) #binary representation\n print(\"Alice's random key\",key)\n print(\"Alice's binary key:\",k)\n print(\"*********************************\")\n for x in k:\n\n  m.append(str(x))\n  s=prepare_qubits(Alice,\"Bob\",x) #send BB84 states\n  #receive a confirmation msg from Bob via the CAC\n  B.append(s[1])\n  S+=str(s[1])\n \"\"\"\n #send Alice's basis to Bob \n ff=S.encode()#conversion to byte\n Alice.sendClassical(\"Bob\",ff)\n \"\"\"\n\n print('a basis',B)\n\n #received Bob's Basis\n x=Alice.recvClassical()\n B_basis=list(x.decode())\n print(\"Bob basis received\",B_basis)\n #print(B_basis.split(\"\"))\n aa=sifted_key(B,B_basis,m)\n print(\"sifted key\",aa)\n\n\n\n listToStr =\"[\"+','.join(map(str, aa[1]))+\"]\"\n ff=listToStr.encode()\n Alice.sendClassical(\"Bob\",ff)\n\n\n #Close  connection  to  SimulaQron\n Alice.close()\n\nBob.py\nfrom cqc.pythonLib import CQCConnection, qubit\nimport numpy as np\nfrom BB84 import *\nfrom CAC.classical_comm import *\nimport ast\n\n# Establish  connection  to  SimulaQron\nwith CQCConnection(\"Bob\") as Bob:\n #Bob.closeClassicalServer() #if I want to use my socket functions\n n=Bob.recvClassical()[0] #number of qubits given by Bob (\"Eve\")\n key=[]\n B=''\n for i in range(0,n):\n  c=receive_qubits(Bob)\n  #send confirmation to Alice via CAC\n  #print(\"out meas.\",c[0])\n  key.append(c[0])\n  B+=str(c[1]) #Bob basis\n\n print(\"Bob off\",B)\n #send Basis to Alice\n print(\"bob's initial key :\",key)\n ff=B.encode()#conversion to byte\n Bob.sendClassical(\"Alice\",ff)\n\n #receive Alice's basis\n a=Bob.recvClassical()\n x=a.decode()\n res = ast.literal_eval(x)\n print(\"Alice's Basis received\",res)\n key_s=[]\n\n for c in res:\n  key_s.append(key[c])\n\n print(\"final sifted key\",key_s)\nBob.close()\n\n", "answers": [], "comments": [], "link": "https://quantumcomputing.stackexchange.com//questions/11382/why-alice-and-bob-dont-get-the-same-result-when-they-measure-in-the-same-basis"}