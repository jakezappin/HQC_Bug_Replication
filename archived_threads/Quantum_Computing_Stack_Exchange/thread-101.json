{"question": "\nMonths or years ago, in a remote part of the globe, someone accessed an IBM Quantum computer online to perform a real experiment. She saved the resulting measurement outcomes of the algorithm in csv format on her computer, and she doesn't have access to IBM's experimental data files or job IDs anymore. She was cautious with her methods, so while she took the steps to perform measurement error mitigation, she kept raw measurement data separate from the data used to calibrate the error mitigation fitter. As a result, she now has two tables in her computer, which can be imported as Pandas dataframes: calibration_df and raw_results_df.\nIn both dataframes, each row represents a circuit, and there are only two columns: 0 and 1, containing the counts of each possible output of the single qubit measured. Naturally, the calibration_df contains only two rows: \"Prep 0\" and \"Prep 1\", the circuits used to gather the data for calibration of measurement error mitigation. The raw_results_df contains the results of the circuits used for the actual experiment. Let's say it has 10 rows.\nSince she only has access to these two dataframes and she knows that, in principle, the data in calibration_df could be used to mitigate the raw_results_df and produce the corresponding mitigated_results_df, she would like to do just that using the latest Qiskit methods.  All the measurement error mitigation tutorials she has been able to find seem to require the calibration results in the form of a Result object, however, which she doesn't have access to anymore. Furthermore, trying to import and use CompleteMeasFitter, she runs into DeprecationWarning: The class ``qiskit.utils.mitigation.fitters.CompleteMeasFitter`` is deprecated as of qiskit-terra 0.24.0. It will be removed no earlier than 3 months after the release date. For code migration guidelines, visit https://qisk.it/qi_migration..\nDo you have an idea how she could achieve that? Some help would be appreciated.\nimport pandas as pd\ncalibration_df = pd.DataFrame([{'0':9293,'1':707},{'0':434,'1':9566}], index=[['Prep 0','Prep 1']])\nraw_results_df = pd.DataFrame([{'0':1500,'1':8500},{'0':6234,'1':3766},{'0':4213,'1':5787},{'0':8124,'1':1876},{'0':3198,'1':6802},\n                               {'0':8462,'1':1538},{'0':5791,'1':4209},{'0':2443,'1':7557},{'0':4897,'1':5103},{'0':9001,'1':999}])\n\n", "answers": ["\nI have encountered the same error while implementing the Qiskit measurement error mitigation as part of the experiments for this paper. Unfortunately, I did not solve the problem - I just used the Result objects I had from the results. I think that this framework in Qiskit of requiring result objects is usually not needed, and just adds complications - this post is a clear example where this is the case. I think specifying the measurement dictionaries should be sufficient to use the libraries. Anyway, I think that there may be a way to create a fake Qiskit Result object - but I am not exactly sure what fake data needs to be created in order for the process to work.\nHowever, with all of that said, I do not think you need to re-perform this measurement error mitigation - or more specifically, there are no \"new\" measurement error mitigation techniques that could be applied based on the data you gathered. The data that the measurement error calibration gathers  is a calibration confusion matrix for all 2n possible readout states, which can then be used to remove some biases in the measurements that are made for a logical circuit. As far as I know, this specific method has not been recently improved on - so if you managed to get the correct Result object and re-run the experiment, I think you would get the same result.\nNow, it is true that there are recent improvements in measurement error mitigation - Qiskit runtime gives an option to mitigate measurement error mitigation using a method called Twirled readout error extinction - this method does not use the 2n state readout calibration matrix method. Note however that this twirled readout error mitigation only gives mitigated expectation values, or mitigated objective function evaluations, so qubit (or variable) states will not given, unlike the calibration matrix method you used.\n"], "comments": [], "link": "https://quantumcomputing.stackexchange.com//questions/33667/qiskits-measurement-error-mitigation-from-counts-data-only-in-2023?r=SearchResults"}