{"question": "\nI tried to implement the traveling salesman problem (TSP) using QAOA with qiskit. I worked with this qiskit QAOA tutorial and this qiskit minimum eigen optimizer tutorial, where they implement a TSP instance for three cities. However, when I tried to slightly change their example by considering four cities, the QAOA solution fails. I used the NumPyMinimumEigensolver classical solver to compare the QAOA solution with the classical obtained one. While the classical algorithm gives me the right solution, the QAOA solution even fails to visit each city once. I have tried to run QAOA with p=1p=1 and p=2p=2, both versions give me the same wrong result. I also used the qasm_simulatorinstead of the statevector_simulator, since for 16 qubits the latter is infeasable.\nThe weird thing to me is, that QAOA gives me a way too high cost value. I think this is due to the fact that QAOA gives me an invalid solution where the fourth city is never visited (QAOA's solution translates: city 1->2->3 and no city visited in fourth time step).\nDoes anyone know, why this slight change in the problem makes the algorithm fail? Is there anything wrong in my code?\nMy code:\nfrom qiskit import Aer\nfrom qiskit.optimization.applications.ising import tsp\nfrom qiskit.aqua.algorithms import NumPyMinimumEigensolver, QAOA\nfrom qiskit.aqua import aqua_globals, QuantumInstance\nfrom qiskit.optimization.algorithms import MinimumEigenOptimizer\nfrom qiskit.optimization.problems import QuadraticProgram\n\n# Generating a TSP instance of n cities\nn = 4\nnum_qubits = n ** 2\nins = tsp.random_tsp(n, seed=123)\nprint('distance\\n', ins.w)\n\n# Create a random TSP Hamiltonian\nqubitOp, offset = tsp.get_operator(ins)\nqp = QuadraticProgram()\nqp.from_ising(qubitOp, offset, linear=True)\n\naqua_globals.random_seed = 10598\nquantum_instance = QuantumInstance(Aer.get_backend('qasm_simulator'),\n                                   seed_simulator=aqua_globals.random_seed,\n                                   seed_transpiler=aqua_globals.random_seed)\nqaoa_mes = QAOA(quantum_instance=quantum_instance, initial_point=[0., 0.])\nexact_mes = NumPyMinimumEigensolver()\n\n# solving Quadratic Program using exact classical eigensolver\nexact = MinimumEigenOptimizer(exact_mes)\nexact_result = exact.solve(qp)\nprint(\"\\nExact:\\n\", exact_result)\n\n# solving the Problem using QAOA\nqaoa = MinimumEigenOptimizer(qaoa_mes) \nqaoa_result = qaoa.solve(qp)\nprint(\"\\nQAOA:\\n\", qaoa_result)\n\nAs a result I get:\ndistance\n [[ 0. 48. 91. 33.]\n [48.  0. 63. 71.]\n [91. 63.  0. 92.]\n [33. 71. 92.  0.]]\n\nExact:\noptimal function value: 236.0\noptimal value: [0. 0. 0. 1. 1. 0. 0. 0. 0. 1. 0. 0. 0. 0. 1. 0.]\nstatus: SUCCESS\n\nQAOA:\noptimal function value: 200111.0\noptimal value: [1. 0. 0. 0. 0. 1. 0. 0. 0. 0. 1. 0. 0. 0. 0. 0.]\nstatus: SUCCESS\n\n", "answers": [], "comments": ["It could be your optimizer defaults are incorrectly setup. Maybe check that your solution is actually converging to something by plotting the energy function for each function evaluation"], "link": "https://quantumcomputing.stackexchange.com//questions/15163/qiskit-traveling-salesman-problem-using-qaoa-fails-for-more-than-3-cities?r=SearchResults"}