{"question": "\nI am a bit hesitant to ask this very specific question, as I feel other people need not benefit from it. But since I have struggled for a while, and I think I should get some help.\nSo I am using VQE in qiskit to calculate the ground sate energy of a chain of hydrogen atoms, but it appears that the result is in-consistent with the result from exact diagonalization. The code works well for other molecules like H2, LiH, so this is confusing. I guess the question boils down to how to set the threshold for the VQE. I have attached the code below, and many thanks for the help!\nfrom qiskit import BasicAer\nimport logging\nfrom qiskit.chemistry import set_qiskit_chemistry_logging\nset_qiskit_chemistry_logging(logging.ERROR) \n\n# chemistry related modules\nfrom qiskit.chemistry import FermionicOperator\nfrom qiskit.chemistry.drivers import PySCFDriver, UnitsType\n\n\nfrom qiskit.aqua.algorithms import VQE, NumPyEigensolver\nimport numpy as np\nfrom qiskit.chemistry.components.variational_forms import UCCSD\nfrom qiskit.chemistry.components.initial_states import HartreeFock\nfrom qiskit.aqua.components.optimizers import L_BFGS_B\nfrom qiskit.aqua.operators import Z2Symmetries\n\n\ndef get_qubit_op(atom,basis,map_type ):\n    driver = PySCFDriver(atom=atom, unit=UnitsType.ANGSTROM, \n                         charge=0, spin=0, basis=basis)\n    molecule = driver.run()\n    num_particles = molecule.num_alpha + molecule.num_beta    \n    num_spin_orbitals = molecule.num_orbitals * 2    \n    ferOp = FermionicOperator(h1=molecule.one_body_integrals, h2=molecule.two_body_integrals)\n    \n    qubitOp = ferOp.mapping(map_type=map_type, threshold=0.00000001)\n    qubitOp = Z2Symmetries.two_qubit_reduction(qubitOp, num_particles)        \n    \n    return qubitOp, num_particles, num_spin_orbitals\n\nimport timeit\n\nstart = timeit.default_timer()\n\n\natom = 'H .0 .0 .0; H .0 .0 1.5 ; H .0 .0 3.0 ; H .0 .0 4.5 '\n\nbasis='sto3g'\n\nmap_type = 'parity'\n\nqubitOp, num_particles, num_spin_orbitals = get_qubit_op(atom,basis,map_type )\n\nprint('Ground state energy is' , NumPyEigensolver( qubitOp ).run().eigenvalues )\n\n    \ninit_state = HartreeFock( num_spin_orbitals , num_particles , map_type )\n\n# set the backend for the quantum computation=\nbackend = BasicAer.get_backend('statevector_simulator')\n\n# setup a classical optimizer for VQE\noptimizer = L_BFGS_B()\nprint( init_state.bitstr )\n\nvar_form_vqe = UCCSD(\n        num_orbitals=num_spin_orbitals,\n        num_particles=num_particles,\n        initial_state=init_state,\n        qubit_mapping=map_type \n    )\n\nalgorithm_vqe = VQE(qubitOp, var_form_vqe, optimizer  )\n\nresult_vqe = algorithm_vqe.run(backend)\n\nprint( 'eigenvalue = ' , result_vqe['eigenvalue' ] )\n\nstop = timeit.default_timer()\n\nprint('The run time of this part: ', stop - start)  \n\nThe output is below, and as you can see, they differ quite significantly.\nGround state energy is [-3.52488449+5.88070795e-18j]\n[False False  True False False  True]\neigenvalue =  (-3.523526951494827+0j)\nThe run time of this part:  57.303660957000034\n\n", "answers": ["\nI think this has to do with the fact that the var_form that you picked, UCCSD, is not expressible enough. What I mean by that is UCCSD doesn't have the sufficient complexity to generate the ground state wavefunction.\nMaybe you should try UCCSDT or some other var_form that have greater expressibility.\n"], "comments": ["I can't see this setting here, but I would begin with increasing the trotter order (i.e. having more runs of the ansatz circuit). But may only on a simulator, the circuit will be too big for existing ibmq chips.", "Hi @mavzolej, thanks for the comments. Actually this is one of my puzzles for such simulation, is this code run on an actual quantum machine, or is it just a simulator? Here the quantum circuit only involve 6 qubits, so in either case, it should be within the limit. What other specific setting of the VQE would you like to know? What do you mean by \"having more runs of the ansatz circuit\"?  Thanks!", "backend = BasicAer.get_backend('statevector_simulator') - in this line you choose the classical simulator to be your backend. So, all the observables are evaluated exactly. The next step could be the QASM backend which would calculate observables using sampling from the exact probability distribution. And then you move to the real hardware.", "I would suggest that you to read about UCC here and also google smth on trotterization, so that you understood what's meant by \"trotter order\" in Ibid.", "Thanks for both the comments. Now I understand what you mean by trotterization order. It seems to corresponds to the \"reps\" parameter in the UCCSD, and I will try it out. Thanks for reminding me that.", "Hi @KAJ226, thanks for the answer. It is a bit surprised that UCCSD is not general enough, given that H_4 is a pretty small system. For \"UCCSDT\" you mentioned, I could not find it in the documentation of qiskit, could you please elaborate a bit more? Thanks!", "I don't think UCCSDT is available in Qiskit. But I think \"Single\" and \"Double\" excitation might be enough here, actually...As suggested by the comment to your question, increasing the trotter order will help. As UCCSD operator is actually an exponential of a matrix with terms that do not commute. Therefore it has to be approximated. Qiskit takes the approximation order to be 1 if you don't specify it specifically.  Here is the link to the source code: qiskit.org/documentation/stubs/\u2026", "I guess you mean the parameter \"reps\" in UCCSD. Thanks for pointing that out, as I almost forgot in the trotterization, there is a factor of n in the exponential. I will try to make the parameter larger.", "I mean the \"num_time_slice\". Although I don't know why they have the parameter \"reps\" for UCCSD to be honest . That is usually for those heuristic ansatz. For UCCSD , which is a chemically motivated ansatz, it doesn't make sense to repeat it multiple time in that sense, in my opinion. I didn't get any better result though. It is about the same as before. Maybe you did.", "No, I tried reps = 2,3, the result is still roughly -3.5236... If you try different \"num_time_slice\" and still get the same result, then it is really confusing.", "In any case, I still feel that it has something to do with the accuracy of the VQE. Do you know how to set the threshold or accuracy for VQE? I checked the documentation for VQE, and vq_algorithm, but found nothing.", "You can set the tolerance level for the optimizer. In VQE we are trying to minimize the cost function, so we don't know what the answer is ahead of time.  Also, you might get stuck in one of the local -minimum during the classical optimization step and that is why you don't get true ground state energy you want.", "Yes, I try to set the \"epsilon\" in L_BFGS_B, but that does not help either. I think I will have to accept that I am stuck in a local minima."], "link": "https://quantumcomputing.stackexchange.com//questions/14040/why-vqe-gives-an-incorrect-ground-state-energy-for-a-chain-of-4-hydrogen-atoms"}