{"question": "\nI am new to python programming and Qiskit. I would like to ask can we use sklearn for adding external .csv data file before Qiskit libraries, or without sklearn, we can do or is there any other Qiskit library to add any external .csv file, to run the python code of quantum support vector machine?\nHow I can use .csv data file with Qiskit libraries to run quantum SVM ?\nI am following the code written below, where I should put my own .csv data file\nimport numpy as np\nfrom dataset import breast_cancer\nfrom sklearn.datasets.samples_generator import make_blobs\nfrom qiskit.aqua.utils import split_dataset_to_data_and_labels \nfrom sklearn import svm\nfrom utils import svm_utils \nfrom matplotlib import pyplot as plt\n#matplotlib inline\n#load_ext autoreload\n#autoreload 2   % Breast Cancer dataset\n\nn = 2 # number of principal components kept\ntraining_dataset_size = 20\ntesting_dataset_size = 10\n\nsample_Total, training_input, test_input, class_labels = breast_cancer(training_dataset_size, testing_dataset_size, n)\n\ndata_train, _ = split_dataset_to_data_and_labels(training_input)\ndata_test, _ = split_dataset_to_data_and_labels(test_input)  # %%Breast Cancer dataset\n\n##%% Linear Support vector machine\n# We use the function of scikit learn to generate linearly separable blobs\ncenters = [(2.5,0),(0,2.5)]\nx, y = make_blobs(n_samples=100, centers=centers, n_features=2,random_state=0,cluster_std=0.5)\n\n\nfig,ax=plt.subplots(1,2,figsize=(10,5))\n\n\nax[0].scatter(data_train[0][:,0],data_train[0][:,1],c=data_train[1])\nax[0].set_title('Breast Cancer dataset');\n\nax[1].scatter(x[:,0],x[:,1],c=y)\nax[1].set_title('Blobs linearly separable');\n\n##%% Hands-on session on support vector machine\n\nplt.scatter(data_train[0][:,0],data_train[0][:,1],c=data_train[1])\nplt.title('Breast Cancer dataset');\n\nmodel= svm.LinearSVC()\nmodel.fit(data_train[0], data_train[1])\naccuracy_train = model.score(data_train[0], data_train[1])\naccuracy_test = model.score(data_test[0], data_test[1])\n\n\nX0, X1 = data_train[0][:, 0], data_train[0][:, 1]\nxx, yy = svm_utils.make_meshgrid(X0, X1)\nZ = model.predict(np.c_[xx.ravel(), yy.ravel()])\nZ = Z.reshape(xx.shape)\n\nfig,ax=plt.subplots(1,2,figsize=(15,5))\nax[0].contourf(xx, yy, Z, cmap=plt.cm.coolwarm)\nax[0].scatter(data_train[0][:,0], data_train[0][:,1], c=data_train[1])\nax[0].set_title('Accuracy on the training set: '+str(accuracy_train));\n\nax[1].contourf(xx, yy, Z, cmap=plt.cm.coolwarm)\nax[1].scatter(data_test[0][:,0], data_test[0][:,1], c=data_test[1])\nax[1].set_title('Accuracy on the test set: '+str(accuracy_test));\n\n##%% We now implement a SVM with gaussian kernel\nclf = svm.SVC(gamma = 'scale')\nclf.fit(data_train[0], data_train[1]);\naccuracy_train = clf.score(data_train[0], data_train[1])\naccuracy_test = clf.score(data_test[0], data_test[1])\n\n\nX0, X1 = data_train[0][:, 0], data_train[0][:, 1]\nxx, yy = svm_utils.make_meshgrid(X0, X1)\nZ = clf.predict(np.c_[xx.ravel(), yy.ravel()])\nZ = Z.reshape(xx.shape)\n\nfig,ax=plt.subplots(1,2,figsize=(15,5))\nax[0].contourf(xx, yy, Z, cmap=plt.cm.coolwarm)\nax[0].scatter(data_train[0][:,0], data_train[0][:,1], c=data_train[1])\nax[0].set_title('Accuracy on the training set: '+str(accuracy_train));\n\nax[1].contourf(xx, yy, Z, cmap=plt.cm.coolwarm)\nax[1].scatter(data_test[0][:,0], data_test[0][:,1], c=data_test[1])\nax[1].set_title('Accuracy on the test set: '+str(accuracy_test));\n\n##%% First steps in Qiskit\nimport qiskit as qk\n\n# Creating Qubits\nq = qk.QuantumRegister(2)\n# Creating Classical Bits\nc = qk.ClassicalRegister(2)\n\n##%% Define and print empty circuit\ncircuit = qk.QuantumCircuit(q, c)\nprint(circuit)\n\n##%%% Add gates to the qubits\n# Initialize empty circuit\ncircuit = qk.QuantumCircuit(q, c)\n# Hadamard Gate on the first Qubit\ncircuit.h(q[0])\n# CNOT Gate on the first and second Qubits\ncircuit.cx(q[0], q[1])\n# Measuring the Qubits\ncircuit.measure(q, c)\nprint (circuit)\n\n##%% Run the circuit on the quantum simulator\n# Using Qiskit Aer's Qasm Simulator: Define where do you want to run the simulation.\nsimulator = qk.BasicAer.get_backend('qasm_simulator')\n\n# Simulating the circuit using the simulator to get the result\njob = qk.execute(circuit, simulator, shots=100)\nresult = job.result()\n\n# Getting the aggregated binary outcomes of the circuit.\ncounts = result.get_counts(circuit)\nprint (counts)\n\nfrom qiskit.aqua.components.feature_maps import SecondOrderExpansion\n\nfeature_map = SecondOrderExpansion(feature_dimension=2, \n                                   depth=1)\n\n##%%Print the feature map circuit\nx = np.array([0.6, 0.3])\nprint(feature_map.construct_circuit(x))\n\n##%%% QSVM Algorithm\nfrom qiskit.aqua.algorithms import QSVM\n\nqsvm = QSVM(feature_map, training_input, test_input)\n\n##%% Run QSVM\nfrom qiskit.aqua import run_algorithm, QuantumInstance\nfrom qiskit import BasicAer\n\nbackend = BasicAer.get_backend('qasm_simulator')\nquantum_instance = QuantumInstance(backend, shots=1024, seed_simulator=10598, seed_transpiler=10598)\n\nresult = qsvm.run(quantum_instance)\n\n##%%% Analyze output\nplt.scatter(training_input['Benign'][:,0], training_input['Benign'][:,1])\nplt.scatter(training_input['Malignant'][:,0], training_input['Malignant'][:,1])\nplt.show()\nlength_data = len(training_input['Benign']) + len(training_input['Malignant'])\nprint(\"size training set: {}\".format(length_data))\nprint(\"Matrix dimension: {}\".format(result['kernel_matrix_training'].shape))\n\nprint(\"testing success ratio: \", result['testing_accuracy'])\n\ntest_set = np.concatenate((test_input['Benign'], test_input['Malignant']))\ny_test = qsvm.predict(test_set, quantum_instance)\n\n##%% And here we plot the results. The first plot shows the label predictions of the QSVM and the second plot shows the test labels.\nplt.scatter(test_set[:, 0], test_set[:,1], c=y_test)\nplt.show()\n\nplt.scatter(test_input['Benign'][:,0], test_input['Benign'][:,1])\nplt.scatter(test_input['Malignant'][:,0], test_input['Malignant'][:,1])\nplt.show()\n\n\n", "answers": ["\nI have previously used this function to load a custom data set - it should still work but I haven't tried it with more recent releases of Aqua\ndef userDefinedData(location, file, class_labels,training_size, test_size, n=2, PLOT_DATA=True):\n\n\n    data, target, target_names = load_data(location, file)\n    # sample_train is of the same form as data\n    sample_train, sample_test, label_train, label_test = train_test_split(\n        data, target,test_size=0.25, train_size=0.75 ,random_state=22)\n\n\n    # Now we standarize for gaussian around 0 with unit variance\n    std_scale = StandardScaler().fit(sample_train)\n    sample_train = std_scale.transform(sample_train)\n    sample_test = std_scale.transform(sample_test)\n\n\n    # Now reduce number of features to number of qubits\n    pca = PCA(n_components=n).fit(sample_train)\n    sample_train = pca.transform(sample_train)\n    sample_test = pca.transform(sample_test)\n\n\n    # Samples are pairs of points\n    samples = np.append(sample_train, sample_test, axis=0)\n    minmax_scale = MinMaxScaler((-1, 1)).fit(samples)\n    sample_train = minmax_scale.transform(sample_train)\n    sample_test = minmax_scale.transform(sample_test)\n\n\n    # If class labels are numeric\n    if class_labels[0].isdigit():\n        # Pick training size number of samples from each distro\n        training_input = {key: (sample_train[label_train == int(key), :])[:training_size] for k, key in enumerate(class_labels)}\n        test_input = {key: (sample_test[label_test == int(key), :])[: test_size] for k, key in enumerate(class_labels)}\n\n    else:\n        # if they aren't\n        training_input = {key: (sample_train[label_train == k, :])[:training_size] for k, key in\n                         enumerate(class_labels)}\n        test_input = {key: (sample_train[label_train == k, :])[training_size:(\n                training_size + test_size)] for k, key in enumerate(class_labels)}\n\n\n\n    if PLOT_DATA:\n        for k in range(0, 9):\n            plt.scatter(sample_train[label_train == k, 0][:training_size],\n                        sample_train[label_train == k, 1][:training_size])\n\n        plt.title(\"PCA dim. reduced user dataset\")\n        plt.show()\n\n    return sample_train, training_input, test_input, class_labels\n\n\n"], "comments": ["Hi! You already have this question open here quantumcomputing.stackexchange.com/questions/9961/\u2026 , are you asking something different here?", "Let us continue this discussion in chat.", "If you have further questions, it would be better to ask them as new questions rather than comments :)", "For any further discussion, please continue in the chatroom vis555 already set up. Thanks!"], "link": "https://quantumcomputing.stackexchange.com//questions/9961/regarding-quantum-support-vector-machine-using-qiskit?r=SearchResults"}