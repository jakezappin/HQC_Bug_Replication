{"question": "\nI wrote an implementation of Grover's algorithm that looks like this:\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, Aer, execute\n\n# Initialize circuit\nm_qubit = QuantumRegister(1)\nsearch_register = QuantumRegister(4)\nresult_register = ClassicalRegister(4)\nancillaries = QuantumRegister(3)\ncircuit = QuantumCircuit(search_register, result_register, m_qubit, ancillaries)\n\n# Put M qubit into 1-superposition\ncircuit.x(m_qubit)\ncircuit.h(m_qubit)\n\n# Put search qubits into superposition\ncircuit.h(search_register)\n\nfor _ in range(2):\n\n    # Encode S1 * !S2 * S3\n    circuit.x( search_register[2] )\n    circuit.ccx( search_register[1], search_register[2], ancillaries[0] )\n    circuit.ccx( search_register[3], ancillaries[0], ancillaries[1] )\n    circuit.x( search_register[2] )\n\n    # Encode S0 * S1\n    circuit.ccx( search_register[0], search_register[1], ancillaries[2] )\n\n    # Encode oracle ((S0 * S1) + (S1 * !S2 * S3))\n    circuit.x(ancillaries)\n    circuit.ccx( ancillaries[1], ancillaries[2], m_qubit[0] )\n    circuit.x(ancillaries)\n    circuit.x(m_qubit)\n\n    # Reset ancillaries to be used later\n    circuit.reset(ancillaries)\n\n    # Do rotation about the average\n    circuit.h(search_register)\n    circuit.x(search_register)\n    circuit.ccx( search_register[0], search_register[1], ancillaries[0] )\n    circuit.ccx( search_register[2], ancillaries[0], ancillaries[1] )\n    circuit.ccx( search_register[3], ancillaries[1], m_qubit[0] )\n    circuit.x(search_register)\n    circuit.x(m_qubit)\n    circuit.h(search_register)\n\n    # Reset ancillaries for use later\n    circuit.reset(ancillaries)\n\ncircuit.measure(search_register, result_register)\n\n# Run the circuit with a given number of shots\nbackend_sim = Aer.get_backend('qasm_simulator')\njob_sim = execute(circuit, backend_sim, shots = 1024)\nresult_sim = job_sim.result()\n\n# get_counts returns a dictionary with the bit-strings as keys\n# and the number of times the string resulted as the value\nprint(result_sim.get_counts(circuit))\n\nEssentially, this circuit should search for any value that matches X1X2X3+X0X1X1X2X3+X0X1. When I do the math for this circuit I get the following:\n11024\u221a2(\u2212304(\u2211x\u2208{00,01,11}|x\u27e9(|00\u27e9+|01\u27e9+|10\u27e9)+|1000\u27e9+|1001\u27e9)+80(11\u2211x=00|x\u27e9|11\u27e9+|1010\u27e9))(|0\u27e9\u2212|1\u27e9)110242\u2013\u221a\u239b\u239d\u2212304\u239b\u239d\u2211x\u2208{00,01,11}|x\u27e9(|00\u27e9+|01\u27e9+|10\u27e9)+|1000\u27e9+|1001\u27e9\u239e\u23a0+80(\u2211x=0011|x\u27e9|11\u27e9+|1010\u27e9)\u239e\u23a0(|0\u27e9\u2212|1\u27e9)\nThese amplitudes correspond to probabilities of \u221230422(10242)=\u22121922(642) and 8022(10242)=522(642) for the unsuccessful and successful probabilities, respectively.\nWhat I don't understand from this is how the successful outputs would appear over the unsuccessful ones, because the magnitude of the probability for the unsuccessful results is much higher. Can someone explain how the normalization is done in this case?\nFurthermore, these results do not obtain when I actually run the circuit. Instead of a step-function for the probabilities, when I run 1024 shots I tend to get between 30 and 50 for the unsuccessful results and the successful results are spread between 200 and 460. While it's obvious that the successful results have been selected, the spread is concerning because the math seems to indicate that they should be fairly close together. Moreover, the successful results always fall in the same order, which is also counter-intuitive given that results are probabilistic. This implies one of two things to me:\n\nThe superposition isn't actually equal (i.e. there's some bias towards one value versus the other). However, this doesn't make sense as these results were obtained with a simulator so they should be very close to optimal.\nI have inadvertently entangled the qubits in such a way that the result is affected.\n\nAny insight into this would be greatly appreciated. \n", "answers": ["\nIt turns out the issue with this circuit was in the use of the reset operator in conjunction with entanglement and superposition.\nIn the oracle code I submitted, I use a Toffoli gate several times, which creates an entanglement between both input qubits and the output qubit. Since the input qubits are in superposition, that superposition state then \"spreads\" (for lack of a better term) to the output qubit. So, when the output qubit is reset using the reset operator, its superposition state and entanglements with the input qubits causes certain states to collapse, which changes the output of the circuit as a whole.\nThis had confused me earlier because using reset with either superposition or entanglement causes no issue, because both can collapse without change to the input; because, in a sense, the output and input qubits are separated. It is only, therefore, when they are used in conjunction that reset causes this behavior.\nThe solution then, is quite simple: reverse the circuit to return the output qubit to a |0\u27e9 state after it is no longer needed:\n# Encode S1 * !S2 * S3\ncircuit.x( search_register[2] )\ncircuit.ccx( search_register[1], search_register[2], ancillaries[0] )\ncircuit.ccx( search_register[3], ancillaries[0], ancillaries[1] )\n\n# Encode S0 * S1\ncircuit.ccx( search_register[0], search_register[1], ancillaries[2] )\n\n# Encode oracle ((S0 * S1) + (S1 * !S2 * S3))\ncircuit.x(ancillaries)\ncircuit.ccx( ancillaries[1], ancillaries[2], m_qubit[0] )\ncircuit.x(m_qubit)\n\n# Return ancillaries to 0s so they can be used later\ncircuit.x(ancillaries)\ncircuit.ccx( search_register[0], search_register[1], ancillaries[2] )\ncircuit.ccx( search_register[3], ancillaries[0], ancillaries[1] )\ncircuit.ccx( search_register[1], search_register[2], ancillaries[0] )\ncircuit.x( search_register[2] )\n\n# Do rotation about the average\ncircuit.h(search_register)\ncircuit.x(search_register)\ncircuit.ccx( search_register[0], search_register[1], ancillaries[0] )\ncircuit.ccx( search_register[2], ancillaries[0], ancillaries[1] )\ncircuit.ccx( search_register[3], ancillaries[1], m_qubit[0] )\ncircuit.x(search_register)\ncircuit.x(m_qubit)\n\n# Return ancillaries to 0s for use later\ncircuit.ccx( search_register[2], ancillaries[0], ancillaries[1] )\ncircuit.ccx( search_register[0], search_register[1], ancillaries[0] )\ncircuit.h(search_register)\n\nDoing this instead produced the desired result.\n"], "comments": [], "link": "https://quantumcomputing.stackexchange.com//questions/5959/grovers-algorithm-returns-skewed-probability-distribution"}