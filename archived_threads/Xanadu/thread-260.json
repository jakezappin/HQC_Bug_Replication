{"0": {"author": "James_Ellis", "date": "1638722810880", "content": "I have a system with N total qubits, N_A ancillary qubits, and N-N_A data qubits.\nHow would I be able to implement the following:\n\nTake the partial measurement,  (|0\\rangle \\langle 0|)^{\\otimes^{N_A}}, on the ancillary subsystem\nTrace out the ancillary qubits leaving the post-measurement state \\rho\n\nMeasure the probability of each computational basis state given \\rho\n\n\nAny ideas or thoughts would be greatly appreciated.\nThanks!\n\n\n Solved by Diego in post #2 \n\n\n                Hi @James_Ellis, \nI don\u2019t think we have mid-circuit measurement or density matrix representations implemented in PennyLane yet. \nThat being said, we can still answer the question manually. For a simple two qubit system we could do something like: \ndev = qml.device('default.qubit',wires=2)\n@qml.qnode\u2026\n              \n", "link": "https://discuss.pennylane.ai//t/ancillary-subsystem-measurement-then-trace-out/1532/1"}, "1": {"author": "Diego", "date": "1638812736296", "content": "Hi @James_Ellis,\nI don\u2019t think we have mid-circuit measurement or density matrix representations implemented in PennyLane yet.\nThat being said, we can still answer the question manually. For a simple two qubit system we could do something like:\ndev = qml.device('default.qubit',wires=2)\n@qml.qnode(dev)\ndef circuit():\n    qml.RY(2.7, wires=0)\n    qml.RY(2.1,wires=1)\n    return qml.probs()\n\nprobs=circuit()\nbitstrings = [format(i,'02b') for i in range(4)]\n\nprobsgiven0 =[]\nfor index,bitstring in enumerate(bitstrings):\n    if bitstring[0]=='0':\n        probsgiven0.append(probs[index])\n\nprobsgiven0 /= np.sum(probsgiven0)\n\nprint(probs)\nprint(bitstrings)\nprint(probsgiven0)\n>>> [0.01  0.033 0.249 0.708]\n>>> ['00', '01', '10', '11']\n>>> [0.23255814   0.76744186]\n\nHere we are just taking the probabilities of over all of the qubits and manually calculating the probability that the second qubit is in state 0 or 1 given that the first qubit was measured as 0.\nThis code goes through the trouble of using bit strings to give intuition about which qubits we are working with. But we could skip the bit strings and just be careful with our array indexing.\nLet me know if this helps or if there are further questions!Solution2", "link": "https://discuss.pennylane.ai//t/ancillary-subsystem-measurement-then-trace-out/1532/2"}, "2": {"author": "James_Ellis", "date": "1638828844869", "content": "Instead of the for loop,  could we do something like probsgiven0 = probs[:(2**N / 2**N_A)] where N is the number of qubits, while N_A represents the number of ancillary qubits, assuming a partial measurement of (|0\\rangle \\langle 0|)^{\\otimes^{N_A}}?1 Reply", "link": "https://discuss.pennylane.ai//t/ancillary-subsystem-measurement-then-trace-out/1532/3"}, "3": {"author": "James_Ellis", "date": "1638887285865", "content": "I also have another question, is there a way to implement this all within the circuit() function. When I try to save qml.probs() to variable within the circuit() function , I receive TypeError: 'MeasurementProcess' object is not subscriptable  for the following code:\ndev = qml.device(\"default.qubit\", wires=n_qubits)\n@qml.qnode(dev, interface='torch', diff_method=\"parameter-shift\")\n\ndef quantum_circuit(input, weights):\n\n    #Some parameterised quantum circuit \n\n    #Perform a partial measurement |0><0| tensorprod N_A on the ancillary subsystem\n    probs = qml.probs(wires=list(range(n_qubits)))\n    probsgiven0 = probs[:(2**(n_qubits - n_a_qubits))]\n    probsgiven0 /= np.sum(probs)\n    return probsgiven01 Reply", "link": "https://discuss.pennylane.ai//t/ancillary-subsystem-measurement-then-trace-out/1532/4"}, "4": {"author": "Diego", "date": "1638895136451", "content": "\n\n\n James_Ellis:\n\nInstead of the for loop,  could we do something like probsgiven0 = probs[:(2**N / 2**N_A)] where N is the number of qubits, while N_A represents the number of ancillary qubits, assuming a partial measurement of (|0\\rangle \\langle 0|)^{\\otimes^{N_A}}?\n\n\nThis should would work as long as the data qubits are in the bottom part of the qubit register. I also want to emphasize that these will be the probabilities when the N_A qubits are all measured as zero.", "link": "https://discuss.pennylane.ai//t/ancillary-subsystem-measurement-then-trace-out/1532/5"}, "5": {"author": "Diego", "date": "1638895896488", "content": "\n\n\n James_Ellis:\n\nI also have another question, is there a way to implement this all within the circuit() function. When I try to save qml.probs() to variable within the circuit() function , I receive TypeError: 'MeasurementProcess' object is not subscriptable  for the following code:\ndev = qml.device(\"default.qubit\", wires=n_qubits)\n@qml.qnode(dev, interface='torch', diff_method=\"parameter-shift\")\n\ndef quantum_circuit(input, weights):\n\n    #Some parameterised quantum circuit \n\n    #Perform a partial measurement |0><0| tensorprod N_A on the ancillary subsystem\n    probs = qml.probs(wires=list(range(n_qubits)))\n    probsgiven0 = probs[:(2**(n_qubits - n_a_qubits))]\n    probsgiven0 /= np.sum(probs)\n    return probsgiven0\n\n\n\nI don\u2019t think it\u2019s possible to use qml.probs this way. Would it be useful to call the parameterised circuit from inside a standard python function? Something like this:\ndev = qml.device(\"default.qubit\", wires=n_qubits)\n@qml.qnode(dev, interface='torch', diff_method=\"parameter-shift\")\n\ndef parameterised_circuit(input, weights):\n    #some circuit\n    return qml.probs()\n\ndef regular_function(input, weights):\n   \n    parameterised_circuit(input,weights)\n\n    #Perform a partial measurement |0><0| tensorprod N_A on the ancillary subsystem\n    probs = parameterised_circuit(input,weights)\n    probsgiven0 = probs[:(2**(n_qubits - n_a_qubits))]\n    probsgiven0 /= np.sum(list(probs))\n    return probsgiven0\n1", "link": "https://discuss.pennylane.ai//t/ancillary-subsystem-measurement-then-trace-out/1532/6"}, "6": {"author": "jogi_suda", "date": "1691184518998", "content": "Guys, I know the thread is old, but I was running some tests and I noticed that in James\u2019 first answer, the probabilities are correctly re-normalized:\ndev = qml.device('default.qubit',wires=2)\n@qml.qnode(dev)\ndef circuit():\n    qml.RY(2.7, wires=0)\n    qml.RY(2.1,wires=1)\n    return qml.probs()\n\nprobs=circuit()\nbitstrings = [format(i,'02b') for i in range(4)]\n\nprobsgiven0 =[]\nfor index,bitstring in enumerate(bitstrings):\n    if bitstring[0]=='0':\n        probsgiven0.append(probs[index])\n\nprobsgiven0 /= np.sum(probsgiven0)\n\nprint(probs)\nprint(bitstrings)\nprint(probsgiven0)\n>>> [0.01  0.033 0.249 0.708]\n>>> ['00', '01', '10', '11']\n>>> [0.23255814   0.76744186]\n\nHowever, in the last answer this line does not give the correct normalized probas:\nprobsgiven0 /= np.sum(list(probs))\n\nSince the sum of probs is always 1.0, I would just correct it to:\nprobsgiven0 /= torch.sum(probsgiven0)\n", "link": "https://discuss.pennylane.ai//t/ancillary-subsystem-measurement-then-trace-out/1532/7"}, "7": {"author": "Ivana_at_Xanadu", "date": "1691404332382", "content": "Definitely an old thread, but I think you might be right.  Thanks for spotting it!\nBut it looks like torch.sum wants the input to be a torch.Tensor, so we could stick with NumPy here: probsgiven0 /= np.sum(probsgiven0).", "link": "https://discuss.pennylane.ai//t/ancillary-subsystem-measurement-then-trace-out/1532/8"}, "8": {"author": "jogi_suda", "date": "1691415206454", "content": "Indeed numpy is the correct way for this snippet. I had put in torch format because this code is part of the QGAN demo - Quantum GANs (pennylane.ai) 3, which uses tensors instead.", "link": "https://discuss.pennylane.ai//t/ancillary-subsystem-measurement-then-trace-out/1532/9"}, "9": {"author": "Ivana_at_Xanadu", "date": "1691415927256", "content": "Good point, thanks for adding! ", "link": "https://discuss.pennylane.ai//t/ancillary-subsystem-measurement-then-trace-out/1532/10"}, "10": {"author": "Diego", "date": "1638895136451", "content": "\n\n\n James_Ellis:\n\nInstead of the for loop,  could we do something like probsgiven0 = probs[:(2**N / 2**N_A)] where N is the number of qubits, while N_A represents the number of ancillary qubits, assuming a partial measurement of (|0\\rangle \\langle 0|)^{\\otimes^{N_A}}(|0\u27e9\u27e80|)\u2297NA?\n\n\nThis should would work as long as the data qubits are in the bottom part of the qubit register. I also want to emphasize that these will be the probabilities when the N_ANA qubits are all measured as zero.", "link": "https://discuss.pennylane.ai//t/ancillary-subsystem-measurement-then-trace-out/1532/11"}}