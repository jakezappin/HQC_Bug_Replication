{"0": {"author": "ankit27kh", "date": "1653835182076", "content": "Currently, default.qubit is used for ideal simulations and default.mixed is used for noisy simulations.\nWhat is the difference between the two that prevents the former device from implementing noise models?\nWhen I use a noise gate like qml.DepolarizingChannel, what is being implemented in terms of gates on the circuit?\nThe documentation refers to Kraus operators relating to each Pauli operator. Can the noise gate be simulated by probabilistically applying the Pauli gates on the default.qubit device?\nFor example, is the below code correctly applying the noise channel?\n@qml.qnode(dev)\ndef circ():\n    qml.RY(.5, wires=0)\n    \n    # Depolarising Noise\n    if np.random.choice([True, False], p=[d / 3, 1 - d / 3]):\n        qml.PauliX(0)\n    if np.random.choice([True, False], p=[d / 3, 1 - d / 3]):\n        qml.PauliY(0)\n    if np.random.choice([True, False], p=[d / 3, 1 - d / 3]):\n        qml.PauliZ(0)\n\n    return qml.expval(qml.PauliX(0))\n", "link": "https://discuss.pennylane.ai//t/how-is-noise-implemented-in-default-mixed-device/1924/1"}, "1": {"author": "CatalinaAlbornoz", "date": "1654021114362", "content": "Hi @ankit27kh,\nWith default.mixed the density matrix remains the same and the probabilistic nature of the DepolarizingChannel is taken into account within the device. This allows for a more complex study of error and error correction.\nYour approach would be equivalent to using default.mixed if you don\u2019t need any deep analysis of error, but note that the state of the circuit and the density matrix will be different every time you run your circuit since you are essentially creating a different deterministic circuit every time, instead of creating one probabilistic circuit.\nAs an example:\nAfter your code run\nprint('circ v1',circ())\nqml.draw_mpl(circ)()\nprint('circ v2',circ())\nqml.draw_mpl(circ)()\n\nYou will notice that you essentially build a different circuit every time.\nInstead, if you run the following code you will basically get the same circuit every time:\ndev2 = qml.device('default.mixed', wires = 1)\n\n@qml.qnode(dev2)\ndef circ2():\n    qml.RY(.5, wires=0)\n    qml.DepolarizingChannel(d, wires=0)\n    return qml.density_matrix([0])\n\nprint('circ2 v1',circ2())\nqml.draw_mpl(circ2)()\nprint('circ2 v2',circ2())\nqml.draw_mpl(circ2)()\n\nPlease let me know if this is clear or if you need any other help!", "link": "https://discuss.pennylane.ai//t/how-is-noise-implemented-in-default-mixed-device/1924/2"}, "2": {"author": "ankit27kh", "date": "1654025960264", "content": "Hey @CatalinaAlbornoz, thanks for the response.\nI have some further questions regarding using the default.qubit device for simulating noise.\n\n\nHow are the measurements returned when using the gates directly? For example, when calculating expectation values with a given number of shots, does it consider the probability I have supplied for each gate?\n\n\nWhat happens when using None shots with the probabilistically applied gates?\n\n\nAt least when using None shots, shouldn\u2019t the result from both devices match if they are doing the same computation?\n\n", "link": "https://discuss.pennylane.ai//t/how-is-noise-implemented-in-default-mixed-device/1924/3"}, "3": {"author": "Guillermo_Alonso", "date": "1654089807842", "content": "Hey @ankit27kh , let me answer these questions  When working with probabilities in this way inside the circuit there is no vector that correctly defines the state. You can see that if you calculate qml.state each time you will get a different thing. However, the default.mixed has only one way to represent that state through the density matrix.\nIf you are going to return qml.probs or qml.sample you will see no real difference between using one device or the other, regardless of the number of shots you put in. In particular when you put shots = None , it is solved analytically (as if there were infinite shots) so you will see no difference.\nIn short, if you are not going to use qml.state() you should not notice any difference between the devices (although in the mixed you have some gates already coded that can save you work)1 Reply", "link": "https://discuss.pennylane.ai//t/how-is-noise-implemented-in-default-mixed-device/1924/4"}, "4": {"author": "ankit27kh", "date": "1654092844851", "content": "Hey @Guillermo_Alonso, thank you for this! It covers all of my questions.\nBut I am not getting identical results from the two devices.\nConsider the code below:\nimport pennylane as qml\nimport pennylane.numpy as np\n\nshots = 100\ndev1 = qml.device('default.qubit', wires=1, shots=shots)\ndev2 = qml.device('default.mixed', wires=1, shots=shots)\n\nd = .7\n\n@qml.qnode(dev2)\ndef circ2():\n    qml.RY(1, wires=0)\n\n    qml.DepolarizingChannel(d, 0)\n\n    return qml.expval(qml.PauliX(wires=0))\n\n@qml.qnode(dev1)\ndef circ1():\n    qml.RY(1, wires=0)\n\n    if np.random.choice([True, False], p=[d / 3, 1 - d / 3]):\n        qml.PauliX(0)\n    if np.random.choice([True, False], p=[d / 3, 1 - d / 3]):\n        qml.PauliY(0)\n    if np.random.choice([True, False], p=[d / 3, 1 - d / 3]):\n        qml.PauliZ(0)\n\n    return qml.expval(qml.PauliX(wires=0))\n\nprint(\"default.mixed\")\nfor _ in range(3):\n    np.random.seed(42)\n    print(circ2())\n\nprint(\"default.qubit\")\nfor _ in range(3):\n    np.random.seed(42)\n    print(circ1())\n\nThis results in the output:\ndefault.mixed\n0.14\n0.14\n0.14\ndefault.qubit\n0.86\n0.86\n0.86\n\nAs you can see, these don\u2019t match. I am also resetting the seed every time. You can also use None shots. It does not match even then.\nThe reason for trying this instead of just using the default.mixed device is that this device does not support JAX. So if I can replicate the results with default.qubit device, I can then use JAX-JIT to reduce my computation time.", "link": "https://discuss.pennylane.ai//t/how-is-noise-implemented-in-default-mixed-device/1924/5"}, "5": {"author": "Guillermo_Alonso", "date": "1654096757359", "content": "Theoretically it should work but I don\u2019t see the problem I have to check the Depolarization structure, to see what is going on. As you can see, with another operator it works.\nimport pennylane as qml\nimport pennylane.numpy as np\n\nshots = 1000\n\ndev1 = qml.device('default.qubit', wires=1)\ndev2 = qml.device('default.mixed', wires=1)\n\nd = 0.7 \n\n\n\n@qml.qnode(dev1)\ndef circ1():\n    qml.RY(2, wires=0)\n\n    if np.random.rand() < d:\n        qml.PauliX(0)\n\n    return qml.expval(qml.PauliX(wires=0))\n\n\nprint(\"default.qubit:\", circ1())\n    \n    \n@qml.qnode(dev2)\ndef circ2():\n    \n    qml.RY(2, wires=0)\n\n    qml.BitFlip(d, 0)\n\n    return qml.expval(qml.PauliX(wires=0))\n\nprint(\"default.mixed\", circ2())\n\nIf I find out anything I will write you here1", "link": "https://discuss.pennylane.ai//t/how-is-noise-implemented-in-default-mixed-device/1924/6"}, "6": {"author": "kevinkawchak", "date": "1692806623597", "content": "\n\n\n Guillermo_Alonso:\n\nwhen you put shots = None , it is solved analytically (as if there were infinite shots) so you will see no difference.\n\n\nHello Guillermo,\nFor Documentation \u201cUsing Pennylane\u201d Example:\nnp.random.seed(1)\ndev = qml.device(\u201cdefault.qubit\u201d, wires=1)\n@qml.qnode(dev)\ndef circuit():\nqml.Hadamard(wires=0)\nreturn qml.expval(qml.PauliZ(0))\nRunning the simulator with shots=None returns the exact expectation.\ncircuit(shots=None) 0.0\nNow we set the device to return stochastic results, and increase the number of shots starting from 10.\ncircuit(shots=10) 0.2\ncircuit(shots=1000) -0.062\ncircuit(shots=100000) 0.00056\nThe result converges to the exact expectation.\nQuestions:\n\n\nWhen \u201cshots=None\u201d for quantum simulators: are all quantum mechanical properties preserved when running quantum algorithms vs. on real hardware?\n\n\nWill there be near-term quantum hardware that can productively perform complex machine learning tasks (minimizing shots and minimizing time for each epoch, while coming closer to the exact expectation)?\n\n\nThank You\nReference:\nhttps://docs.pennylane.ai/en/stable/introduction/measurements.html 3", "link": "https://discuss.pennylane.ai//t/how-is-noise-implemented-in-default-mixed-device/1924/7"}, "7": {"author": "Guillermo_Alonso", "date": "1692879945810", "content": "Hi @kevinkawchak ! \nRegarding the first question, you could work with shots = None  for develop any quantum simulation. However, you have to be careful. On the one hand, you may design an algorithm that to achieve certain guarantees, the number of shots you would need to calculate the value would grow exponentially and this would go unnoticed by working in an analytical way. On the other hand, there are differentiation methods that will not work if we set shots (and therefore will not work on real hardware).\nThe second question is something that is not known with certainty. But from my point of view, if we get there, methods that use fewer circuits or fewer shots will start to be interesting, since these technologies generally do not seem to be free 1", "link": "https://discuss.pennylane.ai//t/how-is-noise-implemented-in-default-mixed-device/1924/8"}, "8": {"author": "kevinkawchak", "date": "1692892591487", "content": "Thank you, I appreciate the response.", "link": "https://discuss.pennylane.ai//t/how-is-noise-implemented-in-default-mixed-device/1924/9"}}