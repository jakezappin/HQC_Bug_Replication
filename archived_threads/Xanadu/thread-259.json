{"0": {"author": "Einar_Gabbassov", "date": "1626116005382", "content": "Hi,\nPython functions that define circuits which return sampling are not differentiable. This is quite understandable. But doesn\u2019t qml.expVal() use sampling to estimate the energy? Why circuits that return qml.expVal() can be differentiated?\n\n\n Solved by josh in post #4 \n\n\n                Hi @Einar_Gabbassov! \nI believe what you want to do is possible, using PennyLane\u2019s concept of \u2018shot-batching\u2019. \nFor example, consider the following QNode: \nimport pennylane as qml\nfrom pennylane import numpy as np\n\ndev = qml.device(\"default.qubit\", wires=2, shots=[(1, 100)])\n\n@qml.qnode(dev)\ndef cir\u2026\n              \n", "link": "https://discuss.pennylane.ai//t/differentiable-circuit-with-sampling/1190/1"}, "1": {"author": "Tom_Bromley", "date": "1626120114713", "content": "Hey @Einar_Gabbassov!\n\nBut doesn\u2019t qml.expVal() use sampling to estimate the energy?\n\nExpectation values can be calculated either using sampling or analytically with access to the underlying state (only compatible with simulators). Analytic mode is specified by setting shots=None when loading your PennyLane device and is the default.\n\nWhy circuits that return qml.expVal() can be differentiated?\n\nWhile it doesn\u2019t make sense to differentiate a given sample from a random process (e.g. a quantum circuit), it is ok to differentiate a statistic defined on the random process (such as the expectation value).\nThe expectation value is a function \\mu = f(\\boldsymbol{\\theta}) that maps from the circuit parameters \\boldsymbol{\\theta} to the corresponding value. With an exact simulator, we know \\mu exactly while on an approximate simulator or quantum hardware we find an estimate \\hat{\\mu}.\nThe gradient of the expectation value g(\\boldsymbol{\\theta}) := \\nabla_{\\boldsymbol{\\theta}} f(\\boldsymbol{\\theta}) is also well defined. Again, we can find g(\\boldsymbol{\\theta}) exactly with an exact simulator or estimate it when we have a limited number of shots. Check out Sec. 4 of this 2 paper to get a deeper understanding.\nIn other words, having a finite number of shots just means that the gradient of the expectation value is approximate.1", "link": "https://discuss.pennylane.ai//t/differentiable-circuit-with-sampling/1190/2"}, "2": {"author": "Einar_Gabbassov", "date": "1626121750210", "content": "hi @Tom_Bromley\nThank you for the detailed reply!\nThis brings me to the question which I wanted to ask but decided to differ until I get the answer for the first question.\nIn practice, one might want to use bias estimates. As far as I know expVal() gives unbiased estimate. This is not flexible.\nIdeally, a circuit like this would be very useful\nansatz(params)\nsamples = qml.sample(Operator)\nreturn compute_biased_average(samples)\n\nThe above could be differentiated. However, as far as I know we can\u2019t do this for two reasons:\n\nPennylane gives warning that circuits which use sampling can\u2019t be differentiated.\nAccording to the Docs,  circuit functions must not contain arbitrary code, except multiplication operations.\n\nUnless, I miss some technicality (which is very likely), the above puzzles me a lot. We can use samples to compute expVal and do differentiation, but we can\u2019t use samples to compute other estimates such that the circuit is still differentiable.\nI hope I\u2019m wrong, otherwise it makes my day so  much harder ", "link": "https://discuss.pennylane.ai//t/differentiable-circuit-with-sampling/1190/3"}, "3": {"author": "josh", "date": "1626162652299", "content": "Hi @Einar_Gabbassov!\nI believe what you want to do is possible, using PennyLane\u2019s concept of \u2018shot-batching\u2019.\nFor example, consider the following QNode:\nimport pennylane as qml\nfrom pennylane import numpy as np\n\ndev = qml.device(\"default.qubit\", wires=2, shots=[(1, 100)])\n\n@qml.qnode(dev)\ndef circuit(params):\n    for i in range(2):\n        qml.RX(params[i, 0], wires=i)\n        qml.RY(params[i, 1], wires=i)\n\n    qml.CNOT(wires=[0, 1])\n\n    for i in range(2):\n        qml.RX(params[2 + i, 0], wires=i)\n        qml.RY(params[2 + i, 1], wires=i)\n\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(0))\n\nWe have specified that the device has shots [(1, 100)], which corresponds to [(size_of_batch, number of batches)]. This means that the QNode will be executed for 100 shots on the remote hardware/simulator, however, these 100 shots will be post-processed in batches of 1. In essence, we are computing single-shot expectation values:\n>>> params = np.ones([4, 2], dtype=np.float64)\n>>> circuit(params)\n[ 1.  1.  1. -1.  1. -1. -1. -1. -1.  1.  1. -1. -1. -1. -1.  1.  1. -1.\n  1.  1. -1.  1.  1.  1. -1. -1.  1. -1. -1.  1. -1. -1. -1. -1. -1. -1.\n -1. -1. -1. -1. -1.  1. -1.  1.  1.  1. -1. -1. -1. -1.  1. -1.  1. -1.\n -1. -1. -1. -1. -1. -1. -1.  1. -1.  1. -1.  1. -1. -1.  1. -1. -1. -1.\n  1.  1. -1.  1. -1.  1. -1.  1. -1.  1.  1. -1. -1.  1. -1. -1. -1. -1.\n  1.  1. -1.  1. -1.  1. -1.  1.  1.  1.]\n\nNote that we are not using sample, we are using expval, so this is differentiable!\nLet\u2019s create a cost function that processes this to compute the population variance:\ndef cost(params):\n    samples = circuit(params)\n    return np.var(samples, ddof=1)\n\nThis can be differentiated:\n>>> cost(params)\n0.9418181818181818\n>>> qml.grad(cost)(params)\n[[-0.03636364  0.14343434]\n [ 0.13131313  0.04848485]\n [-0.02626263 -0.05252525]\n [ 0.07474747 -0.03030303]]\n2 RepliesSolution2", "link": "https://discuss.pennylane.ai//t/differentiable-circuit-with-sampling/1190/4"}, "4": {"author": "josh", "date": "1626175316587", "content": "More details on shot-batching is available here: https://pennylane.readthedocs.io/en/stable/introduction/circuits.html#shot-batches 31", "link": "https://discuss.pennylane.ai//t/differentiable-circuit-with-sampling/1190/5"}, "5": {"author": "Einar_Gabbassov", "date": "1626213860547", "content": "@josh thanks a lot! This is great!", "link": "https://discuss.pennylane.ai//t/differentiable-circuit-with-sampling/1190/6"}, "6": {"author": "Oriel", "date": "1626244008906", "content": "Hi, thanks everyone for the nice discussion.\nI am trying to do the same with the strawberry.fock backend but I get a single output, even if I specify shots = [(1,100)].\nMore specifically, I am using\ndev = qml.device(\"strawberryfields.fock\", wires=1, cutoff_dim=10, shots=[(1,100)])\nand the same photonic quantum neural network as in the tutorial (with expval(qml.X(0))\nDoes anyone have an idea why i do not get 100 output like in the answer from Josh?  Thanks a lot", "link": "https://discuss.pennylane.ai//t/differentiable-circuit-with-sampling/1190/7"}, "7": {"author": "josh", "date": "1626269669908", "content": "Hi @Oriel, unfortunately I believe that this is because the strawberryfields.fock device has not yet been updated to support shot batching.\nThanks for catching this! I will create a GitHub issue to alert the team.", "link": "https://discuss.pennylane.ai//t/differentiable-circuit-with-sampling/1190/8"}, "8": {"author": "Tom_Bromley", "date": "1626272670449", "content": "Here is the issue:\n\n\ngithub.com/PennyLaneAI/pennylane-sf\n\n\n\n\n\n\n\n\nDevices do not support shot batching\n\n\n\n        opened \n\n\n\nJul 14, 2021\n\n\n\n          closed \n\n\n\nSep 28, 2021\n\n\n\n\n\n          trbromley\n        \n\n\n\n\n          bug\n        \n\n\n\n\n#### Issue description\n\nhttps://github.com/PennyLaneAI/pennylane/pull/1103 was\u2026 merged a few months ago to support shot batching. This involves processing the input shots into a total number of shots (specified by `self._shots`) and a shots vector (specified by `self._shot_vector`).\n\nCurrently the PennyLane-SF devices all inherit from `StrawberryFieldsSimulator`. In its `expval` method, there is no usage of the `self._shot_vector` attribute - the method just samples based on the total number of shots and returns the average.\n\nConsider\n\n```python\nimport pennylane as qml\n\ndev = qml.device(\"strawberryfields.fock\", wires=1, cutoff_dim=10, shots=[50, 50])\n\n@qml.qnode(dev)\ndef qnode(x):\n    # Encode input x into quantum state\n    qml.Displacement(x, 0.0, wires=0)\n\n    return qml.expval(qml.X(0))\n```\nThe expected return is\n```pycon\n>>> qnode(0.2)\ntensor([0.36074875, 0.40190935], requires_grad=True)\n```\nThat is, two repetitions with 50 shots. The actual output is\n```pycon\n>>> qnode(0.2)\ntensor(0.53289407, requires_grad=True)\n```\nThat is, one repetition with 100 shots.\n\n\n\n\n\n\n1 Reply", "link": "https://discuss.pennylane.ai//t/differentiable-circuit-with-sampling/1190/9"}, "9": {"author": "Einar_Gabbassov", "date": "1626286852997", "content": "Hi,\nI\u2019ve been trying the proposed approach but it messes up outputs from the qml.ExpvalCost().\nFor example, I have a device with shots = 100.\nI call qml.ExpvalCost(), this returns a single value, ok!\nNext, I modify my device so that it does batch shots, dev.shots=[(1,100)]\nand I run my custom cost function which is now differentiable because I use  batches with qml.expval(). Then, I try to set the device back to the default behaviour dev.shots=100.\nBut this breaks  qml.ExpvalCost() as it does not output a single value but an average energy for each Hamiltonian term.\nI would post an error, but it is pretty hard to pin point a meaningful error trace.\nHow I could temporarily set batch shots and then revert back to default single batch behaviour without qml.ExpvalCost() doing funny stuff?", "link": "https://discuss.pennylane.ai//t/differentiable-circuit-with-sampling/1190/10"}, "10": {"author": "Einar_Gabbassov", "date": "1626287199332", "content": "ah, I just realized that I have a single objective function which consists of two functions. One function tries to make use of the default device and the other function is trying to use the device with batch shots.\nTrying manipulate the device from inside the functions doesn\u2019t work.", "link": "https://discuss.pennylane.ai//t/differentiable-circuit-with-sampling/1190/11"}, "11": {"author": "josh", "date": "1626329100894", "content": "Hey @Einar_Gabbassov, could you post a small code example showing what you mean?1 Reply", "link": "https://discuss.pennylane.ai//t/differentiable-circuit-with-sampling/1190/12"}, "12": {"author": "Oriel", "date": "1626701997182", "content": "Hi,\nOn the same note, i would like to efficiently sample from circuits with shifted parameters, where the shifts correspond to the shift in the shift rule. I mean, if I have a circuit with a single qubit rotation with angle theta, I would like to sample from the circuit with angle theta + pi/2 and theta - pi/2.\nI tried to do it myself but I am lacking efficiency since I basically do a for loop over all parameters. Does anyone know if this is already implemented or if there is a more efficient way to do so?\nThanks a lot", "link": "https://discuss.pennylane.ai//t/differentiable-circuit-with-sampling/1190/13"}, "13": {"author": "josh", "date": "1626713743824", "content": "Hey @Oriel, there is a manual implementation of the shift rule available in the backpropagation tutorial:\ndef parameter_shift_term(qnode, params, i):\n    shifted = params.copy()\n    shifted[i] += np.pi/2\n    forward = qnode(shifted)  # forward evaluation\n\n    shifted[i] -= np.pi\n    backward = qnode(shifted) # backward evaluation\n\n    return 0.5 * (forward - backward) \n\ndef parameter_shift(qnode, params):\n    gradients = np.zeros([len(params)])\n\n    for i in range(len(params)):\n        gradients[i] = parameter_shift_term(qnode, params, i)\n\n    return gradients\n\nThis assumes that the QNode only takes a single parameter, and this single parameter is a 1-dimensional NumPy array ", "link": "https://discuss.pennylane.ai//t/differentiable-circuit-with-sampling/1190/14"}, "14": {"author": "Einar_Gabbassov", "date": "1627323562950", "content": "hi @josh\nSorry for taking so long, been busy.\nI attached  the snippet of the code at the end of this post. Basically, the code has a Hamiltonian with 4 terms and the device is configured to use batch shots i.e, shots=[1, num_batches]. Strangely, the output from the expValCost function are 4 values. This doesn\u2019t make sense, because based on the default mechanics, expValCost should output  expectations of energy of the entire Hamiltonian and not expectations of each Hamiltonian term.\nI was able to rectify this by writing my own expValCost which works with batch shots. However, the fundamental problem arises when trying to do gradient descent optimization.\nFrom what I understand, suppose we use MyExpValCost() that produces Hamiltonian energy samples (each energy sample is evaluated from a single shot but we have many batches just as you recommended).\nThis would yield an array of Hamiltonian energies:\nenergy_samples = MyExpValCost(params)\nprint(\"energy samples:\", energy_samples)\n\nThe output for 10 batches is 10 expected energies of the Hamiltonian H. All 10 expectations are estimated from 1 shot.\nThat is, we have,\n\\{<H>_1, <H>_2, ..., <H>_{10}\\}.\nNext, I create a cost function like so\ncost = \\sum_{i=1}^{10} <H>_i.\nAs you claimed this is differentiable.\nThe fundamental problem with this is that it takes orders of magnitude more time to evaluate. Let\u2019s say I do 100000 batches (each batch is one shot). Then the autograd should differentiate a sum which contains 100000 differentiable terms.\nJust to conclude, there are two problems:\n\nExpValCost has strange output when batch shots are used.\nEven if 1. is not the case, the differentiation with batch shots is extremely slow compared to just differentiation of a cost function which uses expValCost with NO batch shots.\n\nI still need a differentiable circuit which can do sampling  then process sampling for producing some biased estimates.\nansatz(params)\nsamples = qml.sample(Operator)\nreturn compute_biased_average(samples)\n\nHere is the code which shows that expValCost produces 4 terms instead of Hamiltonian energies:\nobjective_hamiltonian = qml.Hamiltonian([1,1,1,1], [qml.PauliZ(0), qml.PauliZ(1), qml.PauliZ(2), qml.PauliZ(3)])\n\ndef ansatz(params, wires, depth, h_objective_coeffs, **kwargs):\n    params = params.reshape((depth, 2))\n    # Initial state\n    qml.BasisState(np.array([0]*num_qubits, requires_grad=False), wires=wires)\n    # Add Hadamard gates\n    for i in wires:\n        qml.Hadamard(wires=i)\n\n\n\nnum_qubits = 4      \nnum_shots = 10000\n# Use batch shots for differentiability\ndev = qml.device('default.qubit', wires=num_qubits, shots=[1,num_shots])\n\ndepth = 1\npenalty = 2\n\nansatz_settings = {\n    \"h_objective_coeffs\": objective_hamiltonian.coeffs,\n    \"wires\": dev.wires,\n    \"depth\": depth\n}\n\nansatz = partial(ansatz, **ansatz_settings)\n\n\nobjective_cost_fn = qml.ExpvalCost(ansatz, objective_hamiltonian, dev, optimize=True)\n\nparams = np.zeros((1,2))\nobjective_cost_fn(params)\n", "link": "https://discuss.pennylane.ai//t/differentiable-circuit-with-sampling/1190/15"}, "15": {"author": "sjahangiri", "date": "1627412911576", "content": "Hi @Einar_Gabbassov. It seems that using optimize=True, which enables separating the Hamiltonian observable terms into qubit-wise commuting groups, causes the issue with shot-batching. You can disable the grouping by using optimize=False which might slightly slow down your simulations depending on the Hamiltonian used.\nPlease note that we are working on a functionality that supports using expval(H) directly and after having that functionality implemented in PennyLane, ExpvalCost will be very likely deprecated. Please let us know if you have any other questions. Thanks.", "link": "https://discuss.pennylane.ai//t/differentiable-circuit-with-sampling/1190/16"}, "16": {"author": "Einar_Gabbassov", "date": "1627414439744", "content": "hi @sjahangiri\nThanks for the reply. Unfortunately, this workaround is quite costly as it will lead to too many measurements during gradient descent. I would still report this as a  bug.\nImportantly, my original question is still open. I\u2019m trying to get a differentiable circuit which can use custom expval. As I mentioned before, besides the bug,  the batch shots give extremely slow computation.\nCould you guys please help me with this?\nJust as a refresher, here is what I would like to have in a differentiable circuit body:\nansatz(params)\nsamples = qml.sample(Operator)\nreturn compute_biased_average(samples)\n", "link": "https://discuss.pennylane.ai//t/differentiable-circuit-with-sampling/1190/17"}, "17": {"author": "Tom_Bromley", "date": "1627420560903", "content": "Hey @Einar_Gabbassov,\nThanks for pointing out this issue, we have posted a bug report here 2.\nI also agree with what you are saying about the shot batching approach for biasing the expectation value, i.e., that it presents a bottleneck for gradient calculations as you increase the number of samples. I\u2019m not sure what the best approach is here. Perhaps you can work directly with the output probability distribution of the circuit using qml.probs (possibly in multiple bases), rather than accessing samples.", "link": "https://discuss.pennylane.ai//t/differentiable-circuit-with-sampling/1190/18"}, "18": {"author": "Oriel", "date": "1627942254696", "content": "Dear Tom,\nI just wanted to know if shot batching provides any computational speed up over a for loop on user\u2019s side. If yes, i could be tempted to look into the issue. Thanks", "link": "https://discuss.pennylane.ai//t/differentiable-circuit-with-sampling/1190/19"}, "19": {"author": "antalszava", "date": "1628003786634", "content": "Hi @Oriel,\nThanks for your question!\nThere should indeed be an advantage, namely that we \u201cdraw samples\u201d once and then distribute the statistics.\nA shot batch of the form  shots=[100, 200, 5]  will send a  single  job of size  305  shots to be executed, and then partition the results as the shot vector specifies.\nAlternatively, having a for loop over  separate  executions, each of size  100, 200, 5 , will result in  3 jobs  being submitted to the remote server.\nWould you be interested in having a deeper look at how to directly work with the output probability distribution of the circuit using  qml.probs, as Tom suggested?1 Reply", "link": "https://discuss.pennylane.ai//t/differentiable-circuit-with-sampling/1190/20"}, "20": {"author": "Einar_Gabbassov", "date": "1627323562950", "content": "hi @josh\nSorry for taking so long, been busy.\nI attached  the snippet of the code at the end of this post. Basically, the code has a Hamiltonian with 4 terms and the device is configured to use batch shots i.e, shots=[1, num_batches]. Strangely, the output from the expValCost function are 4 values. This doesn\u2019t make sense, because based on the default mechanics, expValCost should output  expectations of energy of the entire Hamiltonian and not expectations of each Hamiltonian term.\nI was able to rectify this by writing my own expValCost which works with batch shots. However, the fundamental problem arises when trying to do gradient descent optimization.\nFrom what I understand, suppose we use MyExpValCost() that produces Hamiltonian energy samples (each energy sample is evaluated from a single shot but we have many batches just as you recommended).\nThis would yield an array of Hamiltonian energies:\nenergy_samples = MyExpValCost(params)\nprint(\"energy samples:\", energy_samples)\n\nThe output for 10 batches is 10 expected energies of the Hamiltonian HH. All 10 expectations are estimated from 1 shot.\nThat is, we have,\n\\{<H>_1, <H>_2, ..., <H>_{10}\\}{<H>1,<H>2,...,<H>10}.\nNext, I create a cost function like so\ncost = \\sum_{i=1}^{10} <H>_i\u221110i=1<H>i.\nAs you claimed this is differentiable.\nThe fundamental problem with this is that it takes orders of magnitude more time to evaluate. Let\u2019s say I do 100000 batches (each batch is one shot). Then the autograd should differentiate a sum which contains 100000 differentiable terms.\nJust to conclude, there are two problems:\n\nExpValCost has strange output when batch shots are used.\nEven if 1. is not the case, the differentiation with batch shots is extremely slow compared to just differentiation of a cost function which uses expValCost with NO batch shots.\n\nI still need a differentiable circuit which can do sampling  then process sampling for producing some biased estimates.\nansatz(params)\nsamples = qml.sample(Operator)\nreturn compute_biased_average(samples)\n\nHere is the code which shows that expValCost produces 4 terms instead of Hamiltonian energies:\nobjective_hamiltonian = qml.Hamiltonian([1,1,1,1], [qml.PauliZ(0), qml.PauliZ(1), qml.PauliZ(2), qml.PauliZ(3)])\n\ndef ansatz(params, wires, depth, h_objective_coeffs, **kwargs):\n    params = params.reshape((depth, 2))\n    # Initial state\n    qml.BasisState(np.array([0]*num_qubits, requires_grad=False), wires=wires)\n    # Add Hadamard gates\n    for i in wires:\n        qml.Hadamard(wires=i)\n\n\n\nnum_qubits = 4      \nnum_shots = 10000\n# Use batch shots for differentiability\ndev = qml.device('default.qubit', wires=num_qubits, shots=[1,num_shots])\n\ndepth = 1\npenalty = 2\n\nansatz_settings = {\n    \"h_objective_coeffs\": objective_hamiltonian.coeffs,\n    \"wires\": dev.wires,\n    \"depth\": depth\n}\n\nansatz = partial(ansatz, **ansatz_settings)\n\n\nobjective_cost_fn = qml.ExpvalCost(ansatz, objective_hamiltonian, dev, optimize=True)\n\nparams = np.zeros((1,2))\nobjective_cost_fn(params)\n", "link": "https://discuss.pennylane.ai//t/differentiable-circuit-with-sampling/1190/21"}, "21": {"author": "Oriel", "date": "1628093148903", "content": "Thanks,  i see there is an advantage when running on the hardware because we only have to submit one job. However, it does not make any difference on the simulator, right?", "link": "https://discuss.pennylane.ai//t/differentiable-circuit-with-sampling/1190/22"}, "22": {"author": "josh", "date": "1628142455887", "content": "@Oriel it\u2019s a difficult question to answer, as it depends on the simulator!\nOn some simulators, the computational cost of the simulation may scale with the number of shots required, in which case, you are right \u2014 shot batching would lead to no improvement.\nOn other simulators, including default.qubit, this is not the case. By combining the circuits into a single job with shot-batching, you should see an improvement, since default.qubit only simulates the circuit once, and then generates samples from the resulting statevector.", "link": "https://discuss.pennylane.ai//t/differentiable-circuit-with-sampling/1190/23"}}