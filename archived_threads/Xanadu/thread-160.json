{"0": {"author": "milanleonard", "date": "1600820077263", "content": "I\u2019m trying to compare the effect of various noise-models and noise-model strengths on the actual value of the gradient. To do so, it appears that I should use the qml.grad function ( https://pennylane.readthedocs.io/en/user-docs-refactor/code/pennylane.grad.html#pennylane.grad 1 ).\nI have two issues:\n\nThe QNode wrapper is around a circuit which needs to be executed repeatedly in a larger non-qnode objective function. Something like objective = lambda xs : sum([circuit(x) for x in xs]). When I call grad on this, it is still quite happy to run, but this looks like it is outside of the scope of the docs, should this work, or do I need a big refactor?\nI\u2019m not sure what the arguments to the _gradient_function should be, and everything I\u2019ve tried throws an error (which could be closely associated with issue 1.)\n\nThe approach to my overall task was to have two devices, one analytic and one noisy, and then pull the true gradient out for some fixed circuit parameters using qml.grad, and comparing that to the distribution of noisy parameters. This circuit can be optimized w.r.t. my objective function using a qml.Optimizer(), and so the gradient is being correctly computed somewhere, if we struggle too much with qml.grad is there access to the Optimizers internal gradient function for some set of params? Thanks!\n\n\n Solved by Tom_Bromley in post #7 \n\n\n                Hey @milanleonard! It\u2019s great that you mentioned this, since it\u2019s something that we are working on adding to core PennyLane: this and related additions provide a mixed state simulator default.mixed and access to noisy channels. The default.mixed device should let you work in analytic mode but switch\u2026\n              \n", "link": "https://discuss.pennylane.ai//t/extracting-the-gradient-information-from-a-qnode-for-fixed-parameters/579/1"}, "1": {"author": "josh", "date": "1600877977414", "content": "Hi @milanleonard!\n\nWhen I call grad on this, it is still quite happy to run, but this looks like it is outside of the scope of the docs\n\nThe qml.grad() function is a wrapper around autograd.grad(), which provides the autodifferentiable NumPy module that comes with PennyLane. So it natively supports classical gradients as well as quantum gradients!\nHowever, it may be best to use NumPy functions where possible, so np.sum instead of sum.\n\nI\u2019m not sure what the arguments to the _gradient_function should be, and everything I\u2019ve tried throws an error\n\nThe arguments to the gradient function should match exactly the cost function.\nSo, for example, if you have\ndef cost(x, y):\n    return np.sin(x) + np.cos(2*y)\n\ngrad_fn = qml.grad(cost)\n\nthen you would call this like\ngrad_fn(0.5, 0.1)\n", "link": "https://discuss.pennylane.ai//t/extracting-the-gradient-information-from-a-qnode-for-fixed-parameters/579/2"}, "2": {"author": "Tom_Bromley", "date": "1600896437182", "content": "@milanleonard, not sure if this helps but here is a simple bit of code that I think showcases what you\u2019re looking for:\nimport pennylane as qml\nfrom pennylane import numpy as np\n\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.qnode(dev)\ndef circuit(x):\n    qml.RX(x, wires=0)\n    qml.RX(0.4, wires=1)\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(0))\n\n\ndef objective(xs):\n    return np.sum([circuit(x) for x in xs])\n\nd_objective = qml.grad(objective)\n\nxs = np.arange(10, dtype=np.float)\nd_objective(xs)\n\nAlso, feel free to share your code as this helps us give better feedback.\nThanks,\nTom", "link": "https://discuss.pennylane.ai//t/extracting-the-gradient-information-from-a-qnode-for-fixed-parameters/579/3"}, "3": {"author": "milanleonard", "date": "1600911417737", "content": "Thanks @Tom_Bromley and @josh, that has definitely helped a lot, and pushed me a couple steps further!\nI\u2019m now encountering a slightly different behaviour which is equally disconcerting. I\u2019ll dump the whole code here: https://pastebin.com/AvwTtSxq\nThe behaviour that I\u2019m finding is that despite the analytic device being specified with analytic=True, and with or without shots (or even a ridiculous number of shots), I find that calls to the analytic_gradient function produce different answers each time, despite the whole code being (in my eyes) deterministic.\nIf instead of using qiskit.aer for the analytic device I use default.qubit, this error goes away, but I\u2019m now a little lacking in confidence on how the analytic=True or shots parameter is being picked up by aer. Is it a fair comparison between the analytic gradient as identified by default.qubit and the \u2018noisy\u2019 gradient found using a noise-model within qiskit.aer.\nThanks for the help guys, let me know if this question isn\u2019t well-formed.", "link": "https://discuss.pennylane.ai//t/extracting-the-gradient-information-from-a-qnode-for-fixed-parameters/579/4"}, "4": {"author": "josh", "date": "1600930165157", "content": "Hi @milanleonard!\nThis is because, by default, the qiskit.aer plugin uses QASM simulator backend (backend=\"qasm_simulator\"). The QASM simulator does not support exact expectation value computation, since it only outputs stochastic samples.\nIn fact, you should be receiving a warning message for using analytic=True with the QASM simulator:\n>>> analytic_dev = qml.device(\"qiskit.aer\", wires=n_wires, analytic=True, shots=1000)\nUserWarning: The analytic calculation of expectations, variances\nand probabilities is only supported on statevector backends, not on\nthe qasm_simulator. Such statistics obtained from this device\nare estimates based on samples.\n\nLet me know if this warning message didn\u2019t appear, there could be a bug in the PennyLane-Qiskit plugin!\nTo use analytic mode, you will need to instead use the statevector_simulator backend:\nanalytic_dev = qml.device(\"qiskit.aer\", wires=n_wires, analytic=True, backend=\"statevector_simulator\")\n\nLet me know if that helps!", "link": "https://discuss.pennylane.ai//t/extracting-the-gradient-information-from-a-qnode-for-fixed-parameters/579/5"}, "5": {"author": "milanleonard", "date": "1600932574466", "content": "@josh, thanks so much for getting back. It looks like what I\u2019m trying to do is perhaps a little less \u2018native\u2019 than I was hoping.\nSorry that this is now looking less like a PennyLane question but you might have some insight nonetheless. Is there an approximately easy way to compute the gradient with only the impact of noise. That is, to have something that computes the density matrix of the introduced noise model, but doesn\u2019t include any sampling error. The \u2018statevector_simulator\u2019 with analytic=True won\u2019t let me feed it a noise model, but I can\u2019t decouple the effects of shot noise and environmental noise in QASM. Any ideas?\nP.s. I don\u2019t get that warning message, but the device instantiation is embedded within a function and so maybe the warning doesn\u2019t propagate out, or that I\u2019m not using the most up to date PennyLane version.", "link": "https://discuss.pennylane.ai//t/extracting-the-gradient-information-from-a-qnode-for-fixed-parameters/579/6"}, "6": {"author": "Tom_Bromley", "date": "1600979502216", "content": "Hey @milanleonard! It\u2019s great that you mentioned this, since it\u2019s something that we are working on adding to core PennyLane: this and related additions provide a mixed state simulator default.mixed and access to noisy channels. The default.mixed device should let you work in analytic mode but switch to a mixed-state representation.\nThese features are quite new: we still need the final addition to be merged. Once done, you\u2019d be able to access using\npip uninstall pennylane -y\npip install git+https://github.com/PennyLaneAI/pennylane.git#egg=pennylane\n\nBear in mind that these more recent features may not be quite as stable as established parts of the code base.\nThanks!Solution3", "link": "https://discuss.pennylane.ai//t/extracting-the-gradient-information-from-a-qnode-for-fixed-parameters/579/7"}, "7": {"author": "milanleonard", "date": "1600820077263", "content": "I\u2019m trying to compare the effect of various noise-models and noise-model strengths on the actual value of the gradient. To do so, it appears that I should use the qml.grad function ( https://pennylane.readthedocs.io/en/user-docs-refactor/code/pennylane.grad.html#pennylane.grad 1 ).\nI have two issues:\n\nThe QNode wrapper is around a circuit which needs to be executed repeatedly in a larger non-qnode objective function. Something like objective = lambda xs : sum([circuit(x) for x in xs]). When I call grad on this, it is still quite happy to run, but this looks like it is outside of the scope of the docs, should this work, or do I need a big refactor?\nI\u2019m not sure what the arguments to the _gradient_function should be, and everything I\u2019ve tried throws an error (which could be closely associated with issue 1.)\n\nThe approach to my overall task was to have two devices, one analytic and one noisy, and then pull the true gradient out for some fixed circuit parameters using qml.grad, and comparing that to the distribution of noisy parameters. This circuit can be optimized w.r.t. my objective function using a qml.Optimizer(), and so the gradient is being correctly computed somewhere, if we struggle too much with qml.grad is there access to the Optimizers internal gradient function for some set of params? Thanks!\n\n\n Solved by Tom_Bromley in post #7 \n\n\n                Hey @milanleonard! It\u2019s great that you mentioned this, since it\u2019s something that we are working on adding to core PennyLane: this and related additions provide a mixed state simulator default.mixed and access to noisy channels. The default.mixed device should let you work in analytic mode but switch\u2026\n              \n", "link": "https://discuss.pennylane.ai//t/extracting-the-gradient-information-from-a-qnode-for-fixed-parameters/579/8"}}