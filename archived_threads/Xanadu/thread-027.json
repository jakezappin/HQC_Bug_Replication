{"0": {"author": "omersajid9", "date": "1675892814602", "content": "Hi, I hope you are doing well. I am trying to run a natural gradient descent optimization on my circuit. My original work was in qiskit but I switched to pennylane for its qng optimizer. I noticed that using similar routine for making ansatz in pennylane turns out to be different than qiskit\u2019s ansatz so I am now making my ansatz in qiskit and converting it to qml\u2019s ansatz and running the optimization. The ansatz conversion runs smoothely but I am having errors when I put it in qngoptimizer\u2019s step_and_cost function. I was originally having an error where the parameters I was binding to my qiskit ansatz were tensor or autograd.arraybox so I tried converting them into a float to bind them to my qiskit ansatz. Now, I am getting an error of \u201cValue error: need at least one array to stack.\u201d Can you kindly help me with this error or guide me how I can use my qiskit ansatz with pennylane\u2019s qng optimizer?\nI have the following code:\nfrom qiskit import QuantumCircuit, QuantumRegister\nfrom qiskit.circuit import Parameter\nimport numpy as np\nfrom pennylane import numpy as nnn\nimport pickle\nimport pennylane as qml\nimport pennylane_qiskit\nfrom observable import returnStringObservable\n\ndev = qml.device(\"default.qubit\", wires=8)\n\nconnectivity = [(1, 2), (0, 6), (2, 3), (0, 7), (3, 4), (0, 1), (4, 5), (0, 2), (5, 6), (0, 3), (6, 7), (0, 4), (7, 1), (0, 5)]\nboundary = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 1)]\n\n\nconnectivity = list(map(tuple, connectivity))\nboundary = list(map(tuple, boundary))\n\nclass TwoQubitUnitary(QuantumCircuit):\n    def __init__(self,):\n        super().__init__()\n        work = QuantumRegister(2, name='q')\n        self.add_register(work)\n        self.u(Parameter('p0'), Parameter('p1'), Parameter('p2'), work[0])\n        self.u(Parameter('p3'), Parameter('p4'), Parameter('p5'), work[1])\n        self.cx(work[1], work[0])\n        self.rz(Parameter('p6'), work[0])\n        self.ry(Parameter('p7'), work[1])\n        self.cx(work[0], work[1])\n        self.ry(Parameter('p8'), work[1])\n        self.cx(work[1], work[0])\n        self.u(Parameter('p9'), Parameter('p10'), Parameter('p11'), work[0])\n        self.u(Parameter('p12'), Parameter('p13'), Parameter('p14'), work[1])\n        \nnum_qubits = 8\nboundary_start = 1\nconec_list = [list((i, j)) for (i, j) in connectivity]\n\nparamsList = list()\nenergyList = list()\n\ndef qiskitToQml(parameters):\n    num_gates = len(parameters)/15\n    gates = list()\n\n    for i in range(int(num_gates)):\n        print(i)\n        relevant_params = parameters[i*15:(i*15)+15]\n        gate = TwoQubitUnitary()\n        if (type(relevant_params) == nnn.tensor):\n            gate = gate.bind_parameters({gate.parameters.data[index]: val.unwrap() for (index, val) in enumerate(relevant_params)})\n        else:\n            gate = gate.bind_parameters({gate.parameters.data[index]: (val._value).unwrap() for (index, val) in enumerate(relevant_params)})\n        # gate = gate.bind_parameters({gate.parameters.data[index]: val for (index, val) in enumerate(relevant_params)})\n        gates.append(gate)\n        \n    ansatz = QuantumCircuit(num_qubits)\n\n    print(\"===start===\")\n    for (index, (i, j)) in enumerate(connectivity):\n        if index % 2 == 0:\n            ansatz.append(gates[1], [i, j])\n        else:\n            ansatz.append(gates[0], [i, j])\n    for (index, (i, j)) in enumerate(connectivity[::-1]):\n        if index % 2 == 0:\n            ansatz.append(gates[3], [i, j])\n        else:\n            ansatz.append(gates[2], [i, j])\n    print(\"===End====\")\n    return qml.from_qiskit(ansatz.decompose())\n\nop_list = [(qml.pauli.utils.string_to_pauli_word(singleEntry)) for singleEntry in returnStringObservable(boundary_start, num_qubits)]\nH = qml.Hamiltonian([-1]*len(op_list), op_list)\n\n@qml.qnode(dev)\ndef cost_fn(params):\n    circ = qiskitToQml(params)\n    circ()\n    return qml.expval(H)\n\n\nmax_iterations = 1000\nstep_size = .01\nconv_tol = 5e-07\nopt = qml.QNGOptimizer(stepsize=step_size, approx='diag')\n\nparams = np.random.normal(-0.3, .1, 15*4)\n\n\nqngd_param_history = [params]\nqngd_cost_history = []\n\nparams, prev_energy = opt.step_and_cost(cost_fn, nnn.array(params, requires_grad=True))\nprint(prev_energy)\n\nfor n in range(max_iterations):\n\n    params, next_energy = opt.step_and_cost(cost_fn, nnn.array(params, requires_grad=True))\n    qngd_param_history.append(params)\n    qngd_cost_history.append(next_energy)\n\n    conv = np.abs(next_energy - prev_energy)\n\n    print(\n            \"Iteration = {:},  Energy = {:.8f} Ha,  Convergence parameter = {\"\n            \":.8f} Ha\".format(n, next_energy, conv)\n        )\n\n    if conv <= conv_tol:\n        \n        break\n\n    prev_energy = next_energy\npickle.dump([qngd_param_history, qngd_cost_history], open(\"qml_depth_1_8_15_params.pkl\", \"wb\"))\nprint()\nprint(\"Final value of the energy = {:.8f} Ha\".format(next_energy))\nprint(\"Number of iterations = \", n)\n\n", "link": "https://discuss.pennylane.ai//t/value-error-need-at-least-one-array-to-stack-while-using-qiskit-ansatz-with-qmls-qngoptimizer/2525/1"}, "1": {"author": "isaacdevlugt", "date": "1676063293152", "content": "Hey @omersajid9! Thanks for integrating PennyLane into your workflow !\nI\u2019m looking into a solution and will get back to you. Thank you for providing your code!1", "link": "https://discuss.pennylane.ai//t/value-error-need-at-least-one-array-to-stack-while-using-qiskit-ansatz-with-qmls-qngoptimizer/2525/2"}, "2": {"author": "isaacdevlugt", "date": "1677782892513", "content": "Hey @omersajid9 !\nI got a response from one of the PennyLane developers when I posed the following question:\nIf I want to convert a qiskit circuit to be usable in PennyLane, I can use qml.from_qiskit. But, what do I do if my qiskit circuit has parameters in it that I want to differentiate over after I convert to a PennyLane circuit?\nE.g., I have something like\ndef convert_circuit(x):\n    qc = qiskit.QuantumCircuit(1)\n    qc.ry(x, [0])\n    return qml.from_qiskit(qc)\n\nand would like to inject this into PennyLane, then differentiate w.r.t. x.\nTheir response:\nI could imagine that supporting this in all generality is very tough, because it basically requires that all used parts of Qiskit are compatible with the autodifferentiation interface.\nAt this time, it might be best to migrate your qiskit code into PennyLane. Is that feasible for you?1", "link": "https://discuss.pennylane.ai//t/value-error-need-at-least-one-array-to-stack-while-using-qiskit-ansatz-with-qmls-qngoptimizer/2525/3"}, "3": {"author": "Tom_Bromley", "date": "1677856598804", "content": "To add to @isaacdevlugt\u2019s response:\nYou can convert a Qiskit circuit to PennyLane and differentiate the circuit parameters if you use qiskit.circuit.Parameter to mark the variational parameters in your input Qiskit circuit.\nFor example, suppose you have:\nfrom qiskit.circuit import QuantumCircuit, Parameter\n\nphi = Parameter('phi')\n\nqc = QuantumCircuit(1)\nqc.ry(phi, [0])\n\nYou can convert this to PennyLane:\nimport pennylane as qml\n\nmy_circuit = qml.from_qiskit(qc)\ndev = qml.device(\"default.qubit\", wires=1)\n\n@qml.qnode(dev)\ndef circuit(psi):\n    my_circuit({phi: psi})\n    return qml.expval(qml.PauliZ(0))\n\nHere, we have mapped from the Qiskit circuit parameter phi to a new PennyLane parameter psi. This circuit can be differentiated:\n>>> psi = qml.numpy.array(0.5, requires_grad=True)\n>>> qml.grad(circuit)(psi)\ntensor(-0.47942554, requires_grad=True)\n1", "link": "https://discuss.pennylane.ai//t/value-error-need-at-least-one-array-to-stack-while-using-qiskit-ansatz-with-qmls-qngoptimizer/2525/4"}, "4": {"author": "omersajid9", "date": "1675892814602", "content": "Hi, I hope you are doing well. I am trying to run a natural gradient descent optimization on my circuit. My original work was in qiskit but I switched to pennylane for its qng optimizer. I noticed that using similar routine for making ansatz in pennylane turns out to be different than qiskit\u2019s ansatz so I am now making my ansatz in qiskit and converting it to qml\u2019s ansatz and running the optimization. The ansatz conversion runs smoothely but I am having errors when I put it in qngoptimizer\u2019s step_and_cost function. I was originally having an error where the parameters I was binding to my qiskit ansatz were tensor or autograd.arraybox so I tried converting them into a float to bind them to my qiskit ansatz. Now, I am getting an error of \u201cValue error: need at least one array to stack.\u201d Can you kindly help me with this error or guide me how I can use my qiskit ansatz with pennylane\u2019s qng optimizer?\nI have the following code:\nfrom qiskit import QuantumCircuit, QuantumRegister\nfrom qiskit.circuit import Parameter\nimport numpy as np\nfrom pennylane import numpy as nnn\nimport pickle\nimport pennylane as qml\nimport pennylane_qiskit\nfrom observable import returnStringObservable\n\ndev = qml.device(\"default.qubit\", wires=8)\n\nconnectivity = [(1, 2), (0, 6), (2, 3), (0, 7), (3, 4), (0, 1), (4, 5), (0, 2), (5, 6), (0, 3), (6, 7), (0, 4), (7, 1), (0, 5)]\nboundary = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 1)]\n\n\nconnectivity = list(map(tuple, connectivity))\nboundary = list(map(tuple, boundary))\n\nclass TwoQubitUnitary(QuantumCircuit):\n    def __init__(self,):\n        super().__init__()\n        work = QuantumRegister(2, name='q')\n        self.add_register(work)\n        self.u(Parameter('p0'), Parameter('p1'), Parameter('p2'), work[0])\n        self.u(Parameter('p3'), Parameter('p4'), Parameter('p5'), work[1])\n        self.cx(work[1], work[0])\n        self.rz(Parameter('p6'), work[0])\n        self.ry(Parameter('p7'), work[1])\n        self.cx(work[0], work[1])\n        self.ry(Parameter('p8'), work[1])\n        self.cx(work[1], work[0])\n        self.u(Parameter('p9'), Parameter('p10'), Parameter('p11'), work[0])\n        self.u(Parameter('p12'), Parameter('p13'), Parameter('p14'), work[1])\n        \nnum_qubits = 8\nboundary_start = 1\nconec_list = [list((i, j)) for (i, j) in connectivity]\n\nparamsList = list()\nenergyList = list()\n\ndef qiskitToQml(parameters):\n    num_gates = len(parameters)/15\n    gates = list()\n\n    for i in range(int(num_gates)):\n        print(i)\n        relevant_params = parameters[i*15:(i*15)+15]\n        gate = TwoQubitUnitary()\n        if (type(relevant_params) == nnn.tensor):\n            gate = gate.bind_parameters({gate.parameters.data[index]: val.unwrap() for (index, val) in enumerate(relevant_params)})\n        else:\n            gate = gate.bind_parameters({gate.parameters.data[index]: (val._value).unwrap() for (index, val) in enumerate(relevant_params)})\n        # gate = gate.bind_parameters({gate.parameters.data[index]: val for (index, val) in enumerate(relevant_params)})\n        gates.append(gate)\n        \n    ansatz = QuantumCircuit(num_qubits)\n\n    print(\"===start===\")\n    for (index, (i, j)) in enumerate(connectivity):\n        if index % 2 == 0:\n            ansatz.append(gates[1], [i, j])\n        else:\n            ansatz.append(gates[0], [i, j])\n    for (index, (i, j)) in enumerate(connectivity[::-1]):\n        if index % 2 == 0:\n            ansatz.append(gates[3], [i, j])\n        else:\n            ansatz.append(gates[2], [i, j])\n    print(\"===End====\")\n    return qml.from_qiskit(ansatz.decompose())\n\nop_list = [(qml.pauli.utils.string_to_pauli_word(singleEntry)) for singleEntry in returnStringObservable(boundary_start, num_qubits)]\nH = qml.Hamiltonian([-1]*len(op_list), op_list)\n\n@qml.qnode(dev)\ndef cost_fn(params):\n    circ = qiskitToQml(params)\n    circ()\n    return qml.expval(H)\n\n\nmax_iterations = 1000\nstep_size = .01\nconv_tol = 5e-07\nopt = qml.QNGOptimizer(stepsize=step_size, approx='diag')\n\nparams = np.random.normal(-0.3, .1, 15*4)\n\n\nqngd_param_history = [params]\nqngd_cost_history = []\n\nparams, prev_energy = opt.step_and_cost(cost_fn, nnn.array(params, requires_grad=True))\nprint(prev_energy)\n\nfor n in range(max_iterations):\n\n    params, next_energy = opt.step_and_cost(cost_fn, nnn.array(params, requires_grad=True))\n    qngd_param_history.append(params)\n    qngd_cost_history.append(next_energy)\n\n    conv = np.abs(next_energy - prev_energy)\n\n    print(\n            \"Iteration = {:},  Energy = {:.8f} Ha,  Convergence parameter = {\"\n            \":.8f} Ha\".format(n, next_energy, conv)\n        )\n\n    if conv <= conv_tol:\n        \n        break\n\n    prev_energy = next_energy\npickle.dump([qngd_param_history, qngd_cost_history], open(\"qml_depth_1_8_15_params.pkl\", \"wb\"))\nprint()\nprint(\"Final value of the energy = {:.8f} Ha\".format(next_energy))\nprint(\"Number of iterations = \", n)\n\n", "link": "https://discuss.pennylane.ai//t/value-error-need-at-least-one-array-to-stack-while-using-qiskit-ansatz-with-qmls-qngoptimizer/2525/5"}}