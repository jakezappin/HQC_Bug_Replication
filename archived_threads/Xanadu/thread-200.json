{"0": {"author": "Snowman_Liu", "date": "1686685651100", "content": "Hello! I am wondering how to transpile (or compile) a circuit with a specific hardware setting (or specific coupling maps and basic gate sets). Suppose I have a circuit like this:\ndef circuit():\n    qml.CNOT(wires=[0, 1])\n    qml.PauliY(wires=0)\n    qml.CNOT(wires=[2, 3])\n    qml.Hadamard(wires=3)\n    qml.CNOT(wires=[1, 2])\n    qml.PauliZ(wires=0)\n    qml.PauliX(wires=1)\n    qml.Hadamard(wires=2)\n    qml.CNOT(wires=[3,1])\n    qml.PauliZ(wires=2)\n    qml.CNOT(wires=[0, 3])\n    return qml.probs(wires=[0, 1, 2, 3])\n\ndev = qml.device('default.qubit', wires=4)\nqnode = qml.QNode(circuit, dev)\nprint(qml.draw(qnode)())\n\nwhich is:\n0: \u2500\u256d\u25cf\u2500\u2500Y\u2500\u2500Z\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u2524 \u256dProbs\n1: \u2500\u2570X\u2500\u256d\u25cf\u2500\u2500X\u2500\u256dX\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2524 \u251cProbs\n2: \u2500\u256d\u25cf\u2500\u2570X\u2500\u2500H\u2500\u2502\u2500\u2500\u2500Z\u2500\u2502\u2500\u2500\u2524 \u251cProbs\n3: \u2500\u2570X\u2500\u2500H\u2500\u2500\u2500\u2500\u2570\u25cf\u2500\u2500\u2500\u2500\u2570X\u2500\u2524 \u2570Probs\nNow, suppose I want to have it executed on the ibmq_lima (or fake ibmq_lima) device, what can I do to acquire get the corresponding transpile circuit for my designed circuit circuit()? I do not want to execute on the real hardware but only would like to get the transpiled to-be-executed circuit and output some data (like physical depth, gate counts, etc.) from it. Does Pennylane have another different compiling strategy for this compared with qiskit, and how can I implement it?\nThere is another approach in that I can specify the coupling map and the basis set of the specific hardware and implement the qml.compile or qml.transforms.transpile. However, I use the code below to transpile my circuit with specific basis_set={[\"CNOT\", \"X\", \"SX\", \"RZ\"]} (which is exactly\nthe gate set of ibmq_lima):\ncompiled_circuit = qml.compile(basis_set=[\"CNOT\", \"X\", \"SX\", \"RZ\"])(circuit)\ncompiled_qnode = qml.QNode(compiled_circuit, dev)\nprint(qml.draw(compiled_qnode)())\n\nand I get:\n0: \u2500\u256d\u25cf\u2500\u2500RZ(1.57)\u2500\u2500RY(3.14)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u2500RZ(4.71)\u2500\u2524 \u256dProbs\n1: \u2500\u2570X\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500RZ(1.57)\u2500\u2500RX(3.14)\u2500\u2500RZ(1.57)\u2500\u256dX\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251cProbs\n2: \u2500\u256d\u25cf\u2500\u2570X\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500RZ(1.57)\u2500\u2500RX(1.57)\u2500\u2500RZ(4.71)\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251cProbs\n3: \u2500\u2570X\u2500\u2500RZ(1.57)\u2500\u2500RX(1.57)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570\u25cf\u2500\u2500RZ(1.57)\u2500\u2570X\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2570Probs\nWe can see that there is still RX gate inside. This will become even worse when I implement custom unitary gates in the circuit. I cannot get the circuit with my indicated basis_set.\nThanks a lot and looking forward to your answers!\nThis is my environment:\nName: PennyLane\nVersion: 0.30.0\nSummary: PennyLane is a Python quantum machine learning library by Xanadu Inc.\nHome-page: GitHub - PennyLaneAI/pennylane: PennyLane is a cross-platform Python library for differentiable programming of quantum computers. Train a quantum computer the same way as a neural network.\n*Author: *\n*Author-email: *\nLicense: Apache License 2.0\nLocation: e:\\anaconda3\\lib\\site-packages\nRequires: autograd, requests, autoray, semantic-version, scipy, rustworkx, appdirs, numpy, networkx, toml, pennylane-lightning, cachetools\nRequired-by: PennyLane-qiskit, PennyLane-Lightning\nPlatform info:           Windows-10-10.0.19042-SP0\nPython version:          3.9.12\nNumpy version:           1.23.5\nScipy version:           1.9.3\nInstalled devices:\n- qiskit.aer (PennyLane-qiskit-0.30.1)\n- qiskit.basicaer (PennyLane-qiskit-0.30.1)\n- qiskit.ibmq (PennyLane-qiskit-0.30.1)\n- qiskit.ibmq.circuit_runner (PennyLane-qiskit-0.30.1)\n- qiskit.ibmq.sampler (PennyLane-qiskit-0.30.1)\n- default.gaussian (PennyLane-0.30.0)\n- default.mixed (PennyLane-0.30.0)\n- default.qubit (PennyLane-0.30.0)\n- default.qubit.autograd (PennyLane-0.30.0)\n- default.qubit.jax (PennyLane-0.30.0)\n- default.qubit.tf (PennyLane-0.30.0)\n- default.qubit.torch (PennyLane-0.30.0)\n- default.qutrit (PennyLane-0.30.0)\n- null.qubit (PennyLane-0.30.0)\n- lightning.qubit (PennyLane-Lightning-0.30.0)", "link": "https://discuss.pennylane.ai//t/how-to-transpile-or-compile-a-circuit-with-a-specific-hardware-setting/3047/1"}, "1": {"author": "isaacdevlugt", "date": "1686755430404", "content": "Hey @Snowman_Liu! Welcome to the forum !\nqml.compile has some rough edges related to the fact that QNodes are bound to a device, not the compilation \u201cspace\u201d in which you define via a basis_set. So, what can happen is you can move out of the basis_set when compile goes through its steps.\nOn a more detailed level, how PennyLane decomposes operations is very unidirectional \u2014 we have a particular gateset that we consider \u201cuniversal\u201d. E.g., for PauiiY:\n>>> qml.PauliY(wires=0).decomposition()\n[PhaseShift(1.5707963267948966, wires=[0]),\n RY(3.141592653589793, wires=[0]),\n PhaseShift(1.5707963267948966, wires=[0])]\n\nIn other words, PennyLane has no way to turn PauliY into something in [\"CNOT\", \"X\", \"SX\", \"RZ\"]. It\u2019s a shortcoming that we\u2019re aware of \u2014 we need more versatile decomposition strategies!\nFor the gates in your circuit that are causing problems, you can see if creating a custom decomposition will work by using qml.transforms.create_decomp_expand_fn: qml.transforms.create_decomp_expand_fn \u2014 PennyLane 0.30.0 documentation 2\nThis should tell the device how to decompose things in your desired way. Let me know if this works!1", "link": "https://discuss.pennylane.ai//t/how-to-transpile-or-compile-a-circuit-with-a-specific-hardware-setting/3047/2"}, "2": {"author": "Snowman_Liu", "date": "1686858680752", "content": "Hey @isaacdevlugt ! Thank you so much, and yes it works when I pre-define the transpire strategy by myself. Thanks again for your help!1", "link": "https://discuss.pennylane.ai//t/how-to-transpile-or-compile-a-circuit-with-a-specific-hardware-setting/3047/3"}, "3": {"author": "isaacdevlugt", "date": "1686860739868", "content": "Awesome! Glad that works for you ", "link": "https://discuss.pennylane.ai//t/how-to-transpile-or-compile-a-circuit-with-a-specific-hardware-setting/3047/4"}, "4": {"author": "Snowman_Liu", "date": "1686685651100", "content": "Hello! I am wondering how to transpile (or compile) a circuit with a specific hardware setting (or specific coupling maps and basic gate sets). Suppose I have a circuit like this:\ndef circuit():\n    qml.CNOT(wires=[0, 1])\n    qml.PauliY(wires=0)\n    qml.CNOT(wires=[2, 3])\n    qml.Hadamard(wires=3)\n    qml.CNOT(wires=[1, 2])\n    qml.PauliZ(wires=0)\n    qml.PauliX(wires=1)\n    qml.Hadamard(wires=2)\n    qml.CNOT(wires=[3,1])\n    qml.PauliZ(wires=2)\n    qml.CNOT(wires=[0, 3])\n    return qml.probs(wires=[0, 1, 2, 3])\n\ndev = qml.device('default.qubit', wires=4)\nqnode = qml.QNode(circuit, dev)\nprint(qml.draw(qnode)())\n\nwhich is:\n0: \u2500\u256d\u25cf\u2500\u2500Y\u2500\u2500Z\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u2524 \u256dProbs\n1: \u2500\u2570X\u2500\u256d\u25cf\u2500\u2500X\u2500\u256dX\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2524 \u251cProbs\n2: \u2500\u256d\u25cf\u2500\u2570X\u2500\u2500H\u2500\u2502\u2500\u2500\u2500Z\u2500\u2502\u2500\u2500\u2524 \u251cProbs\n3: \u2500\u2570X\u2500\u2500H\u2500\u2500\u2500\u2500\u2570\u25cf\u2500\u2500\u2500\u2500\u2570X\u2500\u2524 \u2570Probs\nNow, suppose I want to have it executed on the ibmq_lima (or fake ibmq_lima) device, what can I do to acquire get the corresponding transpile circuit for my designed circuit circuit()? I do not want to execute on the real hardware but only would like to get the transpiled to-be-executed circuit and output some data (like physical depth, gate counts, etc.) from it. Does Pennylane have another different compiling strategy for this compared with qiskit, and how can I implement it?\nThere is another approach in that I can specify the coupling map and the basis set of the specific hardware and implement the qml.compile or qml.transforms.transpile. However, I use the code below to transpile my circuit with specific basis_set={[\"CNOT\", \"X\", \"SX\", \"RZ\"]} (which is exactly\nthe gate set of ibmq_lima):\ncompiled_circuit = qml.compile(basis_set=[\"CNOT\", \"X\", \"SX\", \"RZ\"])(circuit)\ncompiled_qnode = qml.QNode(compiled_circuit, dev)\nprint(qml.draw(compiled_qnode)())\n\nand I get:\n0: \u2500\u256d\u25cf\u2500\u2500RZ(1.57)\u2500\u2500RY(3.14)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256d\u25cf\u2500\u2500RZ(4.71)\u2500\u2524 \u256dProbs\n1: \u2500\u2570X\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500RZ(1.57)\u2500\u2500RX(3.14)\u2500\u2500RZ(1.57)\u2500\u256dX\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251cProbs\n2: \u2500\u256d\u25cf\u2500\u2570X\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500RZ(1.57)\u2500\u2500RX(1.57)\u2500\u2500RZ(4.71)\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251cProbs\n3: \u2500\u2570X\u2500\u2500RZ(1.57)\u2500\u2500RX(1.57)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570\u25cf\u2500\u2500RZ(1.57)\u2500\u2570X\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2570Probs\nWe can see that there is still RX gate inside. This will become even worse when I implement custom unitary gates in the circuit. I cannot get the circuit with my indicated basis_set.\nThanks a lot and looking forward to your answers!\nThis is my environment:\nName: PennyLane\nVersion: 0.30.0\nSummary: PennyLane is a Python quantum machine learning library by Xanadu Inc.\nHome-page: GitHub - PennyLaneAI/pennylane: PennyLane is a cross-platform Python library for differentiable programming of quantum computers. Train a quantum computer the same way as a neural network.\n*Author: *\n*Author-email: *\nLicense: Apache License 2.0\nLocation: e:\\anaconda3\\lib\\site-packages\nRequires: autograd, requests, autoray, semantic-version, scipy, rustworkx, appdirs, numpy, networkx, toml, pennylane-lightning, cachetools\nRequired-by: PennyLane-qiskit, PennyLane-Lightning\nPlatform info:           Windows-10-10.0.19042-SP0\nPython version:          3.9.12\nNumpy version:           1.23.5\nScipy version:           1.9.3\nInstalled devices:\n- qiskit.aer (PennyLane-qiskit-0.30.1)\n- qiskit.basicaer (PennyLane-qiskit-0.30.1)\n- qiskit.ibmq (PennyLane-qiskit-0.30.1)\n- qiskit.ibmq.circuit_runner (PennyLane-qiskit-0.30.1)\n- qiskit.ibmq.sampler (PennyLane-qiskit-0.30.1)\n- default.gaussian (PennyLane-0.30.0)\n- default.mixed (PennyLane-0.30.0)\n- default.qubit (PennyLane-0.30.0)\n- default.qubit.autograd (PennyLane-0.30.0)\n- default.qubit.jax (PennyLane-0.30.0)\n- default.qubit.tf (PennyLane-0.30.0)\n- default.qubit.torch (PennyLane-0.30.0)\n- default.qutrit (PennyLane-0.30.0)\n- null.qubit (PennyLane-0.30.0)\n- lightning.qubit (PennyLane-Lightning-0.30.0)", "link": "https://discuss.pennylane.ai//t/how-to-transpile-or-compile-a-circuit-with-a-specific-hardware-setting/3047/5"}}