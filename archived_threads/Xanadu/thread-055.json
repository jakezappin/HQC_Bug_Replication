{"0": {"author": "Daniil-Kuhmistrov", "date": "1682535317106", "content": "I\u2019m trying to figure out how qml.MPS (qml.MPS \u2014 PennyLane 0.29.1 documentation 1) works. The issue is there is no way to do arbitrary offset between blocks, it\u2019s automatically offsetting block by n_qubits_per_block/2. For example, having a block involving 8 wires, the next one will be 4 qubits lower. And I\u2019m in situation when, for example, i want next block be 6 qubits lower. I couldn\u2019t find any parameters that is responsible for offset. However, It seems the authors of this article(https://arxiv.org/pdf/2209.11058.pdf 1) somehow managed to do that. Is it possible and if it is, how to control the offset.\nThanks in advance.", "link": "https://discuss.pennylane.ai//t/qml-mps-offset-control/2890/1"}, "1": {"author": "isaacdevlugt", "date": "1682541827992", "content": "Hey @Daniil-Kuhmistrov! I responded to your original Github issue that you made. I\u2019ll close that in favour of discussing your problem here . Here was my response:\nI think I\u2019m a little confused with how you want to use qml.MPS. Are you able to draw a small circuit that outlines how you would like qml.MPS to behave?", "link": "https://discuss.pennylane.ai//t/qml-mps-offset-control/2890/2"}, "2": {"author": "Daniil-Kuhmistrov", "date": "1682544435852", "content": "\nSure, @isaacdevlugt , for instance, having a block with n_wires=6, i want the next block to be 4 wires lower instead of 3 that is automatically constructed.", "link": "https://discuss.pennylane.ai//t/qml-mps-offset-control/2890/3"}, "3": {"author": "isaacdevlugt", "date": "1682606368016", "content": "I see! Okay, here\u2019s an example:\nimport pennylane as qml\nimport numpy as np\n\n\ndef block(weights, wires):\n    qml.RY(weights[0], wires=wires[0])\n    qml.RX(weights[1], wires=wires[1])\n    qml.RZ(weights[2], wires=wires[2])\n    qml.RY(weights[3], wires=wires[3])\n\n\nn_wires = 6\nn_block_wires = 4\nn_params_block = 4\nn_blocks = qml.MPS.get_n_blocks(range(n_wires), n_block_wires)\nprint(n_blocks)\ntemplate_weights = [[0.1] * n_params_block] * n_blocks\n\ndev = qml.device(\"default.qubit\", wires=range(n_wires))\n\n\n@qml.qnode(dev)\ndef circuit(template_weights):\n    qml.MPS(range(n_wires), n_block_wires, block, n_params_block, template_weights)\n    return qml.expval(qml.PauliZ(wires=n_wires - 1))\n\nprint(qml.draw(circuit,expansion_strategy='device')(template_weights))\n\n\n'''\n0: \u2500\u2500RY(0.10)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \n1: \u2500\u2500RX(0.10)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \n2: \u2500\u2500RZ(0.10)\u2500\u2500RY(0.10)\u2500\u2524     \n3: \u2500\u2500RY(0.10)\u2500\u2500RX(0.10)\u2500\u2524     \n4: \u2500\u2500RZ(0.10)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \n5: \u2500\u2500RY(0.10)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  <Z>\n'''\n\nYou\u2019ll notice that the output is printed seemingly \u201cincorrectly\u201d but is actually what you\u2019re after, i.e., I can rewrite it like this:\n'''\n0: \u2500\u2500RY(0.10)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \n1: \u2500\u2500RX(0.10)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \n2: \u2500\u2500RZ(0.10)\u2500\u2500RY(0.10)\u2500\u2524     \n3: \u2500\u2500RY(0.10)\u2500\u2500RX(0.10)\u2500\u2524     \n4: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500RZ(0.10)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \n5: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500RY(0.10)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  <Z>\n'''\n\nThe key here is what the argumentsn_wires and  n_block_wires mean. If I have a circuit with n_wires and I want 2 blocks of 4 wires (n_block_wires) in the circuit, logically, two of their wires will be shared. Hopefully you can adapt this to fit your needs!", "link": "https://discuss.pennylane.ai//t/qml-mps-offset-control/2890/4"}, "4": {"author": "Diego", "date": "1682607673285", "content": "Hi @Daniil-Kuhmistrov ,\nVarying the offset is not explicitly supported. But for now you can accomplish this in a messy way by doing the following:\nimport pennylane as qml\n\ndef block(weights, wires):\n    qml.MultiControlledX(wires=[wires[i] for i in range(6)])\n\nn_wires = 16\nn_block_wires = 8\nn_params_block = 2\nn_blocks = qml.MPS.get_n_blocks(range(n_wires),n_block_wires)\ntemplate_weights = [[0.1,-0.3]]*n_blocks\n\ndev= qml.device('default.qubit',wires=n_wires)\n@qml.qnode(dev)\ndef circuit(template_weights):\n    qml.MPS(range(n_wires),n_block_wires,block, n_params_block, template_weights)\n    return qml.state()\n\nprint(qml.draw(circuit,expansion_strategy='device')(template_weights))\n\nThis code should accomplish your goal of having six-wire blocks that only connect via the bottom two blocks. The output is:\n 0: \u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  State\n 1: \u2500\u251c\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  State\n 2: \u2500\u251c\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  State\n 3: \u2500\u251c\u25cf\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  State\n 4: \u2500\u251c\u25cf\u2500\u256d\u25cf\u2500\u2500\u2500\u2500\u2524  State\n 5: \u2500\u2570X\u2500\u251c\u25cf\u2500\u2500\u2500\u2500\u2524  State\n 6: \u2500\u2500\u2500\u2500\u251c\u25cf\u2500\u2500\u2500\u2500\u2524  State\n 7: \u2500\u2500\u2500\u2500\u251c\u25cf\u2500\u2500\u2500\u2500\u2524  State\n 8: \u2500\u2500\u2500\u2500\u251c\u25cf\u2500\u256d\u25cf\u2500\u2524  State\n 9: \u2500\u2500\u2500\u2500\u2570X\u2500\u251c\u25cf\u2500\u2524  State\n10: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u251c\u25cf\u2500\u2524  State\n11: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u251c\u25cf\u2500\u2524  State\n12: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u251c\u25cf\u2500\u2524  State\n13: \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2570X\u2500\u2524  State\n\nPlaying around with the number of wires in the block and the number of wires given to the MPS template should allow you to make some offset changes.\nI\u2019ll take another look to see if I can come up with a different solution.2", "link": "https://discuss.pennylane.ai//t/qml-mps-offset-control/2890/5"}, "5": {"author": "Daniil-Kuhmistrov", "date": "1682535317106", "content": "I\u2019m trying to figure out how qml.MPS (qml.MPS \u2014 PennyLane 0.29.1 documentation 1) works. The issue is there is no way to do arbitrary offset between blocks, it\u2019s automatically offsetting block by n_qubits_per_block/2. For example, having a block involving 8 wires, the next one will be 4 qubits lower. And I\u2019m in situation when, for example, i want next block be 6 qubits lower. I couldn\u2019t find any parameters that is responsible for offset. However, It seems the authors of this article(https://arxiv.org/pdf/2209.11058.pdf 1) somehow managed to do that. Is it possible and if it is, how to control the offset.\nThanks in advance.", "link": "https://discuss.pennylane.ai//t/qml-mps-offset-control/2890/6"}}