{"0": {"author": "Onur_Danaci", "date": "1688058655032", "content": "Hi all,\nI am trying to create custom gates/channel elements by fusing single qubit rotations (e.g, class of pennylane.ops.qubit.parametric_ops such as qml.RX) and two qubit rotations (e.g, class of pennylane.ops.qubit.qchem_ops such as SingleExcitation) with noise channels (e.g, one and two qubit depolarizing channels). I tried using Pennylane tutorials for custom gates[*], but I believe they are outdated and don\u2019t cover my need.\nFirst, I tried the template class as prescribed in [*] by:\n@qml.template\ndef RX_0p001(phi,wires):\n    qml.RX(phi, wires)\n    qml.DepolarizingChannel(p = 0.001, wires = wires)\n\nBut it threw an error saying \u2018pennylane\u2019 has no attribute \u2018template\u2019.\nThen I tried, also based on [*], the following:\nclass RX_0p001(Operation):\n    num_params = 1\n    num_wires= AnyWires\n    par_domain = \"R\"\n    \n    grad_method = \"A\"\n    grad_recipe= None\n    \n    def expand(self, theta, wires):\n        with qml.tape.QuantumTape() as tape:\n            qml.RX(theta, wires = wires)\n            qml.DepolarizingChannel(p = 0.001, wires = wires)\n            \n        return tape\n\nInitializing it using\n\nRX_0p001(np.array(2),wires = 0)\n\nyields the output\n\nRX_0p001(tensor(2, requires_grad=True), wires=[0])\n\nBut when I try to do anything with it I get an error such as:\ndev3 = qml.device('default.mixed', wires=1)\n\n\n@qml.qnode(dev3)\ndef depolarizingless_circuit():\n    # qml.Hadamard(wires=0)\n    qml.RX(np.array(0.7),wires =0)\n    return qml.expval(qml.PauliZ(0))\n           \n@qml.qnode(dev3)\ndef depolarizing0p001_circuit():\n    # qml.Hadamard(wires=0)\n    RX_0p001(np.array(0.7),wires =0)\n    return qml.expval(qml.PauliZ(0))\n\nIt yields the error:\nTypeError: RX_0p001.expand() missing 2 required positional arguments: 'theta' and 'wires'\nEdit_1:\nI also tried the following class:\nclass  RX_0p001(Operation):\n    num_wires = AnyWires  \n\n    def __init__(self, theta, wires, do_queue=True, id=None):\n        all_wires = qml.wires.Wires(wires)\n        super().__init__(theta, wires=all_wires, do_queue=do_queue, id=id)\n\n    @staticmethod\n    def compute_decomposition(theta, wires):\n        decomp = []\n        \n        decomp.append(qml.RX(theta, wires))\n        decomp.append(qml.DepolarizingChannel(p = 0.001, wires = wires))\n\n        return decomp\n\nIt again gives me the output when I instantiate it with angle and wire:\n\nRX_0p001(tensor(2, requires_grad=True), wires=[0])\n\nBut, feeding it to the function\n\ndepolarizing0p001_circuit()\n\nyields the following error:\n\nAttributeError                            Traceback (most recent call last)\nCell In[157], line 1\n----> 1 depolarizing0p001_circuit()\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/qnode.py:619, in QNode.call(self, *args, **kwargs)\n612 using_custom_cache = (\n613     hasattr(cache, \u201cgetitem\u201d)\n614     and hasattr(cache, \u201csetitem\u201d)\n615     and hasattr(cache, \u201cdelitem\u201d)\n616 )\n617 self._tape_cached = using_custom_cache and self.tape.hash in cache\n \u2192 619 res = qml.execute(\n620     [self.tape],\n621     device=self.device,\n622     gradient_fn=self.gradient_fn,\n623     interface=self.interface,\n624     gradient_kwargs=self.gradient_kwargs,\n625     override_shots=override_shots,\n626     **self.execute_kwargs,\n627 )\n629 if autograd.isinstance(res, (tuple, list)) and len(res) == 1:\n630     # If a device batch transform was applied, we need to \u2018unpack\u2019\n631     # the returned tuple/list to a float.\n(\u2026)\n638     # TODO: find a more explicit way of determining that a batch transform\n639     # was applied.\n641     res = res[0]\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/interfaces/execution.py:344, in execute(tapes, device, gradient_fn, interface, mode, gradient_kwargs, cache, cachesize, max_diff, override_shots, expand_fn, max_expansion, device_batch_transform)\n340     return batch_fn(res)\n342 if gradient_fn == \u201cbackprop\u201d or interface is None:\n343     return batch_fn(\n \u2192 344         qml.interfaces.cache_execute(\n345             batch_execute, cache, return_tuple=False, expand_fn=expand_fn\n346         )(tapes)\n347     )\n349 # the default execution function is batch_execute\n350 execute_fn = qml.interfaces.cache_execute(batch_execute, cache, expand_fn=expand_fn)\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/interfaces/execution.py:172, in cache_execute..wrapper(tapes, **kwargs)\n168         return (res, ) if return_tuple else res\n170 else:\n171     # execute all unique tapes that do not exist in the cache\n \u2192 172     res = fn(execution_tapes.values(), **kwargs)\n174 final_res = \n176 for i, tape in enumerate(tapes):\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/interfaces/execution.py:96, in cache_execute..fn(tapes, **kwargs)\n95 def fn(tapes, **kwargs):  # pylint: disable=function-redefined\n\u2014> 96     tapes = [expand_fn(tape) for tape in tapes]\n97     return original_fn(tapes, **kwargs)\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/interfaces/execution.py:96, in (.0)\n95 def fn(tapes, **kwargs):  # pylint: disable=function-redefined\n\u2014> 96     tapes = [expand_fn(tape) for tape in tapes]\n97     return original_fn(tapes, **kwargs)\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/interfaces/execution.py:325, in execute..(tape)\n322 batch_execute = set_shots(device, override_shots)(device.batch_execute)\n324 if expand_fn == \u201cdevice\u201d:\n \u2192 325     expand_fn = lambda tape: device.expand_fn(tape, max_expansion=max_expansion)\n327 if gradient_fn is None:\n328     # don\u2019t unwrap if it\u2019s an interface device\n329     if \u201cpassthru_interface\u201d in device.capabilities():\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/_device.py:680, in Device.expand_fn(self, circuit, max_expansion)\n677 if self.custom_expand_fn is not None:\n678     return self.custom_expand_fn(circuit, max_expansion=max_expansion)\n \u2192 680 return self.default_expand_fn(circuit, max_expansion=max_expansion)\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/_device.py:655, in Device.default_expand_fn(self, circuit, max_expansion)\n652 ops_not_supported = not all(self.stopping_condition(op) for op in circuit.operations)\n654 if ops_not_supported or obs_on_same_wire:\n \u2192 655     circuit = circuit.expand(depth=max_expansion, stop_at=self.stopping_condition)\n657 return circuit\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/tape/tape.py:610, in QuantumTape.expand(self, depth, stop_at, expand_measurements)\n562 def expand(self, depth=1, stop_at=None, expand_measurements=False):\n563     \u201c\u201d\u201cExpand all operations in the processed queue to a specific depth.\n564\n565     Args:\n(\u2026)\n608     RY(0.2, wires=[\u2018a\u2019])]\n609     \u201c\u201d\u201d\n \u2192 610     new_tape = expand_tape(\n611         self, depth=depth, stop_at=stop_at, expand_measurements=expand_measurements\n612     )\n613     new_tape._update()\n614     return new_tape\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/tape/tape.py:184, in expand_tape(tape, depth, stop_at, expand_measurements)\n181 if isinstance(obj, (qml.operation.Operator, qml.measurements.MeasurementProcess)):\n182     # Object is an operation; query it for its expansion\n183     try:\n \u2192 184         obj = obj.expand()\n185     except DecompositionUndefinedError:\n186         # Object does not define an expansion; treat this as\n187         # a stopping condition.\n188         getattr(new_tape, queue).append(obj)\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/operation.py:1185, in Operator.expand(self)\n1182 tape = qml.tape.QuantumTape(do_queue=False)\n1184 with tape:\n \u2192 1185     self.decomposition()\n1187 if not self.data:\n1188     # original operation has no trainable parameters\n1189     tape.trainable_params = {}\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/operation.py:1026, in Operator.decomposition(self)\n1014 def decomposition(self):\n1015     r\"\"\u201cRepresentation of the operator as a product of other operators.\n1016\n1017     \u2026 math:: O = O_1 O_2 \\dots O_n\n(\u2026)\n1024         list[Operator]: decomposition of the operator\n1025     \u201c\u201d\u201d\n \u2192 1026     return self.compute_decomposition(\n1027         *self.parameters, wires=self.wires, **self.hyperparameters\n1028     )\nCell In[154], line 13, in RX_0p001.compute_decomposition(theta, wires)\n10 decomp = \n12 decomp.append(qml.RX(theta, wires))\n\u2014> 13 decomp.append(qml.DepolarizingChannel(p = 0.001, wires = wires))\n15 return decomp\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/ops/channel.py:300, in DepolarizingChannel.init(self, p, wires, do_queue, id)\n299 def init(self, p, wires, do_queue=True, id=None):\n \u2192 300     super().init(p, wires=wires, do_queue=do_queue, id=id)\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/operation.py:1452, in Operation.init(self, wires, do_queue, id, *params)\n1449 def init(self, *params, wires=None, do_queue=True, id=None):\n1451     self._inverse = False\n \u2192 1452     super().init(*params, wires=wires, do_queue=do_queue, id=id)\n1454     # check the grad_recipe validity\n1455     if self.grad_recipe is None:\n1456         # Make sure grad_recipe is an iterable of correct length instead of None\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/operation.py:883, in Operator.init(self, wires, do_queue, id, *params)\n877 if self.num_wires not in {AllWires, AnyWires} and len(self._wires) != self.num_wires:\n878     raise ValueError(\n879         f\"{self.name}: wrong number of wires. \"\n880         f\"{len(self._wires)} wires given, {self.num_wires} expected.\"\n881     )\n \u2192 883 self._check_batching(params)\n885 self.data = list(params)  #: list[Any]: parameters of the operator\n887 if do_queue:\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/operation.py:903, in Operator._check_batching(self, params)\n901 self._batch_size = None\n902 try:\n \u2192 903     ndims = tuple(qml.math.ndim(p) for p in params)\n904 except ValueError as e:\n905     # TODO:[dwierichs] When using tf.function with an input_signature that contains\n906     # an unknown-shaped input, ndim() will not be able to determine the number of\n(\u2026)\n911     # investigated. For now, the batch_size is left to be None when instantiating\n912     # an operation with abstract parameters that make qml.math.ndim fail.\n913     if any(qml.math.is_abstract(p) for p in params):\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/operation.py:903, in (.0)\n901 self._batch_size = None\n902 try:\n \u2192 903     ndims = tuple(qml.math.ndim(p) for p in params)\n904 except ValueError as e:\n905     # TODO:[dwierichs] When using tf.function with an input_signature that contains\n906     # an unknown-shaped input, ndim() will not be able to determine the number of\n(\u2026)\n911     # investigated. For now, the batch_size is left to be None when instantiating\n912     # an operation with abstract parameters that make qml.math.ndim fail.\n913     if any(qml.math.is_abstract(p) for p in params):\nFile ~/JaxQuantumML/lib/python3.10/site-packages/autoray/autoray.py:79, in do(fn, like, *args, **kwargs)\n30 \u201c\u201d\u201cDo function named fn on (*args, **kwargs), peforming single\n31 dispatch to retrieve fn based on whichever library defines the class of\n32 the args[0], or the like keyword argument if specified.\n(\u2026)\n76     <tf.Tensor: id=91, shape=(3, 3), dtype=float32>\n77 \u201c\u201d\u201d\n78 backend = choose_backend(fn, *args, like=like, **kwargs)\n\u2014> 79 return get_lib_fn(backend, fn)(*args, **kwargs)\nFile ~/JaxQuantumML/lib/python3.10/site-packages/autoray/autoray.py:886, in ndim(x)\n884 @compose\n885 def ndim(x):\n \u2192 886     return x.ndim\nAttributeError: \u2018float\u2019 object has no attribute \u2018ndim\u2019\nMy goal is to be able to compute gradients out of each of these fused block elements so that I can add them into circuits within an operator pool. Using a noiseless operator pool I\u2019m benchmarking Adapt VQE, and trying to use that noisy operator pool for Adapt VQE under noise.\nI would appreciate your help in somehow creating these custom gates/channels.\nBest,\nOnur\n[*]How to add custom gates and templates to PennyLane | PennyLane Blog", "link": "https://discuss.pennylane.ai//t/need-to-fuse-one-and-two-qubit-rotation-gates-with-noise-channels/3118/1"}, "1": {"author": "isaacdevlugt", "date": "1688072357052", "content": "Hey @Onur_Danaci! Welcome to the forum !\nIt looks like you don\u2019t need to define expand here; this works for me:\nimport pennylane as qml\nfrom pennylane import numpy as np\n\nclass RX_0p001(qml.operation.Operation):\n    num_params = 1\n    num_wires = qml.operation.AnyWires\n    par_domain = \"R\"\n\n    grad_method = \"A\"\n    grad_recipe = None\n\n    @staticmethod\n    def compute_decomposition(theta, wires):\n        decomp = []\n        \n        decomp.append(qml.RX(theta, wires))\n        decomp.append(qml.DepolarizingChannel(p = 0.001, wires = wires))\n\n        return decomp\n\ndev3 = qml.device(\"default.mixed\", wires=1)\n\n\n@qml.qnode(dev3)\ndef depolarizingless_circuit():\n    qml.RX(np.array(0.7), wires=0)\n    return qml.expval(qml.PauliZ(0))\n\n\n@qml.qnode(dev3)\ndef depolarizing0p001_circuit():\n    RX_0p001(np.array(0.7), wires=0)\n    return qml.expval(qml.PauliZ(0))\n\n>>> depolarizingless_circuit()\ntensor(0.76484219, requires_grad=True)\n\n>>> depolarizing0p001_circuit()\ntensor(0.7638224, requires_grad=True)\n\nIs your PennyLane version out of date? We\u2019re on v0.31 currently , which is what I\u2019m using. Let me know if that helps!", "link": "https://discuss.pennylane.ai//t/need-to-fuse-one-and-two-qubit-rotation-gates-with-noise-channels/3118/2"}, "2": {"author": "Onur_Danaci", "date": "1688058655032", "content": "Hi all,\nI am trying to create custom gates/channel elements by fusing single qubit rotations (e.g, class of pennylane.ops.qubit.parametric_ops such as qml.RX) and two qubit rotations (e.g, class of pennylane.ops.qubit.qchem_ops such as SingleExcitation) with noise channels (e.g, one and two qubit depolarizing channels). I tried using Pennylane tutorials for custom gates[*], but I believe they are outdated and don\u2019t cover my need.\nFirst, I tried the template class as prescribed in [*] by:\n@qml.template\ndef RX_0p001(phi,wires):\n    qml.RX(phi, wires)\n    qml.DepolarizingChannel(p = 0.001, wires = wires)\n\nBut it threw an error saying \u2018pennylane\u2019 has no attribute \u2018template\u2019.\nThen I tried, also based on [*], the following:\nclass RX_0p001(Operation):\n    num_params = 1\n    num_wires= AnyWires\n    par_domain = \"R\"\n    \n    grad_method = \"A\"\n    grad_recipe= None\n    \n    def expand(self, theta, wires):\n        with qml.tape.QuantumTape() as tape:\n            qml.RX(theta, wires = wires)\n            qml.DepolarizingChannel(p = 0.001, wires = wires)\n            \n        return tape\n\nInitializing it using\n\nRX_0p001(np.array(2),wires = 0)\n\nyields the output\n\nRX_0p001(tensor(2, requires_grad=True), wires=[0])\n\nBut when I try to do anything with it I get an error such as:\ndev3 = qml.device('default.mixed', wires=1)\n\n\n@qml.qnode(dev3)\ndef depolarizingless_circuit():\n    # qml.Hadamard(wires=0)\n    qml.RX(np.array(0.7),wires =0)\n    return qml.expval(qml.PauliZ(0))\n           \n@qml.qnode(dev3)\ndef depolarizing0p001_circuit():\n    # qml.Hadamard(wires=0)\n    RX_0p001(np.array(0.7),wires =0)\n    return qml.expval(qml.PauliZ(0))\n\nIt yields the error:\nTypeError: RX_0p001.expand() missing 2 required positional arguments: 'theta' and 'wires'\nEdit_1:\nI also tried the following class:\nclass  RX_0p001(Operation):\n    num_wires = AnyWires  \n\n    def __init__(self, theta, wires, do_queue=True, id=None):\n        all_wires = qml.wires.Wires(wires)\n        super().__init__(theta, wires=all_wires, do_queue=do_queue, id=id)\n\n    @staticmethod\n    def compute_decomposition(theta, wires):\n        decomp = []\n        \n        decomp.append(qml.RX(theta, wires))\n        decomp.append(qml.DepolarizingChannel(p = 0.001, wires = wires))\n\n        return decomp\n\nIt again gives me the output when I instantiate it with angle and wire:\n\nRX_0p001(tensor(2, requires_grad=True), wires=[0])\n\nBut, feeding it to the function\n\ndepolarizing0p001_circuit()\n\nyields the following error:\n\nAttributeError                            Traceback (most recent call last)\nCell In[157], line 1\n----> 1 depolarizing0p001_circuit()\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/qnode.py:619, in QNode.call(self, *args, **kwargs)\n612 using_custom_cache = (\n613     hasattr(cache, \u201cgetitem\u201d)\n614     and hasattr(cache, \u201csetitem\u201d)\n615     and hasattr(cache, \u201cdelitem\u201d)\n616 )\n617 self._tape_cached = using_custom_cache and self.tape.hash in cache\n \u2192 619 res = qml.execute(\n620     [self.tape],\n621     device=self.device,\n622     gradient_fn=self.gradient_fn,\n623     interface=self.interface,\n624     gradient_kwargs=self.gradient_kwargs,\n625     override_shots=override_shots,\n626     **self.execute_kwargs,\n627 )\n629 if autograd.isinstance(res, (tuple, list)) and len(res) == 1:\n630     # If a device batch transform was applied, we need to \u2018unpack\u2019\n631     # the returned tuple/list to a float.\n(\u2026)\n638     # TODO: find a more explicit way of determining that a batch transform\n639     # was applied.\n641     res = res[0]\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/interfaces/execution.py:344, in execute(tapes, device, gradient_fn, interface, mode, gradient_kwargs, cache, cachesize, max_diff, override_shots, expand_fn, max_expansion, device_batch_transform)\n340     return batch_fn(res)\n342 if gradient_fn == \u201cbackprop\u201d or interface is None:\n343     return batch_fn(\n \u2192 344         qml.interfaces.cache_execute(\n345             batch_execute, cache, return_tuple=False, expand_fn=expand_fn\n346         )(tapes)\n347     )\n349 # the default execution function is batch_execute\n350 execute_fn = qml.interfaces.cache_execute(batch_execute, cache, expand_fn=expand_fn)\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/interfaces/execution.py:172, in cache_execute..wrapper(tapes, **kwargs)\n168         return (res, ) if return_tuple else res\n170 else:\n171     # execute all unique tapes that do not exist in the cache\n \u2192 172     res = fn(execution_tapes.values(), **kwargs)\n174 final_res = \n176 for i, tape in enumerate(tapes):\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/interfaces/execution.py:96, in cache_execute..fn(tapes, **kwargs)\n95 def fn(tapes, **kwargs):  # pylint: disable=function-redefined\n\u2014> 96     tapes = [expand_fn(tape) for tape in tapes]\n97     return original_fn(tapes, **kwargs)\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/interfaces/execution.py:96, in (.0)\n95 def fn(tapes, **kwargs):  # pylint: disable=function-redefined\n\u2014> 96     tapes = [expand_fn(tape) for tape in tapes]\n97     return original_fn(tapes, **kwargs)\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/interfaces/execution.py:325, in execute..(tape)\n322 batch_execute = set_shots(device, override_shots)(device.batch_execute)\n324 if expand_fn == \u201cdevice\u201d:\n \u2192 325     expand_fn = lambda tape: device.expand_fn(tape, max_expansion=max_expansion)\n327 if gradient_fn is None:\n328     # don\u2019t unwrap if it\u2019s an interface device\n329     if \u201cpassthru_interface\u201d in device.capabilities():\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/_device.py:680, in Device.expand_fn(self, circuit, max_expansion)\n677 if self.custom_expand_fn is not None:\n678     return self.custom_expand_fn(circuit, max_expansion=max_expansion)\n \u2192 680 return self.default_expand_fn(circuit, max_expansion=max_expansion)\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/_device.py:655, in Device.default_expand_fn(self, circuit, max_expansion)\n652 ops_not_supported = not all(self.stopping_condition(op) for op in circuit.operations)\n654 if ops_not_supported or obs_on_same_wire:\n \u2192 655     circuit = circuit.expand(depth=max_expansion, stop_at=self.stopping_condition)\n657 return circuit\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/tape/tape.py:610, in QuantumTape.expand(self, depth, stop_at, expand_measurements)\n562 def expand(self, depth=1, stop_at=None, expand_measurements=False):\n563     \u201c\u201d\u201cExpand all operations in the processed queue to a specific depth.\n564\n565     Args:\n(\u2026)\n608     RY(0.2, wires=[\u2018a\u2019])]\n609     \u201c\u201d\u201d\n \u2192 610     new_tape = expand_tape(\n611         self, depth=depth, stop_at=stop_at, expand_measurements=expand_measurements\n612     )\n613     new_tape._update()\n614     return new_tape\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/tape/tape.py:184, in expand_tape(tape, depth, stop_at, expand_measurements)\n181 if isinstance(obj, (qml.operation.Operator, qml.measurements.MeasurementProcess)):\n182     # Object is an operation; query it for its expansion\n183     try:\n \u2192 184         obj = obj.expand()\n185     except DecompositionUndefinedError:\n186         # Object does not define an expansion; treat this as\n187         # a stopping condition.\n188         getattr(new_tape, queue).append(obj)\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/operation.py:1185, in Operator.expand(self)\n1182 tape = qml.tape.QuantumTape(do_queue=False)\n1184 with tape:\n \u2192 1185     self.decomposition()\n1187 if not self.data:\n1188     # original operation has no trainable parameters\n1189     tape.trainable_params = {}\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/operation.py:1026, in Operator.decomposition(self)\n1014 def decomposition(self):\n1015     r\"\"\u201cRepresentation of the operator as a product of other operators.\n1016\n1017     \u2026 math:: O = O_1 O_2 \\dots O_n\n(\u2026)\n1024         list[Operator]: decomposition of the operator\n1025     \u201c\u201d\u201d\n \u2192 1026     return self.compute_decomposition(\n1027         *self.parameters, wires=self.wires, **self.hyperparameters\n1028     )\nCell In[154], line 13, in RX_0p001.compute_decomposition(theta, wires)\n10 decomp = \n12 decomp.append(qml.RX(theta, wires))\n\u2014> 13 decomp.append(qml.DepolarizingChannel(p = 0.001, wires = wires))\n15 return decomp\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/ops/channel.py:300, in DepolarizingChannel.init(self, p, wires, do_queue, id)\n299 def init(self, p, wires, do_queue=True, id=None):\n \u2192 300     super().init(p, wires=wires, do_queue=do_queue, id=id)\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/operation.py:1452, in Operation.init(self, wires, do_queue, id, *params)\n1449 def init(self, *params, wires=None, do_queue=True, id=None):\n1451     self._inverse = False\n \u2192 1452     super().init(*params, wires=wires, do_queue=do_queue, id=id)\n1454     # check the grad_recipe validity\n1455     if self.grad_recipe is None:\n1456         # Make sure grad_recipe is an iterable of correct length instead of None\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/operation.py:883, in Operator.init(self, wires, do_queue, id, *params)\n877 if self.num_wires not in {AllWires, AnyWires} and len(self._wires) != self.num_wires:\n878     raise ValueError(\n879         f\"{self.name}: wrong number of wires. \"\n880         f\"{len(self._wires)} wires given, {self.num_wires} expected.\"\n881     )\n \u2192 883 self._check_batching(params)\n885 self.data = list(params)  #: list[Any]: parameters of the operator\n887 if do_queue:\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/operation.py:903, in Operator._check_batching(self, params)\n901 self._batch_size = None\n902 try:\n \u2192 903     ndims = tuple(qml.math.ndim(p) for p in params)\n904 except ValueError as e:\n905     # TODO:[dwierichs] When using tf.function with an input_signature that contains\n906     # an unknown-shaped input, ndim() will not be able to determine the number of\n(\u2026)\n911     # investigated. For now, the batch_size is left to be None when instantiating\n912     # an operation with abstract parameters that make qml.math.ndim fail.\n913     if any(qml.math.is_abstract(p) for p in params):\nFile ~/JaxQuantumML/lib/python3.10/site-packages/pennylane/operation.py:903, in (.0)\n901 self._batch_size = None\n902 try:\n \u2192 903     ndims = tuple(qml.math.ndim(p) for p in params)\n904 except ValueError as e:\n905     # TODO:[dwierichs] When using tf.function with an input_signature that contains\n906     # an unknown-shaped input, ndim() will not be able to determine the number of\n(\u2026)\n911     # investigated. For now, the batch_size is left to be None when instantiating\n912     # an operation with abstract parameters that make qml.math.ndim fail.\n913     if any(qml.math.is_abstract(p) for p in params):\nFile ~/JaxQuantumML/lib/python3.10/site-packages/autoray/autoray.py:79, in do(fn, like, *args, **kwargs)\n30 \u201c\u201d\u201cDo function named fn on (*args, **kwargs), peforming single\n31 dispatch to retrieve fn based on whichever library defines the class of\n32 the args[0], or the like keyword argument if specified.\n(\u2026)\n76     <tf.Tensor: id=91, shape=(3, 3), dtype=float32>\n77 \u201c\u201d\u201d\n78 backend = choose_backend(fn, *args, like=like, **kwargs)\n\u2014> 79 return get_lib_fn(backend, fn)(*args, **kwargs)\nFile ~/JaxQuantumML/lib/python3.10/site-packages/autoray/autoray.py:886, in ndim(x)\n884 @compose\n885 def ndim(x):\n \u2192 886     return x.ndim\nAttributeError: \u2018float\u2019 object has no attribute \u2018ndim\u2019\nMy goal is to be able to compute gradients out of each of these fused block elements so that I can add them into circuits within an operator pool. Using a noiseless operator pool I\u2019m benchmarking Adapt VQE, and trying to use that noisy operator pool for Adapt VQE under noise.\nI would appreciate your help in somehow creating these custom gates/channels.\nBest,\nOnur\n[*]How to add custom gates and templates to PennyLane | PennyLane Blog", "link": "https://discuss.pennylane.ai//t/need-to-fuse-one-and-two-qubit-rotation-gates-with-noise-channels/3118/3"}}