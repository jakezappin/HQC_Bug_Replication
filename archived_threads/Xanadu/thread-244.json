{"0": {"author": "matp", "date": "1597960603413", "content": "I\u2019m using pennylane qml to minimize a cost function involving certain circuits. I\u2019m unexpectedly running into a \u2018max recursion depth error\u2019. Here is my code:\nfrom scipy import linalg\n%pip install pennylane --upgrade\nimport pennylane as qml\nimport numpy as np\n\n\nqbts=3\nlayers=3\nparams=layers*qbts + 2\nopt = qml.optimize.AdagradOptimizer()\nall_wires = [i for i in range(qbts)]\nansatz_wires = all_wires[1:]\ndev = qml.device(\"default.qubit\", analytic=True, wires=qbts+1)\n@qml.template\ndef ansatz(params):\n    param_idx = 0\n    for i in ansatz_wires:\n        qml.RY(params[param_idx], wires=i)\n        param_idx=param_idx+1\n    \n    for _ in range(layers-1):\n        for i in range(qbts):\n            if i+1 == qbts:\n                qml.CNOT(wires=[i,0])\n            else:\n                qml.CNOT(wires=[i,i+1])\n\n        for i in range(qbts):\n            qml.RY(params[param_idx], wires=i)\n            param_idx=param_idx+1\n@qml.template\ndef Cadder():\n    adder_matrix = np.diag(np.ones(2**qbts), -1)\n    adder_matrix[0,-1] = 1\n    \n    c_adder = linalg.block_diag(np.diag(np.ones(2**qbts)),adder_matrix)\n    \n    qml.QubitUnitary(c_adder,wires=all_wires)\n\n@qml.qnode(dev)\ndef circuit(l2,l1,U):\n    qml.Hadamard(0)\n    \n    ansatz(l1)\n    for u in U[::-1]:\n        if u == 'a': Cadder()\n    qml.inv(ansatz(l2))\n    \n    qml.Hadamard(0)\n    return qml.expval(qml.PauliZ(0))\n\ndef cost(l2,l1,U):\n    psi = circuit(l2[2:],l1[2:],U)\n    psi = [np.round(_,decimals=5) for _ in psi]\n    return np.linalg.norm(np.array(psi)-np.linalg.norm(fx))\n\ng0 = .02\ndef CostFunctionReal(l_new, l_old, g0=g0):\n    l2 = l_new[2:]\n    l1 = l_old[2:]\n    R1=circuit(l2,l1,[ ])\n    R2=circuit(l2,l1,['a']) #******* Issue caused by this line\n    return R1 + R2\ndef costMin(l_old):\n    return lambda l_new:CostFunctionReal(l_new,l_old)\n\nx0 = 4*np.pi*np.random.rand(params)\nx = opt.step(costMin(x0), x0)\n\nAs you can see, by the commented code, the issue is caused when I use the Cadder() circuit in the cost function CostFunctionReal(\u2026) when setting the R2 term. Your feedback on fixing this error would be much appreciated. Thanks.\n\n\n Solved by Tom_Bromley in post #2 \n\n\n                Hey @matp! \nI managed to get it to work by setting U as a keyword argument: \nfrom scipy import linalg\nimport pennylane as qml\nfrom pennylane import numpy as np\n\nqbts=3\nlayers=3\nparams=layers*qbts + 2\nopt = qml.optimize.AdagradOptimizer()\n\nall_wires = [i for i in range(qbts)]\nansatz_wires = all_wires\u2026\n              \n", "link": "https://discuss.pennylane.ai//t/unexpected-recursion-error-qml-minimization/526/1"}, "1": {"author": "Tom_Bromley", "date": "1598016091671", "content": "Hey @matp!\nI managed to get it to work by setting U as a keyword argument:\nfrom scipy import linalg\nimport pennylane as qml\nfrom pennylane import numpy as np\n\nqbts=3\nlayers=3\nparams=layers*qbts + 2\nopt = qml.optimize.AdagradOptimizer()\n\nall_wires = [i for i in range(qbts)]\nansatz_wires = all_wires[1:]\n\nadder_matrix = np.diag(np.ones(2**qbts - 1), -1)\nadder_matrix[0,-1] = 1\n\nc_adder = linalg.block_diag(np.diag(np.ones(2**qbts)),adder_matrix)\n\ndev = qml.device(\"default.qubit\", analytic=True, wires=qbts+1)\n\n@qml.template\ndef ansatz(params):\n    param_idx = 0\n    for i in ansatz_wires:\n        qml.RY(params[param_idx], wires=i)\n        param_idx=param_idx+1\n    \n    for _ in range(layers-1):\n        for i in range(qbts):\n            if i+1 == qbts:\n                qml.CNOT(wires=[i,0])\n            else:\n                qml.CNOT(wires=[i,i+1])\n\n        for i in range(qbts):\n            qml.RY(params[param_idx], wires=i)\n            param_idx=param_idx+1\n            \n@qml.template\ndef Cadder():\n    qml.QubitUnitary(adder_matrix, wires=all_wires)\n\n@qml.qnode(dev)\ndef circuit(l2,l1,U=None):\n    qml.Hadamard(0)\n    \n    ansatz(l1)\n    for u in U[::-1]:\n        if u == 'a':\n            Cadder()\n    qml.inv(ansatz(l2))\n    \n    qml.Hadamard(0)\n    return qml.expval(qml.PauliZ(0))\n\ndef cost(l2,l1,U):\n    psi = circuit(l2[2:],l1[2:],U)\n    psi = [np.round(_,decimals=5) for _ in psi]\n    return np.linalg.norm(np.array(psi)-np.linalg.norm(fx))\n\nl1 = np.random.random(params)\nl2 = np.random.random(params)\n\nc1 = circuit(l2, l1, U=[])\nc2 = circuit(l2, l1, U=[\"a\"])\n\nprint(c1, c2)\n\nYou can see in the code above that we use def circuit(l2,l1,U=None), which allows the QNode to not worry about differentiating with respect to U. I think having a list of strings was confusing autograd, which is the default interface for supporting differentiation of the QNode.\nSome other changes in the above:\n\nHad to user adder_matrix rather than c_adder as the unitary in Cadder since c_adder was of too big dimension\nYou should do from pennylane import numpy as np so that numpy functionality can keep track of the gradient (see here 1)\n\nHope this helps!Solution", "link": "https://discuss.pennylane.ai//t/unexpected-recursion-error-qml-minimization/526/2"}, "2": {"author": "matp", "date": "1598050343530", "content": "Thank you very much, I was able to solve the issue thanks to your feedback!1", "link": "https://discuss.pennylane.ai//t/unexpected-recursion-error-qml-minimization/526/3"}, "3": {"author": "matp", "date": "1597960603413", "content": "I\u2019m using pennylane qml to minimize a cost function involving certain circuits. I\u2019m unexpectedly running into a \u2018max recursion depth error\u2019. Here is my code:\nfrom scipy import linalg\n%pip install pennylane --upgrade\nimport pennylane as qml\nimport numpy as np\n\n\nqbts=3\nlayers=3\nparams=layers*qbts + 2\nopt = qml.optimize.AdagradOptimizer()\nall_wires = [i for i in range(qbts)]\nansatz_wires = all_wires[1:]\ndev = qml.device(\"default.qubit\", analytic=True, wires=qbts+1)\n@qml.template\ndef ansatz(params):\n    param_idx = 0\n    for i in ansatz_wires:\n        qml.RY(params[param_idx], wires=i)\n        param_idx=param_idx+1\n    \n    for _ in range(layers-1):\n        for i in range(qbts):\n            if i+1 == qbts:\n                qml.CNOT(wires=[i,0])\n            else:\n                qml.CNOT(wires=[i,i+1])\n\n        for i in range(qbts):\n            qml.RY(params[param_idx], wires=i)\n            param_idx=param_idx+1\n@qml.template\ndef Cadder():\n    adder_matrix = np.diag(np.ones(2**qbts), -1)\n    adder_matrix[0,-1] = 1\n    \n    c_adder = linalg.block_diag(np.diag(np.ones(2**qbts)),adder_matrix)\n    \n    qml.QubitUnitary(c_adder,wires=all_wires)\n\n@qml.qnode(dev)\ndef circuit(l2,l1,U):\n    qml.Hadamard(0)\n    \n    ansatz(l1)\n    for u in U[::-1]:\n        if u == 'a': Cadder()\n    qml.inv(ansatz(l2))\n    \n    qml.Hadamard(0)\n    return qml.expval(qml.PauliZ(0))\n\ndef cost(l2,l1,U):\n    psi = circuit(l2[2:],l1[2:],U)\n    psi = [np.round(_,decimals=5) for _ in psi]\n    return np.linalg.norm(np.array(psi)-np.linalg.norm(fx))\n\ng0 = .02\ndef CostFunctionReal(l_new, l_old, g0=g0):\n    l2 = l_new[2:]\n    l1 = l_old[2:]\n    R1=circuit(l2,l1,[ ])\n    R2=circuit(l2,l1,['a']) #******* Issue caused by this line\n    return R1 + R2\ndef costMin(l_old):\n    return lambda l_new:CostFunctionReal(l_new,l_old)\n\nx0 = 4*np.pi*np.random.rand(params)\nx = opt.step(costMin(x0), x0)\n\nAs you can see, by the commented code, the issue is caused when I use the Cadder() circuit in the cost function CostFunctionReal(\u2026) when setting the R2 term. Your feedback on fixing this error would be much appreciated. Thanks.\n\n\n Solved by Tom_Bromley in post #2 \n\n\n                Hey @matp! \nI managed to get it to work by setting U as a keyword argument: \nfrom scipy import linalg\nimport pennylane as qml\nfrom pennylane import numpy as np\n\nqbts=3\nlayers=3\nparams=layers*qbts + 2\nopt = qml.optimize.AdagradOptimizer()\n\nall_wires = [i for i in range(qbts)]\nansatz_wires = all_wires\u2026\n              \n", "link": "https://discuss.pennylane.ai//t/unexpected-recursion-error-qml-minimization/526/4"}}