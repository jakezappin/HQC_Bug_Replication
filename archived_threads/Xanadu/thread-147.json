{"0": {"author": "Muhammad_Kashif", "date": "1622915123421", "content": "Hello,\nI need to know how can we measure and get the probabilities of qubits in the same circuit. For instance, I have 4 qubits, I want to measure q0 and q1 in X-basis and need to know the output state probabilities of all the qubits, if possible or else q0,q2 and q3.\nSecondly, Is there any builtin function in pennylane for qubit measurement in X and Y basis or Am I right with the following?\nqml.PauliZ(wirenumber) --> measurement in computational basis.\nqml.PauliX(wirenumber) --> measurement in X basis.\nqml.PauliY(wirenumber) --> measurement in Y basis.\nThanks for the help", "link": "https://discuss.pennylane.ai//t/measurements-and-output-state-probabilities-in-a-single-circuit/1089/1"}, "1": {"author": "antalszava", "date": "1623025344107", "content": "Hi @Muhammad_Kashif!\nThank you for the questions \nWhen specifying measurements in a QNode, multiple types of measurements 11 are possible. Sampling using qml.sample will provide outcomes of a specified observable after running a quantum circuit.\nThe succinct way of having multiple outputs to a QNode is to have combined measurements 2 in the return statement:\nimport pennylane as qml\n\ndev = qml.device('default.qubit', wires=4, shots=5)\n\n@qml.qnode(dev)\ndef circuit():\n    return qml.sample(qml.PauliX(0)), qml.sample(qml.PauliX(1)), qml.probs(wires=range(4))\n\ncircuit()\n\nIn this case, PennyLane will be generating samples once and providing the PauliX measurement outcomes as well as the joint probability distribution based on 5 samples (specified by shots=5). The wires for the probability distribution can be provided when specifying the wires argument for qml.probs.\n\nSecondly, Is there any builtin function in pennylane for qubit measurement in X and Y basis or Am I right with the following?\n\nIndeed, using qml.PauliX or qml.PauliY, the PauliX and PauliY observables are used when providing measurement statistics. That\u2019s the same for qml.PauliZ, the PauliZ observable is used. The subtle difference between computational basis state measurements and using the PauliZ observable to obtain statistics is that in the latter case samples are the eigenvalues of the PauliZ operator. Therefore,  1 is the outcome for sampling the |0> basis state and 1is the outcome for sampling the|1>` state.\nimport pennylane as qml\n\ndev = qml.device('default.qubit', wires=1, shots=5)\n\n@qml.qnode(dev)\ndef circuit():\n    return qml.sample(qml.PauliZ(0))\n\ncircuit()\n\narray([1, 1, 1, 1, 1])\n\nThe |1> case can be checked by flipping the first qubit using qml.PauliX(0).\nHope this clears up things, let us know if you have further questions! ", "link": "https://discuss.pennylane.ai//t/measurements-and-output-state-probabilities-in-a-single-circuit/1089/2"}, "2": {"author": "Muhammad_Kashif", "date": "1623257193090", "content": "Hi @antalszava,\nThanks for the answer, However I am still a little confused on how to interpret the output. For instance for the below circuit:\n\nimport pennylane as qml\ndev1 = qml.device(\u201cdefault.qubit\u201d, wires=4, shots =10)\n@qml.qnode(dev1)\ndef circuit():\nqml.PauliX(wires=0)\nqml.Hadamard(wires=1)\nqml.Hadamard(wires=2)\nqml.CZ(wires=[0,1])\nqml.CZ(wires=[1, 2])\nqml.CZ(wires=[1, 3])\nreturn qml.sample(qml.PauliX(0)), qml.sample(qml.PauliX(1)), qml.probs(wires=range(4))\n\noutput:\n\n(array([ 1, -1,  1, -1, -1,  1,  1, -1, -1,  1], dtype=int64),\narray([ 1,  1,  1,  1, -1, -1, -1, -1,  1,  1], dtype=int64),\narray([0. , 0. , 0.3, 0. , 0.2, 0. , 0. , 0. , 0. , 0. , 0.3, 0. , 0.2,\n0. , 0. , 0. ]))\n\nHow does I read the output?\nI have 4 qubit system (q0=1, q1=q2=superposition, q3=0).\nIt is a CNOT gate with q3 as control and q0 and q2 are target_in and target_out respectively? Since I have initialized q0 in state |1> and q3 in state |0>, the output should be q2=|1> and q3=|0> for the above case. Is the output mentioned above indicating the same thing? It is literally confusingto read the outputs even in simple circuits here.\nq0 and q1 are measured in X-basis and q3 and q4 are not measured at all. The same circuit works fine in Qiskit. I am not sure about here or may be I am interpreting the output wrong?\nAny help would be appreciated.\nThanks", "link": "https://discuss.pennylane.ai//t/measurements-and-output-state-probabilities-in-a-single-circuit/1089/3"}, "3": {"author": "Tom_Bromley", "date": "1623332757091", "content": "Hey @Muhammad_Kashif!\n\n(array([ 1, -1, 1, -1, -1, 1, 1, -1, -1, 1], dtype=int64),\narray([ 1, 1, 1, 1, -1, -1, -1, -1, 1, 1], dtype=int64),\narray([0. , 0. , 0.3, 0. , 0.2, 0. , 0. , 0. , 0. , 0. , 0.3, 0. , 0.2,\n0. , 0. , 0. ]))\n\nHow does I read the output?\n\nLet\u2019s first look at the output corresponding to qml.probs(wires=range(4)), i.e., the last term in the tuple. This is a probability vector of dimension 2 ** 4. The first element corresponds to the probability of the |0000> state, the next to the |0001> state and so forth, with the last element giving the probability of |1111>.\nNow let\u2019s look at the output corresponding to qml.sample(qml.PauliX(0)), i.e., the first term in the tuple. We have array([ 1, -1, 1, -1, -1, 1, 1, -1, -1, 1], dtype=int64) which is an array of length specified by the number of shots (in this case 10). Each entry gives an output sample from the circuit.\nWhen measuring an observable, we expect the results to be the eigenvalues of that observable. Hence, since PauliX has eigenvalues +1 and -1, we expect to sample these eigenvalues. The eigenvectors of PauliX are |+> = (|0> + |1>) / root(2) (corresponding to the +1 eigenvalue) and |-> = (|0> - |1>) / root(2) (corresponding to the -1 eigenvalue). Whenever you see +1 being sampled, we know that the system is then in the |+> state in the corresponding qubit.\n\nIt is a CNOT gate with q3 as control and q0 and q2 are target_in and target_out respectively? Since I have initialized q0 in state |1> and q3 in state |0>, the output should be q2=|1> and q3=|0> for the above case. Is the output mentioned above indicating the same thing? It is literally confusingto read the outputs even in simple circuits here.\n\nIt looks like q3 is initialized in state |+> due to the Hadamard gate, which is likely why you are getting the the random samples when measuring q1 and q2. You could try skipping the Hadamard gates to get a deterministic output.\nHope this helps, and let us know if you still need a hand with interpreting the output!", "link": "https://discuss.pennylane.ai//t/measurements-and-output-state-probabilities-in-a-single-circuit/1089/4"}, "4": {"author": "Muhammad_Kashif", "date": "1623418760742", "content": "Hi @Tom_Bromley\nThanks for the help, I now have a good idea of output interpretation. Just a simple follow-up question, qml.sample and qml.expval are used when we need to measure certain qubit in eigenbasis of sigma X, Y and Z(computational), right?\nIn the code above, I have not applied Hadmard gate on q3. What I am actually trying to do is to implement the CNOT gate using Measurement-based quantum computation approach. For that I am creating a cluster state of 4 qubits by applying Hadamard gates on qubits (other than the ones acting as inputs) and then apply the entangling CZ gate. This is explained in here - page 14 (Figure 4a)\nAfterwards, measuring q0 and q1 in X-basis applies the CNOT gate between q3 (control) and q0(target) and the output can be read from q2 (flipped version of q0\u2019s initial state). The final states of q0 and q1 are not relevant in this regard.\nI have tried the same circuit IBM quantum composer online and it works fine. The same circuit should have the same output here as well but its not, can you please help with that?", "link": "https://discuss.pennylane.ai//t/measurements-and-output-state-probabilities-in-a-single-circuit/1089/5"}, "5": {"author": "Tom_Bromley", "date": "1623425863032", "content": "Hey @Muhammad_Kashif!\n\nJust a simple follow-up question, qml.sample and qml.expval are used when we need to measure certain qubit in eigenbasis of sigma X, Y and Z(computational), right?\n\nRight! qml.sample returns actual samples (i.e., a list of the sampled eigenvalues of our observable) and qml.expval gives the expectation value, which is just the average over those samples (when shots=None, the expectation value is exact). Note that both return types can accept any PennyLane Observable, including the Pauli operators.\n\nThe same circuit should have the same output here as well but its not, can you please help with that?\n\nWould you be able to share the Qiskit code you are using and your expected output? This will help us debug and spot where the difference may be arising.", "link": "https://discuss.pennylane.ai//t/measurements-and-output-state-probabilities-in-a-single-circuit/1089/6"}, "6": {"author": "Muhammad_Kashif", "date": "1623428397843", "content": "Hi @Tom_Bromley\nThanks\u2026\nYes sure I can share the Qiskit code, I am using IBM Quantum Composer, below is the translated Qiskit code:\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\nfrom numpy import pi\n\nqreg_q = QuantumRegister(4, 'q')\ncreg_c = ClassicalRegister(4, 'c')\ncircuit = QuantumCircuit(qreg_q, creg_c)\n\ncircuit.h(qreg_q[1])\ncircuit.h(qreg_q[2])\ncircuit.x(qreg_q[3])\ncircuit.cz(qreg_q[0], qreg_q[1])\ncircuit.h(qreg_q[0])\ncircuit.cz(qreg_q[1], qreg_q[2])\ncircuit.cz(qreg_q[1], qreg_q[3])\ncircuit.measure(qreg_q[0], creg_c[0])\ncircuit.h(qreg_q[1])\ncircuit.measure(qreg_q[1], creg_c[1])\n\nOutput:\n\njust to elaborate a little following my previous message in this thread, q0 = 0 (target_in), q3 = 1 (control), the target_out(q2) is in |1> state (flipped version of q0 since the control is |1>). Hope it will help you better understand my query.\nThanks for the help.", "link": "https://discuss.pennylane.ai//t/measurements-and-output-state-probabilities-in-a-single-circuit/1089/7"}, "7": {"author": "Tom_Bromley", "date": "1623442646183", "content": "Hey @Muhammad_Kashif!\nThe following PennyLane circuit should give you similar results to Qiskit:\nimport pennylane as qml\n\ndev = qml.device(\"default.qubit\", wires=4, shots=10)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.Hadamard(1)\n    qml.Hadamard(2)\n    qml.PauliX(3)\n    qml.CZ(wires=[0, 1])\n    qml.Hadamard(0)\n    qml.CZ(wires=[1, 2])\n    qml.CZ(wires=[1, 3])\n    qml.Hadamard(1)\n    return [qml.sample(qml.PauliZ(i)) for i in range(4)]\n\nsamples = circuit().T\nsamples = (samples + 1) / 2\nsamples\n\nThis circuit is sampling in the standard basis and follows the same set of gates as in Qiskit. Note that Qiskit uses a reversed convention for ordering qubits.", "link": "https://discuss.pennylane.ai//t/measurements-and-output-state-probabilities-in-a-single-circuit/1089/8"}}