{"0": {"author": "PhilippHS", "date": "1658311390598", "content": "Hello,\nI am working on a Quanten Neuronal Network which includes on the pennylane template CVNeuralNetLayers 2. I have to try it on hardware in the coming month and hoped to be able to do so on Borealis (via AWS Braket Hybrid-Jobs).\nHowever, I am currently a bit unsure how to best test the code before feeding it into Borealis.\nIs the pennylane device \u2018strawberryfields.fock\u2019 1 sufficient, or do I need to use another one of the devices of the Strawberry Fields Plugin 1?\nOr is there no Pennylane Simulator device at all and I would need to program something separate with Strawberry Fields?\nBest wishes,\nPhilipp", "link": "https://discuss.pennylane.ai//t/does-pennylane-sf-plugin-simmulate-borealis/2053/1"}, "1": {"author": "CatalinaAlbornoz", "date": "1658361598069", "content": "Hi @PhilippHS, great question.\nOur Borealis device has a programmable but limited architecture so there are only some specific circuits that you can run there. You can learn more about the circuits that you can run here 5.\nIf you want to run on photonic hardware I suggest that you try out our X8_01 device, which is accessible for free on Xanadu Cloud. You can learn how to run programs on it here 1. The strawberryfields.fock  device should work for simulations but take into account that the actual X8 device only supports gaussian gates.\nYou can get some inspiration in the work of others, which you can find here 3 and here for example.\nPlease let me know if this answers your question!", "link": "https://discuss.pennylane.ai//t/does-pennylane-sf-plugin-simmulate-borealis/2053/2"}, "2": {"author": "PhilippHS", "date": "1658392603325", "content": "Hi @CatalinaAlbornoz\nyes, this answers my question. Thank you very much for the quick reply.\nJust as a quick follow-up question:\nDo I understand correctly that the strawberryfields.gaussian 1 device would be better for simulating the X8_01 device, as it only includes gaussian gates?", "link": "https://discuss.pennylane.ai//t/does-pennylane-sf-plugin-simmulate-borealis/2053/3"}, "3": {"author": "CatalinaAlbornoz", "date": "1658448966888", "content": "Hi @PhilippHS,\nYou could use either device and only use the gates allowed by the hardware as specified in the Device details section 1 of our X8 tutorial. You will still get differences due to loss and other problems as you can see in this thread. I would actually be curious to know the outputs that you get by running a program on the Gaussian backend vs the Fock backend, given that you have an X8-compatible circuit in both cases.", "link": "https://discuss.pennylane.ai//t/does-pennylane-sf-plugin-simmulate-borealis/2053/4"}, "4": {"author": "PhilippHS", "date": "1659089016663", "content": "Hi @CatalinaAlbornoz,\nthank you very much for your answer. I had to remove the Kerr operation from the original template in order to make it gaussian-only but it seems to work now.\nSurprisingly, the Fock backend device requires significantly more run time for the Kerr operation removed (more then factor 100). It also does not seem to learn well. After the loss increased from the first to the second epoch I stopped it.\nThe Gaussian fackend also was quite slow too but at least it learned reasonably well.\nThe question is now if the X8_01 device would behave more like the gaussian- or the fock-backend.", "link": "https://discuss.pennylane.ai//t/does-pennylane-sf-plugin-simmulate-borealis/2053/5"}, "5": {"author": "isaacdevlugt", "date": "1659104808953", "content": "Hey @PhilippHS! Were you able to try X8_01? It will be back online next week. ", "link": "https://discuss.pennylane.ai//t/does-pennylane-sf-plugin-simmulate-borealis/2053/6"}, "6": {"author": "PhilippHS", "date": "1659381130826", "content": "Hi @isaacdevlugt\nyes, I was able to access the device today. Due to the limitations of the X8_01 I needed to reduce the template further and I am the remaining two interferometer will not be able to learn much \nAlso I now receive the Warning UserWarning: The device strawberryfields.remote does not support the PolyXP observable. The analytic parameter-shift cannot be used for second-order observables; falling back to finite-differences. \nI guess the X8_01 ist not really made to be used in a QNN, right? ", "link": "https://discuss.pennylane.ai//t/does-pennylane-sf-plugin-simmulate-borealis/2053/7"}, "7": {"author": "isaacdevlugt", "date": "1659449319561", "content": "Sorry to hear that! For your warning UserWarning: The device strawberryfields.remote does not support the PolyXP observable., this probably has to do with the face that X8 doesn\u2019t support that particular observable. Check out the device details here 1!", "link": "https://discuss.pennylane.ai//t/does-pennylane-sf-plugin-simmulate-borealis/2053/8"}, "8": {"author": "PhilippHS", "date": "1659452543131", "content": "Hi @isaacdevlugt\nthank you for your answer. Unfortunately, looking into it I am actually more confused by error message then before: At the end of my circuit I am using the measurement qml.NumberOperator as I considered it to be most close to the sf.ops.MeasureFock observable on the X8_01.\nThe qml.PolyXP observable is not even part of the circuit. Therefore, I do not understand where the User Warning comes from.\nDoes the qml.NumberOperator somehow decompose into something involving qml.PolyXP ?\nIf so which measurement should I use instead for the  X8_01.?", "link": "https://discuss.pennylane.ai//t/does-pennylane-sf-plugin-simmulate-borealis/2053/9"}, "9": {"author": "isaacdevlugt", "date": "1659474279240", "content": "Would you be able to provide any code?", "link": "https://discuss.pennylane.ai//t/does-pennylane-sf-plugin-simmulate-borealis/2053/10"}, "10": {"author": "PhilippHS", "date": "1659544759739", "content": "Hi @isaacdevlugt\nI now created the following example code which can reproduce the user warning\nfrom pennylane import numpy as np\nimport pennylane as qm\nimport tensorflow as tf\n\n# 0) Initialise Device\ndev = qml.device('strawberryfields.remote', backend='X8_01' )\n\n# 1) Define Input\nnum_inputs = 2\nnum_data = 5\nnum_outputs = 1\n\ninputs = np.asarray( [ [(1.2+x)*(d+1) for x in range(num_inputs)] for d in range(num_data)] )\noutputs= np.asarray( [ [(3.5+y)*(d+1) for y in range(num_outputs)] for d in range(num_data)] )\n\n# normalise and convert to tensors\ninputs = inputs / np.max(inputs)\noutputs= outputs / np.max(outputs)\n\ninputs_tf = tf.convert_to_tensor(inputs, np.float32)\noutputs_tf = tf.convert_to_tensor(outputs, np.float32)\n\n# 2) Define Qnode\n@qml.qnode(dev,interface='tf')\ndef qnode(inputs, theta_1, phi_1, varphi_1, theta_2, phi_2, varphi_2):\n\n   # 2.1) Rotation embedding (as squeezing only possible with binary inputs)\n    for i in range(num_inputs):\n        qml.Rotation(inputs[i], wires=i)\n        qml.Rotation(inputs[i], wires=i+4)\n\n    # 2.2) Interferometer-Layers\n        qml.Interferometer(theta=theta_1[:], phi=phi_1[:], varphi=varphi_1[:], mesh='rectangular', wires=[i for i in range(4)] )\n        qml.Interferometer(theta=theta_1[:], phi=phi_1[:], varphi=varphi_1[:], mesh='rectangular', wires=[i + 4 for i in range(4)] )\n        qml.Interferometer(theta=theta_2[:], phi=phi_2[:], varphi=varphi_2[:], mesh='triangular',  wires=[i for i in range(4)] )\n        qml.Interferometer(theta=theta_2[:], phi=phi_2[:], varphi=varphi_2[:], mesh='triangular',  wires=[i + 4 for i in range(4)] )\n\n    # 2.3) measure \n    ops =  [qml.expval(qml.NumberOperator(wires=i)) for i in range(num_outputs) ]\n\n    return ops\n\n# 3) get weight shapes\nM = 4\nK = int( M/2*(M-1) )\n\nweight_shapes = {  'theta_1':(K), 'phi_1':(K), 'varphi_1':(M),\n                   'theta_2':(K), 'phi_2':(K), 'varphi_2':(M) }  \n\n# 4) Create and train a simple toy model\n\nmodel = tf.keras.models.Sequential([\n    tf.keras.layers.Dense( num_inputs , activation=tf.nn.tanh),\n    qml.qnn.KerasLayer(qnode, weight_shapes, output_dim=num_outputs) ])\n\nmodel.compile(optimizer='adam' , loss='mse' )\nmodel.fit(x=inputs_tf, y=outputs_tf, epochs=3)", "link": "https://discuss.pennylane.ai//t/does-pennylane-sf-plugin-simmulate-borealis/2053/11"}, "11": {"author": "isaacdevlugt", "date": "1659560358447", "content": "Hey! Thank you for providing that. I just tested your code on Xanadu Cloud and reproduced the result you\u2019re getting. I\u2019ll list my thoughts out just to make it easier to read:\n\nThe docs for qml.PolyXP state the following:\n\n\n\u2026 Used for evaluating arbitrary order-2 CV expectation values of  CVParamShiftTape .\n\nSince qml.NumberOperator is an order-2 CV operator, this is why qml.PolyXP gets called under the hood.\n\nSo what\u2019s the deal with the warning UserWarning: The device strawberryfields.remote does not support the PolyXP observable. The analytic parameter-shift cannot be used for second-order observables; falling back to finite-differences.?\n\nI\u2019m in the midst of clarifying something with one of the members of the software team to double check what I think the problem is. Will get back to you soon!", "link": "https://discuss.pennylane.ai//t/does-pennylane-sf-plugin-simmulate-borealis/2053/12"}, "12": {"author": "isaacdevlugt", "date": "1659706435781", "content": "On point number two:\nX8 only supports PNR measurements, meaning that it can only measure the number operator \\hat{n}.\nWhen you train the model, the training is invoking the gradient, and X8 cannot differentiate, using the second-order PS rule, second-order observables like \\hat{n}. But, it can differentiate using finite differences!", "link": "https://discuss.pennylane.ai//t/does-pennylane-sf-plugin-simmulate-borealis/2053/13"}, "13": {"author": "PhilippHS", "date": "1659716357967", "content": "Hi @isaacdevlugt\nthank you very much for coming back to me. Do I understand correctly my use of the  qml.NumberOperator for measuring the circuit results is correct and the network could in fact learn?\nSo it just uses a less efficient method for calculating the gradient and therefore requires more circuit executions? (I noticed that it is executing far more jobs than expected.)", "link": "https://discuss.pennylane.ai//t/does-pennylane-sf-plugin-simmulate-borealis/2053/14"}, "14": {"author": "isaacdevlugt", "date": "1659727441246", "content": "Definitely the network can learn! Just not by using the parameter-shift rule . As you said, you\u2019d have to resort to finite differences (which, unfortunately, of the hardware-compatible differentiation methods isn\u2019t the best\u2026 but that\u2019s your only option ).\nI wouldn\u2019t say that finite differences are less efficient. To calculate the gradient with finite differences requires 2p circuit evaluations (the parameter-shift rule in this case would need more than that), where p is the number of trainable parameters. This isn\u2019t terribly inefficient for hardware-compatible methods!\nFinite difference gradients aren\u2019t ideal because\n\nThey aren\u2019t exact\nOn noisy hardware, the gradient can get \u201clost in the noise\u201d so to speak. Finite difference derivatives rely on evaluating the circuit at \\theta_i + h and \\theta_i - h, where \\theta_i is the parameter of interest and h << 1. We typically need h ~ O(10^{-5}) to get \u201cgood\u201d gradients (not exact still!). But, on noisy hardware, shifting a parameter by h and re-evaluating the circuit is risky business! The noise might overrule the value of h, leading to very inaccurate derivatives.\n", "link": "https://discuss.pennylane.ai//t/does-pennylane-sf-plugin-simmulate-borealis/2053/15"}, "15": {"author": "isaacdevlugt", "date": "1659727505311", "content": "If you\u2019re interested, we have a Youtube video on hardware-compatible differentiation methods \n \n\n\n\n\n\n\n\n          Differentiation on quantum hardware | PennyLane Tutorial\n        \n\n\n\n\n", "link": "https://discuss.pennylane.ai//t/does-pennylane-sf-plugin-simmulate-borealis/2053/16"}, "16": {"author": "PhilippHS", "date": "1660145806163", "content": "Hi @isaacdevlugt\nthank you very much for answers. The video is indeed very insightful.\nUnfortunately it looks like my circuit is in fact not suited to determine a gradient suitable for training. Even with a simulator, it does not work, no chance that the real device would produce something useful.\nAre you aware if anyone managed to use the X8_01 for a QML application?", "link": "https://discuss.pennylane.ai//t/does-pennylane-sf-plugin-simmulate-borealis/2053/17"}, "17": {"author": "isaacdevlugt", "date": "1660164815208", "content": "I can\u2019t think of anything off the top of my head. But it should be entirely possible!", "link": "https://discuss.pennylane.ai//t/does-pennylane-sf-plugin-simmulate-borealis/2053/18"}, "18": {"author": "isaacdevlugt", "date": "1659706435781", "content": "On point number two:\nX8 only supports PNR measurements, meaning that it can only measure the number operator \\hat{n}^n.\nWhen you train the model, the training is invoking the gradient, and X8 cannot differentiate, using the second-order PS rule, second-order observables like \\hat{n}^n. But, it can differentiate using finite differences!", "link": "https://discuss.pennylane.ai//t/does-pennylane-sf-plugin-simmulate-borealis/2053/19"}, "19": {"author": "isaacdevlugt", "date": "1659727441246", "content": "Definitely the network can learn! Just not by using the parameter-shift rule . As you said, you\u2019d have to resort to finite differences (which, unfortunately, of the hardware-compatible differentiation methods isn\u2019t the best\u2026 but that\u2019s your only option ).\nI wouldn\u2019t say that finite differences are less efficient. To calculate the gradient with finite differences requires 2p2p circuit evaluations (the parameter-shift rule in this case would need more than that), where pp is the number of trainable parameters. This isn\u2019t terribly inefficient for hardware-compatible methods!\nFinite difference gradients aren\u2019t ideal because\n\nThey aren\u2019t exact\nOn noisy hardware, the gradient can get \u201clost in the noise\u201d so to speak. Finite difference derivatives rely on evaluating the circuit at \\theta_i + h\u03b8i+h and \\theta_i - h\u03b8i\u2212h, where \\theta_i\u03b8i is the parameter of interest and h << 1h<<1. We typically need hh ~ O(10^{-5})O(10\u22125) to get \u201cgood\u201d gradients (not exact still!). But, on noisy hardware, shifting a parameter by hh and re-evaluating the circuit is risky business! The noise might overrule the value of hh, leading to very inaccurate derivatives.\n", "link": "https://discuss.pennylane.ai//t/does-pennylane-sf-plugin-simmulate-borealis/2053/20"}}