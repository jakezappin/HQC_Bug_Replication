{"0": {"author": "Antonio_Aguiar", "date": "1684416568243", "content": "Hi good morning dear colleagues, I am trying to evolve a system with six coherent states as input to three beamsplitters and I am facing the following errors described in the images below. How would I make this system evolve correctly?\n# import numpy as np\nfrom mrmustard.lab import *\n\nvac = Vacuum(num_modes=2)        # 2-mode vacuum state\ncoh0 = Coherent(x=-0.1, y=-0.4)    # coh state |-alpha> with alpha = -0.1 - 0.4j\ncoh1 = Coherent(x=0.1, y=-0.4)    # coh state |alpha> with alpha = 0.1 - 0.4j\nsq  = SqueezedVacuum(r=0.5)      # squeezed vacuum state\ng   = Gaussian(num_modes=2)      # 2-mode Gaussian state with zero means\nfock4 = Fock(4)                  # fock state |4>\n\nD  = Dgate(x=1.0, y=-0.4)         # Displacement by 1.0 along x and -0.4 along y\nS  = Sgate(r=0.5)                 # Squeezer with r=0.5\n\nBS = BSgate(theta=np.pi/4)          # 50/50 beam splitter\nS2 = S2gate(r=0.5)                  # two-mode squeezer\nMZ = MZgate(phi_a=0.3, phi_b=0.1)   # Mach-Zehnder interferometer\nI  = Interferometer(8)              # 8-mode interferometer\nL  = Attenuator(0.5)                # pure lossy channel with 50% transmissivity\nA  = Amplifier(gain=2.0, nbar=1.0)  # noisy amplifier with 200% gain\n\n## Primeira bateria de BS\n\nCoherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[0,1]\nCoherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[2,3]\nCoherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[4,5]\n\n## Segunda bateria de BS\nCoherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[3,5]\nCoherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[1,6]\nCoherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[2,4]\n\n\n\nIf you want help with diagnosing an error, please put the full error message below:\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[6], line 4\n      1 ## Primeira bateria de BS\n      3 Coherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[0,1]\n----> 4 Coherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[2,3]\n      5 Coherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[4,5]\n\nFile ~\\anaconda3\\lib\\site-packages\\mrmustard\\lab\\abstract\\state.py:500, in State.__rshift__(self, other)\n    496 if issubclass(other.__class__, State):\n    497     raise TypeError(\n    498         f\"Cannot apply {other.__class__.__qualname__} to a state. Are you looking for the << operator?\"\n    499     )\n--> 500 return other.primal(self)\n\nFile ~\\anaconda3\\lib\\site-packages\\mrmustard\\lab\\abstract\\transformation.py:56, in Transformation.primal(self, state)\n     47 r\"\"\"Applies ``self`` (a ``Transformation``) to other (a ``State``) and returns the transformed state.\n     48 \n     49 Args:\n   (...)\n     53     State: the transformed state\n     54 \"\"\"\n     55 if state.is_gaussian:\n---> 56     new_state = self.transform_gaussian(state, dual=False)\n     57 else:\n     58     new_state = self.transform_fock(state, dual=False)\n\nFile ~\\anaconda3\\lib\\site-packages\\mrmustard\\lab\\abstract\\transformation.py:103, in Transformation.transform_gaussian(self, state, dual)\n     93 r\"\"\"Transforms a Gaussian state into a Gaussian state.\n     94 \n     95 Args:\n   (...)\n    100     State: the transformed state\n    101 \"\"\"\n    102 X, Y, d = self.XYd if not dual else self.XYd_dual\n--> 103 cov, means = gaussian.CPTP(state.cov, state.means, X, Y, d, state.modes, self.modes)\n    104 new_state = State(\n    105     cov=cov, means=means, modes=state.modes, _norm=state.norm\n    106 )  # NOTE: assumes modes don't change\n    107 return new_state\n\nFile ~\\anaconda3\\lib\\site-packages\\mrmustard\\physics\\gaussian.py:432, in CPTP(cov, means, X, Y, d, state_modes, transf_modes)\n    411 r\"\"\"Returns the cov matrix and means vector of a state after undergoing a CPTP channel.\n    412 \n    413 Computed as ``cov = X \\cdot cov \\cdot X^T + Y`` and ``d = X \\cdot means + d``.\n   (...)\n    429     Tuple[Matrix, Vector]: the covariance matrix and the means vector of the state after the CPTP channel\n    430 \"\"\"\n    431 if not set(transf_modes).issubset(state_modes):\n--> 432     raise ValueError(\n    433         f\"The channel should act on a subset of the state modes ({transf_modes} is not a subset of {state_modes})\"\n    434     )\n    435 # if single-mode channel, apply to all modes indicated in `modes`\n    436 if X is not None and X.shape[-1] == 2:\n\nValueError: The channel should act on a subset of the state modes ([2, 3] is not a subset of [0, 1])\n\n\nconda 23.3.1\nmrmustard                 0.3.0\nnumpy                     1.23.5", "link": "https://discuss.pennylane.ai//t/implementation-of-a-network-of-interconnected-beamsplitters-for-coherent-state-evolution/2949/1"}, "1": {"author": "isaacdevlugt", "date": "1684424454754", "content": "Hey @Antonio_Aguiar! Welcome to the forum \nThe issue here is that there are only two states indexed by 0 and 1. New state modes aren\u2019t created after the first line you have . You can fix this by doing BS[0, 1] instead of BS[2, 3]. This actually applies to every line after that, as well!  Here\u2019s a demonstration:\nstates = [\n    \"Coherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[0, 1]\",\n    \"Coherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[2, 3]\",\n    \"Coherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[4, 5]\",\n    \"Coherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[3, 5]\",\n    \"Coherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[1, 6]\",\n    \"Coherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[2, 4]\",\n]\n\nfor state in states:\n    try:\n        eval(state)\n    except ValueError as e:\n        print(state)\n        print(e)\n        print()\n\n'''\nCoherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[2, 3]\nThe channel should act on a subset of the state modes ([2, 3] is not a subset of [0, 1])\n\nCoherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[4, 5]\nThe channel should act on a subset of the state modes ([4, 5] is not a subset of [0, 1])\n\nCoherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[3, 5]\nThe channel should act on a subset of the state modes ([3, 5] is not a subset of [0, 1])\n\nCoherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[1, 6]\nThe channel should act on a subset of the state modes ([1, 6] is not a subset of [0, 1])\n\nCoherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[2, 4]\nThe channel should act on a subset of the state modes ([2, 4] is not a subset of [0, 1])\n'''\n\nSo, just change the indices you access in each BS to [0,1]:\nstates = [\n    \"Coherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[0, 1]\",\n    \"Coherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[0, 1]\",\n    \"Coherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[0, 1]\",\n    \"Coherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[0, 1]\",\n    \"Coherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[0, 1]\",\n    \"Coherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[0, 1]\",\n]\n", "link": "https://discuss.pennylane.ai//t/implementation-of-a-network-of-interconnected-beamsplitters-for-coherent-state-evolution/2949/2"}, "2": {"author": "isaacdevlugt", "date": "1684425274925", "content": "If your goal was to create a multi-mode state, then you need to compound those Coherent operations into one object like this:\nstate = (\n    Coherent(x=[1.0, 2.0], y=[-1.0, -2.0])\n    & Coherent(x=[1.0, 2.0], y=[-1.0, -2.0])\n    & Coherent(x=[1.0, 2.0], y=[-1.0, -2.0])\n)\n\nprint(state.num_modes) # 6\n\nstate >> BS[0, 1] >> BS[2, 3] >> BS[4, 5] # this works!\n\nYou can find out more about this here: Basic API Reference \u2014 Mr Mustard 0.4.1 documentation 21", "link": "https://discuss.pennylane.ai//t/implementation-of-a-network-of-interconnected-beamsplitters-for-coherent-state-evolution/2949/3"}, "3": {"author": "Antonio_Aguiar", "date": "1684427565409", "content": "Thank you for your attention. The multimode solution suits me best. About the last code, when you defined the states, there are six coherent states that will then pass through the beam splitters, correct? My next step is to build a function that switches the inputs between |alpha> and |-alpha> so that I evaluate all 64 possible inputs and evolution of my system. Do you know a way to do this analysis?", "link": "https://discuss.pennylane.ai//t/implementation-of-a-network-of-interconnected-beamsplitters-for-coherent-state-evolution/2949/4"}, "4": {"author": "isaacdevlugt", "date": "1684431568229", "content": "Yep! In my code example, state is a 6-mode coherent state that then goes through three beam splitters that act on specific modes.\n\nMy next step is to build a function that switches the inputs between |alpha> and |-alpha> so that I evaluate all 64 possible inputs and evolution of my system.\n\nInteresting! Well, another way that you can make a Coherent state is by applying the displacement operator to a vacuum state. You can do this iteratively as follows:\nalpha = [0.1, 0.2] # alpha[0] = x, alpha[1] = y\nnum_modes = 4\n\nstate = Vacuum(num_modes=num_modes)\n\nfor m in range(num_modes):\n    state >> Dgate(x=alpha[0], y=alpha[1])\n\nHope this helps!", "link": "https://discuss.pennylane.ai//t/implementation-of-a-network-of-interconnected-beamsplitters-for-coherent-state-evolution/2949/5"}, "5": {"author": "Antonio_Aguiar", "date": "1684416568243", "content": "Hi good morning dear colleagues, I am trying to evolve a system with six coherent states as input to three beamsplitters and I am facing the following errors described in the images below. How would I make this system evolve correctly?\n# import numpy as np\nfrom mrmustard.lab import *\n\nvac = Vacuum(num_modes=2)        # 2-mode vacuum state\ncoh0 = Coherent(x=-0.1, y=-0.4)    # coh state |-alpha> with alpha = -0.1 - 0.4j\ncoh1 = Coherent(x=0.1, y=-0.4)    # coh state |alpha> with alpha = 0.1 - 0.4j\nsq  = SqueezedVacuum(r=0.5)      # squeezed vacuum state\ng   = Gaussian(num_modes=2)      # 2-mode Gaussian state with zero means\nfock4 = Fock(4)                  # fock state |4>\n\nD  = Dgate(x=1.0, y=-0.4)         # Displacement by 1.0 along x and -0.4 along y\nS  = Sgate(r=0.5)                 # Squeezer with r=0.5\n\nBS = BSgate(theta=np.pi/4)          # 50/50 beam splitter\nS2 = S2gate(r=0.5)                  # two-mode squeezer\nMZ = MZgate(phi_a=0.3, phi_b=0.1)   # Mach-Zehnder interferometer\nI  = Interferometer(8)              # 8-mode interferometer\nL  = Attenuator(0.5)                # pure lossy channel with 50% transmissivity\nA  = Amplifier(gain=2.0, nbar=1.0)  # noisy amplifier with 200% gain\n\n## Primeira bateria de BS\n\nCoherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[0,1]\nCoherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[2,3]\nCoherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[4,5]\n\n## Segunda bateria de BS\nCoherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[3,5]\nCoherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[1,6]\nCoherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[2,4]\n\n\n\nIf you want help with diagnosing an error, please put the full error message below:\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[6], line 4\n      1 ## Primeira bateria de BS\n      3 Coherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[0,1]\n----> 4 Coherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[2,3]\n      5 Coherent(x=[1.0, 2.0], y=[-1.0, -2.0]) >> BS[4,5]\n\nFile ~\\anaconda3\\lib\\site-packages\\mrmustard\\lab\\abstract\\state.py:500, in State.__rshift__(self, other)\n    496 if issubclass(other.__class__, State):\n    497     raise TypeError(\n    498         f\"Cannot apply {other.__class__.__qualname__} to a state. Are you looking for the << operator?\"\n    499     )\n--> 500 return other.primal(self)\n\nFile ~\\anaconda3\\lib\\site-packages\\mrmustard\\lab\\abstract\\transformation.py:56, in Transformation.primal(self, state)\n     47 r\"\"\"Applies ``self`` (a ``Transformation``) to other (a ``State``) and returns the transformed state.\n     48 \n     49 Args:\n   (...)\n     53     State: the transformed state\n     54 \"\"\"\n     55 if state.is_gaussian:\n---> 56     new_state = self.transform_gaussian(state, dual=False)\n     57 else:\n     58     new_state = self.transform_fock(state, dual=False)\n\nFile ~\\anaconda3\\lib\\site-packages\\mrmustard\\lab\\abstract\\transformation.py:103, in Transformation.transform_gaussian(self, state, dual)\n     93 r\"\"\"Transforms a Gaussian state into a Gaussian state.\n     94 \n     95 Args:\n   (...)\n    100     State: the transformed state\n    101 \"\"\"\n    102 X, Y, d = self.XYd if not dual else self.XYd_dual\n--> 103 cov, means = gaussian.CPTP(state.cov, state.means, X, Y, d, state.modes, self.modes)\n    104 new_state = State(\n    105     cov=cov, means=means, modes=state.modes, _norm=state.norm\n    106 )  # NOTE: assumes modes don't change\n    107 return new_state\n\nFile ~\\anaconda3\\lib\\site-packages\\mrmustard\\physics\\gaussian.py:432, in CPTP(cov, means, X, Y, d, state_modes, transf_modes)\n    411 r\"\"\"Returns the cov matrix and means vector of a state after undergoing a CPTP channel.\n    412 \n    413 Computed as ``cov = X \\cdot cov \\cdot X^T + Y`` and ``d = X \\cdot means + d``.\n   (...)\n    429     Tuple[Matrix, Vector]: the covariance matrix and the means vector of the state after the CPTP channel\n    430 \"\"\"\n    431 if not set(transf_modes).issubset(state_modes):\n--> 432     raise ValueError(\n    433         f\"The channel should act on a subset of the state modes ({transf_modes} is not a subset of {state_modes})\"\n    434     )\n    435 # if single-mode channel, apply to all modes indicated in `modes`\n    436 if X is not None and X.shape[-1] == 2:\n\nValueError: The channel should act on a subset of the state modes ([2, 3] is not a subset of [0, 1])\n\n\nconda 23.3.1\nmrmustard                 0.3.0\nnumpy                     1.23.5", "link": "https://discuss.pennylane.ai//t/implementation-of-a-network-of-interconnected-beamsplitters-for-coherent-state-evolution/2949/6"}}