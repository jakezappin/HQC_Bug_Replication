{"0": {"author": "Julien_Bruyninckx", "date": "1658575572168", "content": "Hello,\nThe code below is based on this paper : https://arxiv.org/pdf/2011.10395.pdf 2\nand it is used to solve non linear DEs.\nWhen I ran the code on the default.qubit , everything works fine (although a bit slow). I then moved it to qiskit.aer, and it get stucks when calculating the gradient. I\u2019m not sure why, but everything else works, i.e. it gets the expectation values and calculate the loss, but then gets stuck, no error message.\nI need this to work with qiskit, because I eventually have to run this code on a Hardware.\nimport qiskit\nfrom qiskit import *\nimport pennylane as qml\nfrom pennylane import numpy as np\nfrom numpy import pi\nfrom pennylane.optimize import AdamOptimizer\nfrom pennylane.optimize import AdagradOptimizer\n\nimport matplotlib.pyplot as plt\nimport time\n\ndev = qml.device('qiskit.aer', wires=6)\nnum_layers = 5\nbound = 1\ndiv=1\nvar_init = np.random.uniform(0, np.pi * 2, (3*num_layers, 6))\n\n#this is the ansatz\ndef layers(var,n_wires,d):\n    for i in range(n_wires):\n        qml.RZ(var[0+d*3][i],wires=i)\n        qml.RX(var[1+d*3][i],wires=i)\n        qml.RZ(var[2+d*3][i],wires=i)\n    for i in range(n_wires):\n        if i !=n_wires-1:\n            qml.CNOT(wires=[i, i+1])\n#this is the first quantum circuit\n    @qml.qnode(dev)\ndef qfc(var, x,n_wires,depth):\n    for i in range(n_wires):\n        qml.RY(x, wires=i)\n\n    # \"layer\" subcircuits\n    for d in range(depth):\n        layers(var,n_wires,d)\n\n    return [qml.expval(qml.PauliZ(i)) for i in range(n_wires)]\n\n#second quantum circuit\n@qml.qnode(dev)\ndef dqcplus(var,x,n_wires,depth,num):\n    #print(var)\n    for i in range(n_wires):\n        if i != num:\n            qml.RY(x,wires=i)\n        else:\n            qml.RY(x+pi/2,wires=i)\n    for d in range(depth):\n        layers(var,n_wires,d)\n\n    return [qml.expval(qml.PauliZ(i)) for i in range(n_wires)]\n\n@qml.qnode(dev)\ndef dqcmin(var,x,n_wires,depth,num):\n    for i in range(n_wires):\n        if i != num:\n            qml.RY(x,wires=i)\n        else:\n            qml.RY(x-pi/2,wires=i)\n    for d in range(depth):\n        layers(var,n_wires,d)\n\n    return [qml.expval(qml.PauliZ(i)) for i in range(n_wires)]\n\nDon\u2019t worry too much about the second circuits, they are essentially like the first one, but with shifted angles for the gates.\nwe then have our loss and cost function.\n    def loss(preds):\n        loss = 0\n        for p in preds:\n            loss += p**2\n        loss = loss/len(preds)\n        print(\"loss calculated\")\n        return loss\n\ndef cost(var,points,fb):\n    preds=[]\n    \n    for x in points:\n        cplus = [sum(dqcplus(var = var,x=2*np.arccos(x),n_wires=6,depth=num_layers,num=i))/div for i in range(6)]\n        cmin = [sum(dqcmin(var = var,x=2*np.arccos(x),n_wires=6,depth=num_layers,num=i))/div for i in range(6)]\n        \n        du = (1/2)*(-2/np.sqrt(1-x**2))*(sum(cplus)-sum(cmin))\n        \n        u=fb+sum(qfc(var = var,x=2*np.arccos(x),n_wires=6,depth=num_layers))/div\n       \n        pred = du+(8*u*(0.1+np.tan(8*x)))\n        \n        preds.append(pred)\n    \n    return loss(preds)\n\nand finally, the part where it all goes wrong, the optimization step\nopt = AdamOptimizer(0.01, beta1=0.9, beta2=0.99)\nvar = var_init\ncoste = []\nstart = time.time()\nprint(\"starting\")\nfor it in range(10):\n    fb = bound-sum(qfc(var = var,x=2*np.arccos(0),n_wires=6,depth=num_layers))/div\nvar, _cost = opt.step_and_cost(lambda v:cost(v, np.linspace(0, 0.9, 10),float(fb)),var)\n    print(\"success\")\n    coste.append(_cost)\n    print(\"Iter: {:5d} | Cost: {:0.7f} \".format(it, _cost))\n    #if _cost <0.1:\n     #   break\nend = time.time()\nprint(\"the optimisation is finished, it took\")\nprint(end - start)  \n\nSorry about all the indenting, I\u2019m new to posting on help blog.\nSo to resume, this code works fine if I use the default.qubit backend. But when I move to qiskit.aer, it fails to calculate the gradient, but it can still evaluate the quantul circuit.\nI hope I am just missing something small ? I do know that I have a lot of parameter to optimize, I think its something like 156+ 15662 =1170. But actually its more like 90 since the parameter in the second circuit are the same as the first. But again, it works fine with the default.qubit so I\u2019m quite loss.\nThanks for any help guys ", "link": "https://discuss.pennylane.ai//t/adam-optimizer-doesnt-work-with-qiskit-aer/2059/1"}, "1": {"author": "CatalinaAlbornoz", "date": "1658800797999", "content": "Hi @Julien_Bruyninckx, welcome to the Forum!\nI can see that there is a big slowdown with running your program using qiskit.aer compared to default.qubit. This is not specific to the Adam optimizer, since you get a similar slowdown with the GradientDescentOptimizer. It is normal to find some slowdown with qiskit.aer since PennyLane is optimized to work with PennyLane devices. In this case my suggestion would be to reduce the size of your problem. For instance if you reduce the number of qubits to 2 you get an answer in about 4min and for 3 qubits it takes about 12min. If you wait long enough you probably get an answer for more qubits. If your program runs out of memory then you can try our circuit-cutting functionality. You can read more about it in the docs 1 or the release blog.\nPlease let me know if this helps!", "link": "https://discuss.pennylane.ai//t/adam-optimizer-doesnt-work-with-qiskit-aer/2059/2"}, "2": {"author": "Julien_Bruyninckx", "date": "1658575572168", "content": "Hello,\nThe code below is based on this paper : https://arxiv.org/pdf/2011.10395.pdf 2\nand it is used to solve non linear DEs.\nWhen I ran the code on the default.qubit , everything works fine (although a bit slow). I then moved it to qiskit.aer, and it get stucks when calculating the gradient. I\u2019m not sure why, but everything else works, i.e. it gets the expectation values and calculate the loss, but then gets stuck, no error message.\nI need this to work with qiskit, because I eventually have to run this code on a Hardware.\nimport qiskit\nfrom qiskit import *\nimport pennylane as qml\nfrom pennylane import numpy as np\nfrom numpy import pi\nfrom pennylane.optimize import AdamOptimizer\nfrom pennylane.optimize import AdagradOptimizer\n\nimport matplotlib.pyplot as plt\nimport time\n\ndev = qml.device('qiskit.aer', wires=6)\nnum_layers = 5\nbound = 1\ndiv=1\nvar_init = np.random.uniform(0, np.pi * 2, (3*num_layers, 6))\n\n#this is the ansatz\ndef layers(var,n_wires,d):\n    for i in range(n_wires):\n        qml.RZ(var[0+d*3][i],wires=i)\n        qml.RX(var[1+d*3][i],wires=i)\n        qml.RZ(var[2+d*3][i],wires=i)\n    for i in range(n_wires):\n        if i !=n_wires-1:\n            qml.CNOT(wires=[i, i+1])\n#this is the first quantum circuit\n    @qml.qnode(dev)\ndef qfc(var, x,n_wires,depth):\n    for i in range(n_wires):\n        qml.RY(x, wires=i)\n\n    # \"layer\" subcircuits\n    for d in range(depth):\n        layers(var,n_wires,d)\n\n    return [qml.expval(qml.PauliZ(i)) for i in range(n_wires)]\n\n#second quantum circuit\n@qml.qnode(dev)\ndef dqcplus(var,x,n_wires,depth,num):\n    #print(var)\n    for i in range(n_wires):\n        if i != num:\n            qml.RY(x,wires=i)\n        else:\n            qml.RY(x+pi/2,wires=i)\n    for d in range(depth):\n        layers(var,n_wires,d)\n\n    return [qml.expval(qml.PauliZ(i)) for i in range(n_wires)]\n\n@qml.qnode(dev)\ndef dqcmin(var,x,n_wires,depth,num):\n    for i in range(n_wires):\n        if i != num:\n            qml.RY(x,wires=i)\n        else:\n            qml.RY(x-pi/2,wires=i)\n    for d in range(depth):\n        layers(var,n_wires,d)\n\n    return [qml.expval(qml.PauliZ(i)) for i in range(n_wires)]\n\nDon\u2019t worry too much about the second circuits, they are essentially like the first one, but with shifted angles for the gates.\nwe then have our loss and cost function.\n    def loss(preds):\n        loss = 0\n        for p in preds:\n            loss += p**2\n        loss = loss/len(preds)\n        print(\"loss calculated\")\n        return loss\n\ndef cost(var,points,fb):\n    preds=[]\n    \n    for x in points:\n        cplus = [sum(dqcplus(var = var,x=2*np.arccos(x),n_wires=6,depth=num_layers,num=i))/div for i in range(6)]\n        cmin = [sum(dqcmin(var = var,x=2*np.arccos(x),n_wires=6,depth=num_layers,num=i))/div for i in range(6)]\n        \n        du = (1/2)*(-2/np.sqrt(1-x**2))*(sum(cplus)-sum(cmin))\n        \n        u=fb+sum(qfc(var = var,x=2*np.arccos(x),n_wires=6,depth=num_layers))/div\n       \n        pred = du+(8*u*(0.1+np.tan(8*x)))\n        \n        preds.append(pred)\n    \n    return loss(preds)\n\nand finally, the part where it all goes wrong, the optimization step\nopt = AdamOptimizer(0.01, beta1=0.9, beta2=0.99)\nvar = var_init\ncoste = []\nstart = time.time()\nprint(\"starting\")\nfor it in range(10):\n    fb = bound-sum(qfc(var = var,x=2*np.arccos(0),n_wires=6,depth=num_layers))/div\nvar, _cost = opt.step_and_cost(lambda v:cost(v, np.linspace(0, 0.9, 10),float(fb)),var)\n    print(\"success\")\n    coste.append(_cost)\n    print(\"Iter: {:5d} | Cost: {:0.7f} \".format(it, _cost))\n    #if _cost <0.1:\n     #   break\nend = time.time()\nprint(\"the optimisation is finished, it took\")\nprint(end - start)  \n\nSorry about all the indenting, I\u2019m new to posting on help blog.\nSo to resume, this code works fine if I use the default.qubit backend. But when I move to qiskit.aer, it fails to calculate the gradient, but it can still evaluate the quantul circuit.\nI hope I am just missing something small ? I do know that I have a lot of parameter to optimize, I think its something like 156+ 15662 =1170. But actually its more like 90 since the parameter in the second circuit are the same as the first. But again, it works fine with the default.qubit so I\u2019m quite loss.\nThanks for any help guys ", "link": "https://discuss.pennylane.ai//t/adam-optimizer-doesnt-work-with-qiskit-aer/2059/3"}}