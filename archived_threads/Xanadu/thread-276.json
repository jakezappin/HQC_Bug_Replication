{"0": {"author": "jackaraz", "date": "1651590895096", "content": "Hi all, I would like to ask some specific questions (I\u2019m sorry its very specific, forgive me) about a paper I\u2019m reading. In 1903.06577, authors are playing with the sigma model hamiltonian, and they are showing how they constructed the time evolution circuit with respect to this hamiltonian. They are using four-dimensional Hilbert space (per site), so each site is defined via two-qubit. I was wondering how I can compute the expectation value of this hamiltonian on a quantum circuit instead of time evolution.\nSo for the interaction terms (please correct me if I\u2019m wrong), they are giving the  j_{1,2,3}  definition (eq. 8) so I believe it is correct to use that definition to form the hamiltonian i.e. j_1 = \\frac{\\mathbf{1}\\otimes\\sigma_2}{\\sqrt{3}} = qml.Hamiltonian([1/np.sqrt(3.)], [qml.Identity(0) @ qml.PauliY(1)]). However, I\u2019m not sure about the kinetic term, they are converting everything into this new  T  basis they are using but without the conversion, (e.g. 1812.00944 eq 2), the kinetic term for the sigma model is  \\frac{1}{2\\beta}\\sum_k^3 J^2_k  where J_k is the angular momentum operator. So would it be correct to write it as qml.Hamiltonian([(1/2*betta)*(hbar/2)**2]*3, [qml.PauliX(0) @ qml.PauliX(1), qml.PauliY(0) @ qml.PauliY(1), qml.PauliZ(0) @ qml.PauliZ(1)])? If I write the entire sum I believe this will give me an identity matrix with a phase. So if I write a simple circuit to calculate the expectation value for only the terms  k=0  in kinetic term (for simplicity) and first interaction term\nimport pennylane as qml\n\ndev = qml.device(\"default.qubit\", wires = 2)\n\n@qml.qnode(dev)\ndef circuit(): \n    # prepare an initial state (not important)\n    for wire in range(2):\n        qml.RY(np.pi/2., wire)\n\n    return qml.expval(qml.Hamiltonian([(1/2)**2, 1/np.sqrt(3.)], \n                                      [qml.PauliX(0) @ qml.PauliX(1), qml.Identity(0) @ qml.PauliY(1)]))\n\nWould this be correct? Any insight and/or reference is highly appreciated.\nThanks for your time", "link": "https://discuss.pennylane.ai//t/converting-sigma-model-hamiltonian-into-a-circuit/1877/1"}, "1": {"author": "CatalinaAlbornoz", "date": "1651699215505", "content": "Hi @jackaraz, thank you for asking this question here. We are taking a look at it and should be back soon with an answer.", "link": "https://discuss.pennylane.ai//t/converting-sigma-model-hamiltonian-into-a-circuit/1877/2"}, "2": {"author": "jackaraz", "date": "1651739737112", "content": "Hi @CatalinaAlbornoz, thank you so very much!!\nIn the meantime, I was looking into other sources and I believe for the interaction terms I can use raising and lowering operators i.e. S^{\\pm} = \\sigma_x \\pm i\\sigma_y and S_z so the full summation should be \\sum_n \\left( S^+_nS^-_{n+1} + S^-_nS^+_{n+1} + S^z_n S^z_{n+1} \\right) where n indicates qubit here. So the first interaction term in the Hamiltonian, I believe, can be written as qml.Hamiltonian([1, -1j,  1j, 1], [X(0)@X(1), X(0)@Y(1), Y(0)@X(1), Y(0)@Y(1)]) where X = lambda wire: qml.PauliX(wire) and the same for Y. Additionally, since J^2 should give identity, I believe it can be written as [qml.Identity(n)@qml.Identity(n+1) for n in range(0, Nqubit, 2)] inside the hamiltonian with the proper constant in front. Tho, I\u2019m not sure if I can use qubit information as such. For instance, if I use 6D Hilbert space instead of 4, should I just extend the qubit structure, i.e. X(0)@X(1)@X(2), or should I change the entire formulation of my hamiltonian to have my raising and lowering operators in different basis?", "link": "https://discuss.pennylane.ai//t/converting-sigma-model-hamiltonian-into-a-circuit/1877/3"}, "3": {"author": "christina", "date": "1651865995163", "content": "Hi @jackaraz . Thanks for the question.  This seems really interesting.\nAs far as I can tell (though I may be misinterpreting the notation), the kinetic term is projectors:\n\n\\mathcal{H}^{0} = g^2 \\left( | T_1\\rangle\\langle T_1 | + \n| T_2 \\rangle\\langle T_2| + |T_3\\rangle\\langle T_3 |\n\\right)\n\nWe can see from this we recover the relationship in the paper:\n\nh_{1,1}^{0} = g^2  \\langle T_1| T_1 \\rangle \\langle T_1 | T_1 \\rangle = g^2\n\nThe question then is: What does this look like in terms of qubits on a quantum computer?\nIf we make the mapping:\n\n|T_0 \\rangle \\rightarrow |00\\rangle\n\n\n| T_1 \\rangle \\rightarrow | 0 1\\rangle\n\n\n| T_2 \\rangle \\rightarrow |1 0 \\rangle\n\n\n| T_3 \\rangle \\rightarrow | 11 \\rangle\n\nWe could express the kinetic hamiltonian as a sum of the projectors over those states:\nproj1 = qml.Projector([0,1], wires=(0,1))\nproj2 = qml.Projector([1,0], wires=(0,1))\nproj3 = qml.Projector([1,1], wires=(0,1))\n\nh = qml.Hamiltonian([g**2, g**2, g**2], [proj1, proj2, proj3])\n\nThis seems to be consistent with eq. 11 in the paper.\nThe expectation value of this Hamiltonian would be equivalent to measuring the probabilities and then summing over all but the first term:\n@qml.qnode(dev)\ndef circ():\n    return qml.probs(wires=(0,1))\n\ng**2 * sum(circ()[1:])\n\nI\u2019m still trying to figure out the interaction hamiltonian component. Hope this helps a little.1", "link": "https://discuss.pennylane.ai//t/converting-sigma-model-hamiltonian-into-a-circuit/1877/4"}, "4": {"author": "jackaraz", "date": "1652199964482", "content": "Hi @christina, thanks a lot for your answer! I have couple questions about your answer; I\u2019m assuming in your circ function you assumed an initial state otherthan |00\\rangle right? i.e.\n@qml.qnode(dev)\ndef circ():\n    qml.RY(np.random.uniform(0, np.pi, 1)[0], 0)\n    qml.RY(np.random.uniform(0, np.pi, 1)[0], 1)\n    return qml.probs(wires=(0,1))\n\nAlso I believe 2 qubit operators are not supported yet so the expectation value of the Hamiltonian that you wrote raises a following error;\nValueError: Can only compute sparse representation for tensors whose operations act on consecutive wires; got Projector([0, 1], wires=[0, 1]).\n\nAnd I can see that in the code this feature listed as todo:\nFile ~/pennylane/operation.py:2017, in Tensor.sparse_matrix(self, wires)\n   2014 for o in self.obs:\n   2015     if len(o.wires) > 1:\n   2016         # todo: deal with multi-qubit operations that do not act on consecutive qubits\n-> 2017         raise ValueError(\n   2018             f\"Can only compute sparse representation for tensors whose operations \"\n   2019             f\"act on consecutive wires; got {o}.\"\n   2020         )\n   2021     # store the single-qubit ops according to the order of their wires\n   2022     idx = wires.index(o.wires)\n\nSo I believe a workaround for now would be\nproj1 = qml.Projector([0], wires=(0)) @ qml.Projector([1], wires=(1))\nproj2 = qml.Projector([1], wires=(0)) @ qml.Projector([0], wires=(1))\nproj3 = qml.Projector([1], wires=(0)) @ qml.Projector([1], wires=(1))\n\nh = qml.Hamiltonian([g**2, g**2, g**2], [proj1, proj2, proj3])\n\n@qml.qnode(dev)\ndef circ():\n    qml.RY(np.random.uniform(-np.pi, np.pi, 1)[0], 0)\n    qml.RY(np.random.uniform(-np.pi, np.pi, 1)[0], 1)\n    return qml.expval(h)\n\nThanks a lot this was very helpful!", "link": "https://discuss.pennylane.ai//t/converting-sigma-model-hamiltonian-into-a-circuit/1877/5"}, "5": {"author": "christina", "date": "1652312488666", "content": "Glad you found a workaround.\nAnd yes, in my example I was just trying to show the expval part and left out state prep.", "link": "https://discuss.pennylane.ai//t/converting-sigma-model-hamiltonian-into-a-circuit/1877/6"}, "6": {"author": "jackaraz", "date": "1651590895096", "content": "Hi all, I would like to ask some specific questions (I\u2019m sorry its very specific, forgive me) about a paper I\u2019m reading. In 1903.06577, authors are playing with the sigma model hamiltonian, and they are showing how they constructed the time evolution circuit with respect to this hamiltonian. They are using four-dimensional Hilbert space (per site), so each site is defined via two-qubit. I was wondering how I can compute the expectation value of this hamiltonian on a quantum circuit instead of time evolution.\nSo for the interaction terms (please correct me if I\u2019m wrong), they are giving the  j_{1,2,3} j1,2,3 definition (eq. 8) so I believe it is correct to use that definition to form the hamiltonian i.e. j_1 = \\frac{\\mathbf{1}\\otimes\\sigma_2}{\\sqrt{3}} =j1=1\u2297\u03c32\u221a3= qml.Hamiltonian([1/np.sqrt(3.)], [qml.Identity(0) @ qml.PauliY(1)]). However, I\u2019m not sure about the kinetic term, they are converting everything into this new  T T basis they are using but without the conversion, (e.g. 1812.00944 eq 2), the kinetic term for the sigma model is  \\frac{1}{2\\beta}\\sum_k^3 J^2_k 12\u03b2\u22113kJ2k where J_kJk is the angular momentum operator. So would it be correct to write it as qml.Hamiltonian([(1/2*betta)*(hbar/2)**2]*3, [qml.PauliX(0) @ qml.PauliX(1), qml.PauliY(0) @ qml.PauliY(1), qml.PauliZ(0) @ qml.PauliZ(1)])? If I write the entire sum I believe this will give me an identity matrix with a phase. So if I write a simple circuit to calculate the expectation value for only the terms  k=0 k=0 in kinetic term (for simplicity) and first interaction term\nimport pennylane as qml\n\ndev = qml.device(\"default.qubit\", wires = 2)\n\n@qml.qnode(dev)\ndef circuit(): \n    # prepare an initial state (not important)\n    for wire in range(2):\n        qml.RY(np.pi/2., wire)\n\n    return qml.expval(qml.Hamiltonian([(1/2)**2, 1/np.sqrt(3.)], \n                                      [qml.PauliX(0) @ qml.PauliX(1), qml.Identity(0) @ qml.PauliY(1)]))\n\nWould this be correct? Any insight and/or reference is highly appreciated.\nThanks for your time", "link": "https://discuss.pennylane.ai//t/converting-sigma-model-hamiltonian-into-a-circuit/1877/7"}, "7": {"author": "jackaraz", "date": "1651739737112", "content": "Hi @CatalinaAlbornoz, thank you so very much!!\nIn the meantime, I was looking into other sources and I believe for the interaction terms I can use raising and lowering operators i.e. S^{\\pm} = \\sigma_x \\pm i\\sigma_yS\u00b1=\u03c3x\u00b1i\u03c3y and S_zSz so the full summation should be \\sum_n \\left( S^+_nS^-_{n+1} + S^-_nS^+_{n+1} + S^z_n S^z_{n+1} \\right)\u2211n(S+nS\u2212n+1+S\u2212nS+n+1+SznSzn+1) where nn indicates qubit here. So the first interaction term in the Hamiltonian, I believe, can be written as qml.Hamiltonian([1, -1j,  1j, 1], [X(0)@X(1), X(0)@Y(1), Y(0)@X(1), Y(0)@Y(1)]) where X = lambda wire: qml.PauliX(wire) and the same for Y. Additionally, since J^2J2 should give identity, I believe it can be written as [qml.Identity(n)@qml.Identity(n+1) for n in range(0, Nqubit, 2)] inside the hamiltonian with the proper constant in front. Tho, I\u2019m not sure if I can use qubit information as such. For instance, if I use 6D Hilbert space instead of 4, should I just extend the qubit structure, i.e. X(0)@X(1)@X(2), or should I change the entire formulation of my hamiltonian to have my raising and lowering operators in different basis?", "link": "https://discuss.pennylane.ai//t/converting-sigma-model-hamiltonian-into-a-circuit/1877/8"}, "8": {"author": "christina", "date": "1651865995163", "content": "Hi @jackaraz . Thanks for the question.  This seems really interesting.\nAs far as I can tell (though I may be misinterpreting the notation), the kinetic term is projectors:\n\n\\mathcal{H}^{0} = g^2 \\left( | T_1\\rangle\\langle T_1 | + \n| T_2 \\rangle\\langle T_2| + |T_3\\rangle\\langle T_3 |\n\\right)\nH0=g2(|T1\u27e9\u27e8T1|+|T2\u27e9\u27e8T2|+|T3\u27e9\u27e8T3|)\nWe can see from this we recover the relationship in the paper:\n\nh_{1,1}^{0} = g^2  \\langle T_1| T_1 \\rangle \\langle T_1 | T_1 \\rangle = g^2\nh01,1=g2\u27e8T1|T1\u27e9\u27e8T1|T1\u27e9=g2\nThe question then is: What does this look like in terms of qubits on a quantum computer?\nIf we make the mapping:\n\n|T_0 \\rangle \\rightarrow |00\\rangle\n|T0\u27e9\u2192|00\u27e9\n\n| T_1 \\rangle \\rightarrow | 0 1\\rangle\n|T1\u27e9\u2192|01\u27e9\n\n| T_2 \\rangle \\rightarrow |1 0 \\rangle\n|T2\u27e9\u2192|10\u27e9\n\n| T_3 \\rangle \\rightarrow | 11 \\rangle\n|T3\u27e9\u2192|11\u27e9\nWe could express the kinetic hamiltonian as a sum of the projectors over those states:\nproj1 = qml.Projector([0,1], wires=(0,1))\nproj2 = qml.Projector([1,0], wires=(0,1))\nproj3 = qml.Projector([1,1], wires=(0,1))\n\nh = qml.Hamiltonian([g**2, g**2, g**2], [proj1, proj2, proj3])\n\nThis seems to be consistent with eq. 11 in the paper.\nThe expectation value of this Hamiltonian would be equivalent to measuring the probabilities and then summing over all but the first term:\n@qml.qnode(dev)\ndef circ():\n    return qml.probs(wires=(0,1))\n\ng**2 * sum(circ()[1:])\n\nI\u2019m still trying to figure out the interaction hamiltonian component. Hope this helps a little.1", "link": "https://discuss.pennylane.ai//t/converting-sigma-model-hamiltonian-into-a-circuit/1877/9"}, "9": {"author": "jackaraz", "date": "1652199964482", "content": "Hi @christina, thanks a lot for your answer! I have couple questions about your answer; I\u2019m assuming in your circ function you assumed an initial state otherthan |00\\rangle|00\u27e9 right? i.e.\n@qml.qnode(dev)\ndef circ():\n    qml.RY(np.random.uniform(0, np.pi, 1)[0], 0)\n    qml.RY(np.random.uniform(0, np.pi, 1)[0], 1)\n    return qml.probs(wires=(0,1))\n\nAlso I believe 2 qubit operators are not supported yet so the expectation value of the Hamiltonian that you wrote raises a following error;\nValueError: Can only compute sparse representation for tensors whose operations act on consecutive wires; got Projector([0, 1], wires=[0, 1]).\n\nAnd I can see that in the code this feature listed as todo:\nFile ~/pennylane/operation.py:2017, in Tensor.sparse_matrix(self, wires)\n   2014 for o in self.obs:\n   2015     if len(o.wires) > 1:\n   2016         # todo: deal with multi-qubit operations that do not act on consecutive qubits\n-> 2017         raise ValueError(\n   2018             f\"Can only compute sparse representation for tensors whose operations \"\n   2019             f\"act on consecutive wires; got {o}.\"\n   2020         )\n   2021     # store the single-qubit ops according to the order of their wires\n   2022     idx = wires.index(o.wires)\n\nSo I believe a workaround for now would be\nproj1 = qml.Projector([0], wires=(0)) @ qml.Projector([1], wires=(1))\nproj2 = qml.Projector([1], wires=(0)) @ qml.Projector([0], wires=(1))\nproj3 = qml.Projector([1], wires=(0)) @ qml.Projector([1], wires=(1))\n\nh = qml.Hamiltonian([g**2, g**2, g**2], [proj1, proj2, proj3])\n\n@qml.qnode(dev)\ndef circ():\n    qml.RY(np.random.uniform(-np.pi, np.pi, 1)[0], 0)\n    qml.RY(np.random.uniform(-np.pi, np.pi, 1)[0], 1)\n    return qml.expval(h)\n\nThanks a lot this was very helpful!", "link": "https://discuss.pennylane.ai//t/converting-sigma-model-hamiltonian-into-a-circuit/1877/10"}}