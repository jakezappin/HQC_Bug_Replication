{"0": {"author": "omersajid9", "date": "1673828622972", "content": "I am getting a LinAlgError: Singular matrix when trying to run QNGOptimizer on my circuit.\nHere is the code for making the circuit and the hamiltonian:\ndev = qml.device(\"default.qubit\", wires=8)\nconnectivity = [(1, 2), (0, 6), (2, 3), (0, 7), (3, 4), (0, 1), (4, 5), (0, 2), (5, 6), (0, 3), (6, 7), (0, 4), (7, 1), (0, 5)]\n\ndef twoQubit(params, wires=8):\n    for (index, (i, j)) in enumerate(connectivity):\n        start = index * 15\n\n        qml.U3(params[start], params[start+1], params[start+2], wires=i)\n        qml.U3(params[start+3], params[start+4], params[start+5], wires=j)\n        \n        qml.CNOT(wires=[j, i])\n\n        qml.RZ(params[start+6], wires=i)\n        qml.RY(params[start+7], wires=j)\n\n        qml.CNOT(wires=[i, j])\n\n        qml.RY(params[start+8], wires=j)\n\n        qml.CNOT(wires=[j, i])\n\n        qml.U3(params[start+9], params[start+10], params[start+11], wires=i)\n        qml.U3(params[start+12], params[start+13], params[start+14], wires=j)\nop_list = [(qml.pauli.utils.string_to_pauli_word(singleEntry)) for singleEntry in returnStringObservable(1, 8)]\nH = qml.Hamiltonian([-1]*len(op_list), op_list)\n\n@qml.qnode(dev)\ndef cost_fn(params):\n    twoQubit(params)\n    return qml.expval(H)\ninit_params = np.array(np.random.normal(0, 0.1, 15*14), requires_grad=True)\n\nopt = qml.QNGOptimizer(stepsize=step_size, approx=\"block-diag\")\n\nopt.step_and_cost(cost_fn, init_params)\n\nThe error stack is:\n----> 3 opt.step_and_cost(cost_fn, init_params)\n\nFile ~\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.10_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python310\\site-packages\\pennylane\\optimize\\qng.py:204, in QNGOptimizer.step_and_cost(self, qnode, grad_fn, recompute_tensor, metric_tensor_fn, *args, **kwargs)\n    199     self.metric_tensor = self.metric_tensor + self.lam * qml.math.eye(\n    200         size, like=_metric_tensor\n    201     )\n    203 g, forward = self.compute_grad(qnode, args, kwargs, grad_fn=grad_fn)\n--> 204 new_args = np.array(self.apply_grad(g, args), requires_grad=True)\n    206 if forward is None:\n    207     forward = qnode(*args, **kwargs)\n\nFile ~\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.10_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python310\\site-packages\\pennylane\\optimize\\qng.py:278, in QNGOptimizer.apply_grad(self, grad, args)\n    276 grad_flat = np.array(list(_flatten(grad)))\n    277 x_flat = np.array(list(_flatten(args)))\n--> 278 x_new_flat = x_flat - self.stepsize * np.linalg.solve(self.metric_tensor, grad_flat)\n    279 return unflatten(x_new_flat, args)\n\nFile ~\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.10_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python310\\site-packages\\pennylane\\numpy\\wrapper.py:117, in tensor_wrapper.<locals>._wrapped(*args, **kwargs)\n    114         tensor_kwargs[\"requires_grad\"] = _np.any([i.requires_grad for i in tensor_args])\n    116 # evaluate the original object\n...\nFile ~\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.10_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python310\\site-packages\\numpy\\linalg\\linalg.py:89, in _raise_linalgerror_singular(err, flag)\n     88 def _raise_linalgerror_singular(err, flag):\n---> 89     raise LinAlgError(\"Singular matrix\")\n\nLinAlgError: Singular matrix\n\nThe optimizer runs well with other circuits but not this. I usually use qiskit but switched to pennylane because of its quantum natural gradient optimizer and would really appreciate any help here", "link": "https://discuss.pennylane.ai//t/qngoptimizer-linalgerr-singlular-matrix/2437/1"}, "1": {"author": "omersajid9", "date": "1673828753563", "content": "My hermitian looks as follows:\n  (-1) [X1]\n+ (-1) [X2]\n+ (-1) [X3]\n+ (-1) [X4]\n+ (-1) [X5]\n+ (-1) [X6]\n+ (-1) [X7]\n+ (-1) [Z1 Z2]\n+ (-1) [Z2 Z3]\n+ (-1) [Z3 Z4]\n+ (-1) [Z4 Z5]\n+ (-1) [Z5 Z6]\n+ (-1) [Z6 Z7]\n+ (-1) [Z1 Z7]\n", "link": "https://discuss.pennylane.ai//t/qngoptimizer-linalgerr-singlular-matrix/2437/2"}, "2": {"author": "CatalinaAlbornoz", "date": "1674505505143", "content": "Hi @omersajid9,\nIf you run print(np.round(qml.metric_tensor(cost_fn, approx=\"block-diag\")(init_params), 8)), you will see that the matrix corresponding to your qnode is in fact singular.\nIf you look at our demo here you will notice that the metric tensor is not singular.\nI think this might be an issue with how you use your parameters in your circuit. If you are able to simplify this you might find the root of the problem.\nFor instance, in the following circuit you will get a singular matrix because only the first parameter is being used:\ndev2 = qml.device('default.qubit',wires=2)\n\n@qml.qnode(dev2)\ndef circuit2(params):\n    qml.RX(params[0],wires=0)\n    qml.RY(params[0],wires=1)\n    return qml.expval(qml.PauliZ(0)@qml.PauliY(1))\n\ni_param = np.array([0.1,0.2],requires_grad=True)\nprint(qml.metric_tensor(circuit2, approx=\"block-diag\")(i_param))\n\nHowever if you change qml.RY(params[0],wires=1) to qml.RY(params[1],wires=1) your matrix is no longer singular.\nPlease let me know if this helps!", "link": "https://discuss.pennylane.ai//t/qngoptimizer-linalgerr-singlular-matrix/2437/3"}, "3": {"author": "omersajid9", "date": "1675893136436", "content": "Hi, thank you for your response. Yes, it fixes the issue sometimes but I have noticed that just applying a single qubit gate (for ex. H) on all qubits infront of my ansatz gets the circuit running. Is there any special reason for this?", "link": "https://discuss.pennylane.ai//t/qngoptimizer-linalgerr-singlular-matrix/2437/4"}, "4": {"author": "CatalinaAlbornoz", "date": "1675994299601", "content": "Hi @omersajid9,\nI\u2019m not sure why this is working for you. If you\u2019re not using all of your parameters then you probably still get a singular matrix. However, if you\u2019re adding parametrized gates where you use all of your parameters then maybe that\u2019s why this fixes your issue.\nIn any case I\u2019m glad you managed to solve your problem!", "link": "https://discuss.pennylane.ai//t/qngoptimizer-linalgerr-singlular-matrix/2437/5"}, "5": {"author": "omersajid9", "date": "1673828622972", "content": "I am getting a LinAlgError: Singular matrix when trying to run QNGOptimizer on my circuit.\nHere is the code for making the circuit and the hamiltonian:\ndev = qml.device(\"default.qubit\", wires=8)\nconnectivity = [(1, 2), (0, 6), (2, 3), (0, 7), (3, 4), (0, 1), (4, 5), (0, 2), (5, 6), (0, 3), (6, 7), (0, 4), (7, 1), (0, 5)]\n\ndef twoQubit(params, wires=8):\n    for (index, (i, j)) in enumerate(connectivity):\n        start = index * 15\n\n        qml.U3(params[start], params[start+1], params[start+2], wires=i)\n        qml.U3(params[start+3], params[start+4], params[start+5], wires=j)\n        \n        qml.CNOT(wires=[j, i])\n\n        qml.RZ(params[start+6], wires=i)\n        qml.RY(params[start+7], wires=j)\n\n        qml.CNOT(wires=[i, j])\n\n        qml.RY(params[start+8], wires=j)\n\n        qml.CNOT(wires=[j, i])\n\n        qml.U3(params[start+9], params[start+10], params[start+11], wires=i)\n        qml.U3(params[start+12], params[start+13], params[start+14], wires=j)\nop_list = [(qml.pauli.utils.string_to_pauli_word(singleEntry)) for singleEntry in returnStringObservable(1, 8)]\nH = qml.Hamiltonian([-1]*len(op_list), op_list)\n\n@qml.qnode(dev)\ndef cost_fn(params):\n    twoQubit(params)\n    return qml.expval(H)\ninit_params = np.array(np.random.normal(0, 0.1, 15*14), requires_grad=True)\n\nopt = qml.QNGOptimizer(stepsize=step_size, approx=\"block-diag\")\n\nopt.step_and_cost(cost_fn, init_params)\n\nThe error stack is:\n----> 3 opt.step_and_cost(cost_fn, init_params)\n\nFile ~\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.10_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python310\\site-packages\\pennylane\\optimize\\qng.py:204, in QNGOptimizer.step_and_cost(self, qnode, grad_fn, recompute_tensor, metric_tensor_fn, *args, **kwargs)\n    199     self.metric_tensor = self.metric_tensor + self.lam * qml.math.eye(\n    200         size, like=_metric_tensor\n    201     )\n    203 g, forward = self.compute_grad(qnode, args, kwargs, grad_fn=grad_fn)\n--> 204 new_args = np.array(self.apply_grad(g, args), requires_grad=True)\n    206 if forward is None:\n    207     forward = qnode(*args, **kwargs)\n\nFile ~\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.10_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python310\\site-packages\\pennylane\\optimize\\qng.py:278, in QNGOptimizer.apply_grad(self, grad, args)\n    276 grad_flat = np.array(list(_flatten(grad)))\n    277 x_flat = np.array(list(_flatten(args)))\n--> 278 x_new_flat = x_flat - self.stepsize * np.linalg.solve(self.metric_tensor, grad_flat)\n    279 return unflatten(x_new_flat, args)\n\nFile ~\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.10_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python310\\site-packages\\pennylane\\numpy\\wrapper.py:117, in tensor_wrapper.<locals>._wrapped(*args, **kwargs)\n    114         tensor_kwargs[\"requires_grad\"] = _np.any([i.requires_grad for i in tensor_args])\n    116 # evaluate the original object\n...\nFile ~\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.10_qbz5n2kfra8p0\\LocalCache\\local-packages\\Python310\\site-packages\\numpy\\linalg\\linalg.py:89, in _raise_linalgerror_singular(err, flag)\n     88 def _raise_linalgerror_singular(err, flag):\n---> 89     raise LinAlgError(\"Singular matrix\")\n\nLinAlgError: Singular matrix\n\nThe optimizer runs well with other circuits but not this. I usually use qiskit but switched to pennylane because of its quantum natural gradient optimizer and would really appreciate any help here", "link": "https://discuss.pennylane.ai//t/qngoptimizer-linalgerr-singlular-matrix/2437/6"}}