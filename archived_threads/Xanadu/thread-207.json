{"0": {"author": "contepablod", "date": "1686767682186", "content": "Hi! I am trying to minizime Ry Params of BasicEntanglerLayers with COBYLA optimizer. First, I used AmplitudeEmbedding which not allows gradient based optimizers as i infer from its warning.\n\nThis is the circuit:\n@qml.qnode(dev)\ndef circuit(features, weights):\n    qml.AmplitudeEmbedding(features=features, wires=range(0, NUM_LAT + NUM_TRASH), normalize=True, pad_with=features.flatten().shape[0])\n    qml.Barrier(wires=range(0,WIRES), only_visual=True)\n    qml.BasicEntanglerLayers(weights=weights, wires=range(0, NUM_LAT + NUM_TRASH), rotation=qml.RY)\n    qml.Barrier(wires=range(0,WIRES), only_visual=True)\n    qml.Hadamard(WIRES)\n    for i in range(NUM_REF):\n        qml.CSWAP(wires=[WIRES, NUM_LAT+i, NUM_LAT+NUM_TRASH+i])\n    qml.Hadamard(WIRES)\n    # Z Measure\n    return qml.probs(WIRES)\n\n\nThis is the cost function:\ndef cost(weights):\n    return np.mean(circuit(image, weights)[:,1])\n\n\nThis is the opt:\nopt_res = minimize(cost, initial_weights, method='COBYLA')\n\n\nThis is the traceback:\nValueError: Weights tensor must be 2-dimensional or 3-dimensional if batching; got shape (10,)\nSeems that COBYLA is flattening the weights tensor. BasicEntanglerLayers expects a weight tensor (layers, num_weights). In this example (1, 10).\n\nQML.about()\nqml.about().\nName: PennyLane\nVersion: 0.30.0\nSummary: PennyLane is a Python quantum machine learning library by Xanadu Inc.\nHome-page: GitHub - PennyLaneAI/pennylane: PennyLane is a cross-platform Python library for differentiable programming of quantum computers. Train a quantum computer the same way as a neural network.\nAuthor:\nAuthor-email:\nLicense: Apache License 2.0\nLocation: /home/contepablod/.local/lib/python3.10/site-packages\nRequires: appdirs, autograd, autoray, cachetools, networkx, numpy, pennylane-lightning, requests, rustworkx, scipy, semantic-version, toml\nRequired-by: PennyLane-Lightning, PennyLane-Lightning-GPU, PennyLane-qiskit\nPlatform info:           Linux-5.15.90.1-microsoft-standard-WSL2-x86_64-with-glibc2.35\nPython version:          3.10.6\nNumpy version:           1.23.5\nScipy version:           1.10.1\nInstalled devices:\n\nqiskit.aer (PennyLane-qiskit-0.30.1)\nqiskit.basicaer (PennyLane-qiskit-0.30.1)\nqiskit.ibmq (PennyLane-qiskit-0.30.1)\nqiskit.ibmq.circuit_runner (PennyLane-qiskit-0.30.1)\nqiskit.ibmq.sampler (PennyLane-qiskit-0.30.1)\ndefault.gaussian (PennyLane-0.30.0)\ndefault.mixed (PennyLane-0.30.0)\ndefault.qubit (PennyLane-0.30.0)\ndefault.qubit.autograd (PennyLane-0.30.0)\ndefault.qubit.jax (PennyLane-0.30.0)\ndefault.qubit.tf (PennyLane-0.30.0)\ndefault.qubit.torch (PennyLane-0.30.0)\ndefault.qutrit (PennyLane-0.30.0)\nnull.qubit (PennyLane-0.30.0)\nlightning.qubit (PennyLane-Lightning-0.30.0)\nlightning.gpu (PennyLane-Lightning-GPU-0.30.0)\n\nAny insights?\n\n\n Solved by contepablod in post #2 \n\n\n                Already solved, just passed to COBYLA initial_weights[0] and then reshaped inside the cost function to x = weights.reshape(1,10) being x the function parameters to allow the weights being processed by the circuit.\n              \n", "link": "https://discuss.pennylane.ai//t/pennylane-cobyla-integration/3051/1"}, "1": {"author": "contepablod", "date": "1686791447350", "content": "Already solved, just passed to COBYLA initial_weights[0] and then reshaped inside the cost function to x = weights.reshape(1,10) being x the function parameters to allow the weights being processed by the circuit.Solution1", "link": "https://discuss.pennylane.ai//t/pennylane-cobyla-integration/3051/2"}, "2": {"author": "isaacdevlugt", "date": "1686834423210", "content": "Thanks @contepablod! Glad you solved your problem ", "link": "https://discuss.pennylane.ai//t/pennylane-cobyla-integration/3051/3"}, "3": {"author": "contepablod", "date": "1686767682186", "content": "Hi! I am trying to minizime Ry Params of BasicEntanglerLayers with COBYLA optimizer. First, I used AmplitudeEmbedding which not allows gradient based optimizers as i infer from its warning.\n\nThis is the circuit:\n@qml.qnode(dev)\ndef circuit(features, weights):\n    qml.AmplitudeEmbedding(features=features, wires=range(0, NUM_LAT + NUM_TRASH), normalize=True, pad_with=features.flatten().shape[0])\n    qml.Barrier(wires=range(0,WIRES), only_visual=True)\n    qml.BasicEntanglerLayers(weights=weights, wires=range(0, NUM_LAT + NUM_TRASH), rotation=qml.RY)\n    qml.Barrier(wires=range(0,WIRES), only_visual=True)\n    qml.Hadamard(WIRES)\n    for i in range(NUM_REF):\n        qml.CSWAP(wires=[WIRES, NUM_LAT+i, NUM_LAT+NUM_TRASH+i])\n    qml.Hadamard(WIRES)\n    # Z Measure\n    return qml.probs(WIRES)\n\n\nThis is the cost function:\ndef cost(weights):\n    return np.mean(circuit(image, weights)[:,1])\n\n\nThis is the opt:\nopt_res = minimize(cost, initial_weights, method='COBYLA')\n\n\nThis is the traceback:\nValueError: Weights tensor must be 2-dimensional or 3-dimensional if batching; got shape (10,)\nSeems that COBYLA is flattening the weights tensor. BasicEntanglerLayers expects a weight tensor (layers, num_weights). In this example (1, 10).\n\nQML.about()\nqml.about().\nName: PennyLane\nVersion: 0.30.0\nSummary: PennyLane is a Python quantum machine learning library by Xanadu Inc.\nHome-page: GitHub - PennyLaneAI/pennylane: PennyLane is a cross-platform Python library for differentiable programming of quantum computers. Train a quantum computer the same way as a neural network.\nAuthor:\nAuthor-email:\nLicense: Apache License 2.0\nLocation: /home/contepablod/.local/lib/python3.10/site-packages\nRequires: appdirs, autograd, autoray, cachetools, networkx, numpy, pennylane-lightning, requests, rustworkx, scipy, semantic-version, toml\nRequired-by: PennyLane-Lightning, PennyLane-Lightning-GPU, PennyLane-qiskit\nPlatform info:           Linux-5.15.90.1-microsoft-standard-WSL2-x86_64-with-glibc2.35\nPython version:          3.10.6\nNumpy version:           1.23.5\nScipy version:           1.10.1\nInstalled devices:\n\nqiskit.aer (PennyLane-qiskit-0.30.1)\nqiskit.basicaer (PennyLane-qiskit-0.30.1)\nqiskit.ibmq (PennyLane-qiskit-0.30.1)\nqiskit.ibmq.circuit_runner (PennyLane-qiskit-0.30.1)\nqiskit.ibmq.sampler (PennyLane-qiskit-0.30.1)\ndefault.gaussian (PennyLane-0.30.0)\ndefault.mixed (PennyLane-0.30.0)\ndefault.qubit (PennyLane-0.30.0)\ndefault.qubit.autograd (PennyLane-0.30.0)\ndefault.qubit.jax (PennyLane-0.30.0)\ndefault.qubit.tf (PennyLane-0.30.0)\ndefault.qubit.torch (PennyLane-0.30.0)\ndefault.qutrit (PennyLane-0.30.0)\nnull.qubit (PennyLane-0.30.0)\nlightning.qubit (PennyLane-Lightning-0.30.0)\nlightning.gpu (PennyLane-Lightning-GPU-0.30.0)\n\nAny insights?\n\n\n Solved by contepablod in post #2 \n\n\n                Already solved, just passed to COBYLA initial_weights[0] and then reshaped inside the cost function to x = weights.reshape(1,10) being x the function parameters to allow the weights being processed by the circuit.\n              \n", "link": "https://discuss.pennylane.ai//t/pennylane-cobyla-integration/3051/4"}}