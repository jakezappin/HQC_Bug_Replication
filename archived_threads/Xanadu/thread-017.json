{"0": {"author": "Bmete7", "date": "1603733423621", "content": "Hi!\nI am working on a Quantum Neural Network using PennyLane with PyTorch interface,\nMy training data is a simple MNIST classical data, which I scale it to 4x4, My idea was to use AmplitudeEmbedding and encode the 16 features into a 4-qubit system and implement the rest of the network.\nHowever, AmplitudeEmbedding(Along with QubitStateVector) functions are non-differentiable and I am stuck here, what is causing this problem and how can I solve it?\nThe thing is, AngleEmbedding works fine, however that way I embed my features into 16-qubit system and it takes forever to optimize.\nOne quick note is, I do not actually want the AmplitudeEmbedding layer to be optimized, since it is only helping to create the quantum input. Therefore, I do not actually need this node within my autograd graph.\n#Error message: \nCannot differentiate with respect to argument(s) {'inputs[12]', 'inputs[0]', 'inputs[11]', 'inputs[2]', 'inputs[4]', 'inputs[5]', 'inputs[7]', 'inputs[3]', 'inputs[6]', 'inputs[9]', 'inputs[13]', 'inputs[10]', 'inputs[15]', 'inputs[14]', 'inputs[1]', 'inputs[8]'}\n\n#Code \nclass Net(nn.Module):\ndef __init__(self):\n    super(Net, self).__init__()\n\n    @qml.qnode(dev)\n    def my_circuit(inputs,weights):\n        self.embed(inputs)\n        \n        for i in range(n_qubits):\n            # implementation of the circuit\n        return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1)),qml.expval(qml.PauliZ(2)), qml.expval(qml.PauliZ(3))\n\n    @qml.template\n    def embed(self,inputs):\n        qml.QubitStateVector(inputs, wires = range(n_qubits))\n\n\n Solved by Tom_Bromley in post #2 \n\n\n                Hey @Bmete7, welcome to the forum! \nThis should be a case of setting the inputs argument to be a keyword argument, i.e., \ndef qcircuit(weights, inputs=False): \nThis syntax is designed to support the Autograd interface, where keyword arguments are treated as non-trainable. \nHere is an example that wo\u2026\n              \n", "link": "https://discuss.pennylane.ai//t/differentiation-with-amplitudeembedding/638/1"}, "1": {"author": "Tom_Bromley", "date": "1603742079877", "content": "Hey @Bmete7, welcome to the forum!\nThis should be a case of setting the inputs argument to be a keyword argument, i.e.,\ndef qcircuit(weights, inputs=False):\nThis syntax is designed to support the Autograd interface, where keyword arguments are treated as non-trainable.\nHere is an example that works:\nimport pennylane as qml\nimport torch\n\nqubits = 4\nlayers = 3\ndev = qml.device(\"default.qubit\", wires=qubits)\n\n@qml.qnode(dev, interface=\"torch\")\ndef qcircuit(weights, inputs=False):\n    qml.templates.AmplitudeEmbedding(inputs, wires=range(qubits), normalize=True)\n    qml.templates.StronglyEntanglingLayers(weights, wires=range(qubits))\n    return [qml.expval(qml.PauliZ(i)) for i in range(qubits)]\n\n\nweights = torch.tensor(qml.init.strong_ent_layers_uniform(layers, qubits), requires_grad=True)\nimages = torch.ones(16)\n\nout = torch.sum(qcircuit(weights, inputs=images))\nout.backward()\n\nprint(weights.grad)\nprint(images.grad)\nSolution1", "link": "https://discuss.pennylane.ai//t/differentiation-with-amplitudeembedding/638/2"}, "2": {"author": "Bmete7", "date": "1603752568248", "content": "Thank you very much for a very quick response @Tom_Bromley !\nAnd you were right, I completely missed the need for using a keyword argument with AmplitudeEmbeddings. Now the code is working alright.\nI am quite new to the QML area, and I should say it is really exciting to be a part of such a great community!1", "link": "https://discuss.pennylane.ai//t/differentiation-with-amplitudeembedding/638/3"}, "3": {"author": "Bmete7", "date": "1603733423621", "content": "Hi!\nI am working on a Quantum Neural Network using PennyLane with PyTorch interface,\nMy training data is a simple MNIST classical data, which I scale it to 4x4, My idea was to use AmplitudeEmbedding and encode the 16 features into a 4-qubit system and implement the rest of the network.\nHowever, AmplitudeEmbedding(Along with QubitStateVector) functions are non-differentiable and I am stuck here, what is causing this problem and how can I solve it?\nThe thing is, AngleEmbedding works fine, however that way I embed my features into 16-qubit system and it takes forever to optimize.\nOne quick note is, I do not actually want the AmplitudeEmbedding layer to be optimized, since it is only helping to create the quantum input. Therefore, I do not actually need this node within my autograd graph.\n#Error message: \nCannot differentiate with respect to argument(s) {'inputs[12]', 'inputs[0]', 'inputs[11]', 'inputs[2]', 'inputs[4]', 'inputs[5]', 'inputs[7]', 'inputs[3]', 'inputs[6]', 'inputs[9]', 'inputs[13]', 'inputs[10]', 'inputs[15]', 'inputs[14]', 'inputs[1]', 'inputs[8]'}\n\n#Code \nclass Net(nn.Module):\ndef __init__(self):\n    super(Net, self).__init__()\n\n    @qml.qnode(dev)\n    def my_circuit(inputs,weights):\n        self.embed(inputs)\n        \n        for i in range(n_qubits):\n            # implementation of the circuit\n        return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1)),qml.expval(qml.PauliZ(2)), qml.expval(qml.PauliZ(3))\n\n    @qml.template\n    def embed(self,inputs):\n        qml.QubitStateVector(inputs, wires = range(n_qubits))\n\n\n Solved by Tom_Bromley in post #2 \n\n\n                Hey @Bmete7, welcome to the forum! \nThis should be a case of setting the inputs argument to be a keyword argument, i.e., \ndef qcircuit(weights, inputs=False): \nThis syntax is designed to support the Autograd interface, where keyword arguments are treated as non-trainable. \nHere is an example that wo\u2026\n              \n", "link": "https://discuss.pennylane.ai//t/differentiation-with-amplitudeembedding/638/4"}}