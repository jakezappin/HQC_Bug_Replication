{"0": {"author": "EMY91", "date": "1553719435080", "content": "I created a quantum node with this circuit:\ndef single_input_circuit(params, x):\nqml.Displacement(x[0], 0, wires=0)\nqml.RY(params[0], wires=0)\nreturn qml.expval.PauliZ(0)\nbut I got this error\nQuantumFunctionError: Continuous and discrete operations are not allowed in the same quantum circuit.\nI don\u2019t understand why??", "link": "https://discuss.pennylane.ai//t/quantumfunctionerror/108/1"}, "1": {"author": "josh", "date": "1553734433557", "content": "Hi @EMY91,\nIn PennyLane, we support two main models of quantum computation:\n\n\nDiscrete variables\n\nThis is the model simulated by 'default.qubit', as well as the qiskit, Forest, and ProjectQ plugins.\nThis model supports specific operations and expectation values:\nClick here for a full list of discrete operations 9\nClick here for a full list of discrete expectation values 7\n\n\n\n\n\n\n\nContinuous variables\n\nThis is the model simulated by 'default.gaussian', as well as the Strawberry Fields plugin.\nThis model supports specific operations and expectation values:\nClick here for a full list of discrete operations 9\nClick here for a full list of discrete expectation values 7\n\n\n\n\n\nThere are several important things to note here:\n\n\nYou cannot mix continuous and discrete operations in the same QNode.\nIn your case, you are using qml.Displacement (a continuous operation) as well as qml.RY (a discrete operation) and qml.expval.PauliZ (a discrete expectation)\n\n\nIf the QNode device is a continuous device, you must use only continuous operations. Likewise, if your QNode device is a discrete device, you must use only discrete operations.\nFor example, default.qubit can use qml.RY, but not qml.Displacement.\n\n\nI hope that helps, let me know if you have any other questions.1", "link": "https://discuss.pennylane.ai//t/quantumfunctionerror/108/2"}, "2": {"author": "sassan_moradi", "date": "1613139917768", "content": "I think this a weakness of Pennylane. i encountered the same problem in Pennylane:\n@qml.qnode(dev)\ndef circuit(x1, x2):\nqml.Hadamard(wires=0)\n\n\nqml.RX(2*pi, wires=[0]) #first gate\nqml.RX(pi, wires=[1])\n\nqml.RX(2*pi, wires=[0]) #second gate\nqml.RX(pi, wires=[2])\n\nqml.RX(2*pi, wires=[0]) #third gate\nqml.RX(pi, wires=[3])\n\nqml.templates.MottonenStatePreparation(x1, wires=[1, 2, 3])\n\nqml.RX(2*pi, wires=[0]) #first gate\nqml.RX(pi, wires=[3])\n\nqml.RX(2*pi, wires=[0]) #second gate\nqml.RX(pi, wires=[2])\n\nqml.RX(2*pi, wires=[0]) #first gate\nqml.RX(pi, wires=[1])\n\nqml.X(wires=0)\n\n\nqml.RX(2*pi, wires=[0]) #first gate\nqml.RX(pi, wires=[1])\n\nqml.RX(2*pi, wires=[0]) #second gate\nqml.RX(pi, wires=[2])\n\nqml.RX(2*pi, wires=[0]) #third gate\nqml.RX(pi, wires=[3])\n\nqml.templates.MottonenStatePreparation(x2, wires=[1, 2, 3])\n\nqml.RX(2*pi, wires=[0]) #first gate\nqml.RX(pi, wires=[3])\n\nqml.RX(2*pi, wires=[0]) #second gate\nqml.RX(pi, wires=[2])\n\nqml.RX(2*pi, wires=[0]) #first gate\nqml.RX(pi, wires=[1])\n\nqml.X(wires=0)\n\nqml.Hadamard(wires=0)\n\nreturn qml.expval(qml.PauliZ(0))", "link": "https://discuss.pennylane.ai//t/quantumfunctionerror/108/3"}, "3": {"author": "theodor", "date": "1613159989417", "content": "Hi @sassan_moradi,\nYes, this circuit wouldn\u2019t be possible to run due to using the continuous variable operation qml.X with other qubit operations. I hope my reply in the other thread 3 can help you out. Otherwise, feel free to keep asking us questions.", "link": "https://discuss.pennylane.ai//t/quantumfunctionerror/108/4"}, "4": {"author": "sassan_moradi", "date": "1613234711192", "content": "i solved the problem. Thanks.1", "link": "https://discuss.pennylane.ai//t/quantumfunctionerror/108/5"}, "5": {"author": "theodor", "date": "1613489230945", "content": "That\u2019s great! Let us know if you have any other issues or questions!", "link": "https://discuss.pennylane.ai//t/quantumfunctionerror/108/6"}, "6": {"author": "sassan_moradi", "date": "1613565021036", "content": "@qml.qnode(dev)\ndef circuit1(x1, x2):\n    \n    qml.Hadamard(wires=0)\n    \n    qml.U3(2*pi, 0, 0, wires=[0])  #first gate\n    qml.U3(pi, -pi/2, pi/2, wires=[1])\n    \n    qml.U3(2*pi, 0, 0, wires=[0])  #second gate\n    qml.U3(pi, -pi/2, pi/2, wires=[2])\n    \n    qml.U3(2*pi, 0, 0, wires=[0])  #third gate\n    qml.U3(pi, -pi/2, pi/2, wires=[3])\n    \n    #qml.U3(2*pi, 0, 0, wires=[0])  #fourth\n    #qml.U3(pi, -pi/2, pi/2, wires=[4])\n    \n    #qml.U3(2*pi, 0, 0, wires=[0])  #fifth gate\n    #qml.U3(pi, -pi/2, pi/2, wires=[5])\n    \n\n    qml.templates.MottonenStatePreparation(x1, wires=[1, 2, 3])\n    \n    #qml.U3(2*pi, 0, 0, wires=[0])  #first gate\n    #qml.U3(pi, -pi/2, pi/2, wires=[5])\n    \n    #qml.U3(2*pi, 0, 0, wires=[0])  #second gate\n    #qml.U3(pi, -pi/2, pi/2, wires=[4])\n    \n    qml.U3(2*pi, 0, 0, wires=[0])  #third gate\n    qml.U3(pi, -pi/2, pi/2, wires=[3])\n    \n    qml.U3(2*pi, 0, 0, wires=[0])  #fourth gate\n    qml.U3(pi, -pi/2, pi/2, wires=[2])\n    \n    qml.U3(2*pi, 0, 0, wires=[0])  #fifth gate\n    qml.U3(pi, -pi/2, pi/2, wires=[1])\n    \n    \n    \n    qml.U3(pi, 0, pi, wires=0)\n    \n    \n    qml.U3(2*pi, 0, 0, wires=[0])  #first gate\n    qml.U3(pi, -pi/2, pi/2, wires=[1])\n    \n    qml.U3(2*pi, 0, 0, wires=[0])  #second gate\n    qml.U3(pi, -pi/2, pi/2, wires=[2])\n    \n    qml.U3(2*pi, 0, 0, wires=[0])  #third gate\n    qml.U3(pi, -pi/2, pi/2, wires=[3])\n    \n    #qml.U3(2*pi, 0, 0, wires=[0])  #fourth\n    #qml.U3(pi, -pi/2, pi/2, wires=[4])\n    \n    #qml.U3(2*pi, 0, 0, wires=[0])  #fifth gate\n    #qml.U3(pi, -pi/2, pi/2, wires=[5])\n    \n   \n    qml.templates.MottonenStatePreparation(x2, wires=[1, 2, 3])\n    \n    #qml.U3(2*pi, 0, 0, wires=[0])  #first gate\n    #qml.U3(pi, -pi/2, pi/2, wires=[5])\n    \n    #qml.U3(2*pi, 0, 0, wires=[0])  #second gate\n    #qml.U3(pi, -pi/2, pi/2, wires=[4])\n    \n    qml.U3(2*pi, 0, 0, wires=[0])  #third gate\n    qml.U3(pi, -pi/2, pi/2, wires=[3])\n    \n    qml.U3(2*pi, 0, 0, wires=[0])  #fourth gate\n    qml.U3(pi, -pi/2, pi/2, wires=[2])\n    \n    qml.U3(2*pi, 0, 0, wires=[0])  #fifth gate \n    qml.U3(pi, -pi/2, pi/2, wires=[1])\n    \n    qml.U3(pi, 0, pi, wires=0)\n    \n    qml.Hadamard(wires=0)\n\n    return qml.expval(qml.PauliZ(0))\n\ni had to use u3 gate.", "link": "https://discuss.pennylane.ai//t/quantumfunctionerror/108/7"}, "7": {"author": "theodor", "date": "1613590990111", "content": "Thanks for sharing your code @sassan_moradi. I\u2019m glad you solved it!", "link": "https://discuss.pennylane.ai//t/quantumfunctionerror/108/8"}, "8": {"author": "EMY91", "date": "1553719435080", "content": "I created a quantum node with this circuit:\ndef single_input_circuit(params, x):\nqml.Displacement(x[0], 0, wires=0)\nqml.RY(params[0], wires=0)\nreturn qml.expval.PauliZ(0)\nbut I got this error\nQuantumFunctionError: Continuous and discrete operations are not allowed in the same quantum circuit.\nI don\u2019t understand why??", "link": "https://discuss.pennylane.ai//t/quantumfunctionerror/108/9"}}