{"0": {"author": "sdas", "date": "1681402724182", "content": "Hi, I am trying to encode two different quantum states to two different set of qubits in Pennylane circuit using @merge_amplitude_embedding. My code is the following:\n\nimport pennylane as qml\nfrom pennylane.templates.embeddings import AmplitudeEmbedding\nfrom pennylane.transforms import merge_amplitude_embedding\ndef Outcome(params):\n@merge_amplitude_embedding\ndef qfunc(params):\n    qml.AmplitudeEmbedding([0,1,0,0], wires = [0,1])\n    qml.AmplitudeEmbedding([0,1], wires = 2)\n    \n    qml.RX(params[0], wires=0)\n    qml.IsingXX(params[1], wires=[0,1])\n\n    \n    return qml.probs(wires = 1)\n\ndev = qml.device(\"default.qubit\", wires = 3)\nqnode = qml.QNode(qfunc(params), dev)\nqnode()\nprint(qnode)\n\n\n\nx = Outcome([0.5, 0.3])\nprint(x)\n\nWhen I run it, I get the following error:\nTraceback (most recent call last):\nFile \u201c/home/sreetama/Downloads/QCNN-main/symmetric_QCNN/RGB/merge_encoding_test.py\u201d, line 23, in \nx = Outcome([0.5, 0.3])\nFile \u201c/home/sreetama/Downloads/QCNN-main/symmetric_QCNN/RGB/merge_encoding_test.py\u201d, line 19, in Outcome\nqnode = qml.QNode(qfunc(params), dev)\nFile \u201c/home/sreetama/anaconda3/lib/python3.9/site-packages/pennylane/qnode.py\u201d, line 373, in init\nif \u201cshots\u201d in inspect.signature(func).parameters:\nFile \u201c/home/sreetama/anaconda3/lib/python3.9/inspect.py\u201d, line 3111, in signature\nreturn Signature.from_callable(obj, follow_wrapped=follow_wrapped)\nFile \u201c/home/sreetama/anaconda3/lib/python3.9/inspect.py\u201d, line 2860, in from_callable\nreturn _signature_from_callable(obj, sigcls=cls,\nFile \u201c/home/sreetama/anaconda3/lib/python3.9/inspect.py\u201d, line 2259, in _signature_from_callable\nraise TypeError(\u2018{!r} is not a callable object\u2019.format(obj))\nTypeError: probs(wires=[1]) is not a callable object\nHow to eliminate it? Any help is appreciated.\n\n\n Solved by isaacdevlugt in post #2 \n\n\n                Hey @sdas! Welcome to the forum ! \nI think there\u2019s just a small misunderstanding regarding how wrapping works. The line \nqnode = qml.QNode(qfunc(params), dev)\n\nis problematic because qfunc is the function you want to wrap as a QNode, but you are passing in the output of qfunc given the params, which\u2026\n              \n", "link": "https://discuss.pennylane.ai//t/multiple-amplitude-encoding-in-one-circuit-and-printing-the-expectation-value/2835/1"}, "1": {"author": "isaacdevlugt", "date": "1681480033330", "content": "Hey @sdas! Welcome to the forum !\nI think there\u2019s just a small misunderstanding regarding how wrapping works. The line\nqnode = qml.QNode(qfunc(params), dev)\n\nis problematic because qfunc is the function you want to wrap as a QNode, but you are passing in the output of qfunc given the params, which is not a function \u2014 it\u2019s a scalar! This is at the heart of the error you\u2019re seeing.\nHere\u2019s the solution:\nimport pennylane as qml\nfrom pennylane.transforms import merge_amplitude_embedding\n\n@merge_amplitude_embedding\ndef qfunc(params):\n    qml.AmplitudeEmbedding([0,1,0,0], wires = [0,1])\n    qml.AmplitudeEmbedding([0,1], wires = 2)\n    qml.RX(params[0], wires=0)\n    qml.IsingXX(params[1], wires=[0,1])\n    return qml.probs(wires = [1])\n\ndev = qml.device(\"default.qubit\", wires = 3)\nqnode = qml.QNode(qfunc, dev)\nprint(qnode([0.5, 0.3]))\n# [0.02233176 0.97766824]\n\nNote:\nqnode = qml.QNode(qfunc, dev) # qfunc is the function you want to wrap.\n2 RepliesSolution", "link": "https://discuss.pennylane.ai//t/multiple-amplitude-encoding-in-one-circuit-and-printing-the-expectation-value/2835/2"}, "2": {"author": "isaacdevlugt", "date": "1681480124989", "content": "I should say also that you can alleviate any confusion here by decorating with @qml.qnode as well:\nimport pennylane as qml\nfrom pennylane.transforms import merge_amplitude_embedding\n\ndev = qml.device(\"default.qubit\", wires = 3)\n\n@qml.qnode(dev)\n@merge_amplitude_embedding\ndef qfunc(params):\n    qml.AmplitudeEmbedding([0,1,0,0], wires = [0,1])\n    qml.AmplitudeEmbedding([0,1], wires = 2)\n    qml.RX(params[0], wires=0)\n    qml.IsingXX(params[1], wires=[0,1])\n    return qml.probs(wires = [1])\n\nprint(qnode([0.5, 0.3]))\n", "link": "https://discuss.pennylane.ai//t/multiple-amplitude-encoding-in-one-circuit-and-printing-the-expectation-value/2835/3"}, "3": {"author": "sdas", "date": "1681483936676", "content": "Thank you very much, it solved my issue!", "link": "https://discuss.pennylane.ai//t/multiple-amplitude-encoding-in-one-circuit-and-printing-the-expectation-value/2835/4"}, "4": {"author": "isaacdevlugt", "date": "1681484822161", "content": "Awesome! Glad to hear ", "link": "https://discuss.pennylane.ai//t/multiple-amplitude-encoding-in-one-circuit-and-printing-the-expectation-value/2835/5"}, "5": {"author": "sdas", "date": "1681402724182", "content": "Hi, I am trying to encode two different quantum states to two different set of qubits in Pennylane circuit using @merge_amplitude_embedding. My code is the following:\n\nimport pennylane as qml\nfrom pennylane.templates.embeddings import AmplitudeEmbedding\nfrom pennylane.transforms import merge_amplitude_embedding\ndef Outcome(params):\n@merge_amplitude_embedding\ndef qfunc(params):\n    qml.AmplitudeEmbedding([0,1,0,0], wires = [0,1])\n    qml.AmplitudeEmbedding([0,1], wires = 2)\n    \n    qml.RX(params[0], wires=0)\n    qml.IsingXX(params[1], wires=[0,1])\n\n    \n    return qml.probs(wires = 1)\n\ndev = qml.device(\"default.qubit\", wires = 3)\nqnode = qml.QNode(qfunc(params), dev)\nqnode()\nprint(qnode)\n\n\n\nx = Outcome([0.5, 0.3])\nprint(x)\n\nWhen I run it, I get the following error:\nTraceback (most recent call last):\nFile \u201c/home/sreetama/Downloads/QCNN-main/symmetric_QCNN/RGB/merge_encoding_test.py\u201d, line 23, in \nx = Outcome([0.5, 0.3])\nFile \u201c/home/sreetama/Downloads/QCNN-main/symmetric_QCNN/RGB/merge_encoding_test.py\u201d, line 19, in Outcome\nqnode = qml.QNode(qfunc(params), dev)\nFile \u201c/home/sreetama/anaconda3/lib/python3.9/site-packages/pennylane/qnode.py\u201d, line 373, in init\nif \u201cshots\u201d in inspect.signature(func).parameters:\nFile \u201c/home/sreetama/anaconda3/lib/python3.9/inspect.py\u201d, line 3111, in signature\nreturn Signature.from_callable(obj, follow_wrapped=follow_wrapped)\nFile \u201c/home/sreetama/anaconda3/lib/python3.9/inspect.py\u201d, line 2860, in from_callable\nreturn _signature_from_callable(obj, sigcls=cls,\nFile \u201c/home/sreetama/anaconda3/lib/python3.9/inspect.py\u201d, line 2259, in _signature_from_callable\nraise TypeError(\u2018{!r} is not a callable object\u2019.format(obj))\nTypeError: probs(wires=[1]) is not a callable object\nHow to eliminate it? Any help is appreciated.\n\n\n Solved by isaacdevlugt in post #2 \n\n\n                Hey @sdas! Welcome to the forum ! \nI think there\u2019s just a small misunderstanding regarding how wrapping works. The line \nqnode = qml.QNode(qfunc(params), dev)\n\nis problematic because qfunc is the function you want to wrap as a QNode, but you are passing in the output of qfunc given the params, which\u2026\n              \n", "link": "https://discuss.pennylane.ai//t/multiple-amplitude-encoding-in-one-circuit-and-printing-the-expectation-value/2835/6"}}