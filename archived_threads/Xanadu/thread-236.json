{"0": {"author": "roysuman088", "date": "1675190737091", "content": "Hi, I try to use QAOA for max cut problem for 18 nodes graph. I try to follow the similar startegey of QAOA mentioned in codebook but it takes too long to reponse. So, I try to implement it using JAX for 4nodes as similar to QAOA codebbok code but using JAX, but find some issue related to arraybox element and JAX type mismatch. Can you please guide me to resolve it?", "link": "https://discuss.pennylane.ai//t/qaoa-implementation-with-jax-for-max-cut-problem/2484/1"}, "1": {"author": "CatalinaAlbornoz", "date": "1675383891362", "content": "Hi @roysuman088, welcome to the Forum!\nCan you please post a minimal version of your code that I can run to see if I can replicate your error?\nAlso please post the output of qml.about() and the full error traceback.\nArraybox issues sometimes happen when you\u2019re trying to update global variables or when you\u2019re using ._value\nHowever I would need to see your code in order to have a better idea of what can be wrong.", "link": "https://discuss.pennylane.ai//t/qaoa-implementation-with-jax-for-max-cut-problem/2484/2"}, "2": {"author": "roysuman088", "date": "1675435819511", "content": "#import libraries\nimport pennylane as qml\nfrom pennylane import numpy as np\nfrom jax.config import config\nconfig.update(\u201cjax_enable_x64\u201d, True)\nimport jax\nimport jax.numpy as jnp\nimport optax\nfrom functools import partial\nnp.random.seed(42)\ndef main(graph, n_wires, offset):\n# unitary operator U_B with parameter beta\ndef U_B(beta):\n    for wire in range(n_wires):\n        qml.RX(2 * beta, wires=wire)\n\n# unitary operator U_C with parameter gamma\ndef U_C(gamma):\n    for edge in graph:\n        wire1 = edge[0]\n        wire2 = edge[1]\n        qml.CNOT(wires=[wire1, wire2])\n        qml.RZ(gamma, wires=wire2)\n        qml.CNOT(wires=[wire1, wire2])\n\ndef bitstring_to_int(bit_string_sample):\n    bit_string = \"\".join(str(bs) for bs in bit_string_sample)\n    return int(bit_string, base=2)\n\ndev = qml.device(\"lightning.qubit\", wires=n_wires, shots=1)\n\n@partial(jax.jit, static_argnums=(2,3))\n@qml.qnode(dev, interface='jax')\ndef circuit(gammas, betas, edge, n_layers):\n    # apply Hadamards to get the n qubit |+> state\n    for wire in range(n_wires):\n        qml.Hadamard(wires=wire)\n    # p instances of unitary operators\n    for i in range(n_layers):\n        U_C(gammas[i])\n        U_B(betas[i])\n    if edge is None:\n        # measurement phase\n        return qml.sample()\n    # during the optimization phase we are evaluating a term\n    # in the objective using expval\n    H = qml.PauliZ(wires=edge[0]) @ qml.PauliZ(wires=edge[1])\n    return qml.expval(H)\n\n\ndef cost(gammas, betas, edge, n_layers):\n    return circuit(gammas, betas, edge, n_layers)\n\ndef qaoa_maxcut(n_layers=1):\n    print(\"\\np={:d}\".format(n_layers))\n\n    # initialize the parameters near zero\n    init_params = jnp.array(0.01 * np.random.rand(2, n_layers))\n\n    # minimize the negative of the objective function\n    def objective(params):\n        gammas = params[0]\n        betas = params[1]\n        neg_obj = 0\n        for edge in graph:\n            # objective for the MaxCut problem\n            neg_obj -= 0.5 * edge[2] * (1 - cost(gammas, betas, edge=edge, n_layers=n_layers))\n        neg_obj-=offset\n        return neg_obj\n\n    # initialize optimizer: Adagrad works well empirically\n    opt = optax.adam(0.2)\n\n    # optimize parameters in objective\n    params = init_params\n    opt_state = opt.init(init_params)\n    steps = 1500\n    for i in range(steps):\n        grads = jax.grad(objective)(params)\n        updates, opt_state = opt.update(grads, opt_state)\n        params = optax.apply_updates(params, updates)\n        if (i + 1) % 5 == 0:\n            print(\"Objective after step {:5d}: {: .7f}\".format(i + 1, -objective(params)))\n    \n    # sample measured bitstrings 100 times\n    bit_strings = []\n    n_samples = 100\n    for i in range(0, n_samples):\n        bit_strings.append(bitstring_to_int(circuit(params[0], params[1], edge=None, n_layers=n_layers)))\n\n    # print optimal parameters and most frequently sampled bitstring\n    counts = np.bincount(np.array(bit_strings))\n    most_freq_bit_string = np.argmax(counts)\n    print(\"Optimized (gamma, beta) vectors:\\n{}\".format(params[:, :n_layers]))\n    print(\"Most frequently sampled bit string is: {:04b}\".format(most_freq_bit_string))\n\n    return -objective(params), bit_strings, most_freq_bit_string\n\nbitstrings = qaoa_maxcut(n_layers=1)\nbitstrings1, most_freq_bit_string_1 = bitstrings[1], bitstrings[2]\nmost_freq_bit_string_1=(\"{:0\"+str(n_wires)+\"b}\").format(most_freq_bit_string_1)\n\nbitstrings2 = qaoa_maxcut(n_layers=2)\nbitstrings2, most_freq_bit_string_2 = bitstrings2[1], bitstrings2[2]\nmost_freq_bit_string_2=(\"{:0\"+str(n_wires)+\"b}\").format(most_freq_bit_string_2)\nreturn most_freq_bit_string_1,most_freq_bit_string_2\n\ngraph=[(0, 1, 1), (0, 3, 0), (0, 9, 10), (0, 10, 0), (1, 2, 1), (1, 4, 0), (1, 9, 10), (1, 10, 0), (2, 5, 0), (2, 9, 10), (2, 10, 0), (3, 4, 1), (3, 6, 1), (3, 9, 0), (3, 10, -10), (4, 5, 1), (4, 7, 1), (4, 9, 0), (4, 10, -10), (5, 8, 1), (5, 9, 0), (5, 10, -10), (6, 7, 1), (6, 9, 0), (6, 10, -10), (7, 8, 1), (7, 9, 0), (7, 10, -10), (8, 9, 0), (8, 10, -10)]\nHi @CatalinaAlbornoz, I actually working on the Max cut problem using JAX for higher number of nodes. For the time being, the above code is working fine, just the graph itself is not taking each edge as a list but it allows it as a tuple. Can you check on that part, also if I want to execute more than 20 nodes graph, is it possible to do? Can you highlight any suggestions related to it? Even Im using JAX, it still takes quite a long time along with lightning.qubit, can you suggest something on it.\nThanks for your response.", "link": "https://discuss.pennylane.ai//t/qaoa-implementation-with-jax-for-max-cut-problem/2484/3"}, "3": {"author": "CatalinaAlbornoz", "date": "1675896443082", "content": "Hi @roysuman088,\nThis system is very big so it will inevitably take a long time. Using JAX and lightning is the right approach though.\nOne additional thing that might help is setting the differentiation method to \u2018adjoint\u2019. You can specify it when you define your qnode.\n@qml.qnode(dev, diff_method='adjoint', interface='jax')\nPlease let me know if this helps!", "link": "https://discuss.pennylane.ai//t/qaoa-implementation-with-jax-for-max-cut-problem/2484/4"}, "4": {"author": "roysuman088", "date": "1676184679370", "content": "Thanks @CatalinaAlbornoz \u2026will look into it", "link": "https://discuss.pennylane.ai//t/qaoa-implementation-with-jax-for-max-cut-problem/2484/5"}, "5": {"author": "roysuman088", "date": "1675190737091", "content": "Hi, I try to use QAOA for max cut problem for 18 nodes graph. I try to follow the similar startegey of QAOA mentioned in codebook but it takes too long to reponse. So, I try to implement it using JAX for 4nodes as similar to QAOA codebbok code but using JAX, but find some issue related to arraybox element and JAX type mismatch. Can you please guide me to resolve it?", "link": "https://discuss.pennylane.ai//t/qaoa-implementation-with-jax-for-max-cut-problem/2484/6"}}