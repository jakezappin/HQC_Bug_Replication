{"0": {"author": "Afrah", "date": "1678352365312", "content": "How can I apply Hadamard to a list of qubits without using loops like that in qiskit.\nn_bits = 4\ndev = qml.device(\"default.qubit\", wires=n_bits)\n\n@qml.qnode(dev)\ndef appLyHadamard():\n    qml.Hadamard(wires=dev.wires) \n# without using this    ' for wire in dev.wires:      qml.Hadamard(wires =wire)'\n    return qml.state()\n\nr = appLyHadamard()\n\n\nI got this error:\n\nValueError                                Traceback (most recent call last)\n/tmp/ipykernel_51/3241397786.py in <cell line: 1>()\n----> 1 r = appLyHadamard()\n/opt/conda/envs/pennylane/lib/python3.9/site-packages/pennylane/qnode.py in call(self, *args, **kwargs)\n798\n799         # construct the tape\n \u2192 800         self.construct(args, kwargs)\n801\n802         cache = self.execute_kwargs.get(\u201ccache\u201d, False)\n/opt/conda/envs/pennylane/lib/python3.9/site-packages/pennylane/qnode.py in construct(self, args, kwargs)\n709         \u201c\u201d\u201cCall the quantum function with a tape context, ensuring the operations get queued.\u201d\u201c\u201d\n710\n \u2192 711         self._tape = make_qscript(self.func)(*args, **kwargs)\n712         self._tape._queue_category = \u201c_ops\u201d\n713         self._qfunc_output = self.tape._qfunc_output\n/opt/conda/envs/pennylane/lib/python3.9/site-packages/pennylane/tape/qscript.py in wrapper(*args, **kwargs)\n1344     def wrapper(*args, **kwargs):\n1345         with AnnotatedQueue() as q:\n \u2192 1346             result = fn(*args, **kwargs)\n1347\n1348         qscript = QuantumScript.from_queue(q)\n/tmp/ipykernel_51/935320941.py in appLyHadamard()\n4 @qml.qnode(dev)\n5 def appLyHadamard():\n----> 6     qml.Hadamard(wires=dev.wires)\n7     return qml.state()\n/opt/conda/envs/pennylane/lib/python3.9/site-packages/pennylane/operation.py in init(self, wires, do_queue, id, *params)\n1559\n1560         self._inverse = False\n \u2192 1561         super().init(*params, wires=wires, do_queue=do_queue, id=id)\n1562\n1563         # check the grad_recipe validity\n/opt/conda/envs/pennylane/lib/python3.9/site-packages/pennylane/operation.py in init(self, wires, do_queue, id, *params)\n880\n881         elif len(self._wires) != self.num_wires:\n \u2192 882             raise ValueError(\n883                 f\"{self.name}: wrong number of wires. \"\n884                 f\"{len(self._wires)} wires given, {self.num_wires} expected.\"\nValueError: Hadamard: wrong number of wires. 4 wires given, 1 expected.", "link": "https://discuss.pennylane.ai//t/apply-hadamard-to-a-list-of-qubits-at-the-same-time/2695/1"}, "1": {"author": "CatalinaAlbornoz", "date": "1678725503323", "content": "Hi @Afrah, great question!\nYou can use qml.broadcast! This will apply a specific gate multiple times in a certain pattern. You can take a look at the different patterns in the PennyLane docs.\nSo instead of using qml.Hadamard(wires=dev.wires) you can use qml.broadcast(unitary=qml.Hadamard, pattern=\"single\", wires=dev.wires)\nCheck out our other templates too :).\nEnjoy using PennyLane!", "link": "https://discuss.pennylane.ai//t/apply-hadamard-to-a-list-of-qubits-at-the-same-time/2695/2"}, "2": {"author": "Afrah", "date": "1678352365312", "content": "How can I apply Hadamard to a list of qubits without using loops like that in qiskit.\nn_bits = 4\ndev = qml.device(\"default.qubit\", wires=n_bits)\n\n@qml.qnode(dev)\ndef appLyHadamard():\n    qml.Hadamard(wires=dev.wires) \n# without using this    ' for wire in dev.wires:      qml.Hadamard(wires =wire)'\n    return qml.state()\n\nr = appLyHadamard()\n\n\nI got this error:\n\nValueError                                Traceback (most recent call last)\n/tmp/ipykernel_51/3241397786.py in <cell line: 1>()\n----> 1 r = appLyHadamard()\n/opt/conda/envs/pennylane/lib/python3.9/site-packages/pennylane/qnode.py in call(self, *args, **kwargs)\n798\n799         # construct the tape\n \u2192 800         self.construct(args, kwargs)\n801\n802         cache = self.execute_kwargs.get(\u201ccache\u201d, False)\n/opt/conda/envs/pennylane/lib/python3.9/site-packages/pennylane/qnode.py in construct(self, args, kwargs)\n709         \u201c\u201d\u201cCall the quantum function with a tape context, ensuring the operations get queued.\u201d\u201c\u201d\n710\n \u2192 711         self._tape = make_qscript(self.func)(*args, **kwargs)\n712         self._tape._queue_category = \u201c_ops\u201d\n713         self._qfunc_output = self.tape._qfunc_output\n/opt/conda/envs/pennylane/lib/python3.9/site-packages/pennylane/tape/qscript.py in wrapper(*args, **kwargs)\n1344     def wrapper(*args, **kwargs):\n1345         with AnnotatedQueue() as q:\n \u2192 1346             result = fn(*args, **kwargs)\n1347\n1348         qscript = QuantumScript.from_queue(q)\n/tmp/ipykernel_51/935320941.py in appLyHadamard()\n4 @qml.qnode(dev)\n5 def appLyHadamard():\n----> 6     qml.Hadamard(wires=dev.wires)\n7     return qml.state()\n/opt/conda/envs/pennylane/lib/python3.9/site-packages/pennylane/operation.py in init(self, wires, do_queue, id, *params)\n1559\n1560         self._inverse = False\n \u2192 1561         super().init(*params, wires=wires, do_queue=do_queue, id=id)\n1562\n1563         # check the grad_recipe validity\n/opt/conda/envs/pennylane/lib/python3.9/site-packages/pennylane/operation.py in init(self, wires, do_queue, id, *params)\n880\n881         elif len(self._wires) != self.num_wires:\n \u2192 882             raise ValueError(\n883                 f\"{self.name}: wrong number of wires. \"\n884                 f\"{len(self._wires)} wires given, {self.num_wires} expected.\"\nValueError: Hadamard: wrong number of wires. 4 wires given, 1 expected.", "link": "https://discuss.pennylane.ai//t/apply-hadamard-to-a-list-of-qubits-at-the-same-time/2695/3"}}