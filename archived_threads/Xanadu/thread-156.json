{"0": {"author": "leo", "date": "1693809771210", "content": "Hi, I had some trouble getting measurements of the quantum circuit.\nI want to get measurements for a single wire.\nMy Pennylane version is\nName: PennyLane\nVersion: 0.32.0\nSummary: PennyLane is a Python quantum machine learning library by Xanadu Inc.\nHome-page: https://github.com/PennyLaneAI/pennylane\nAuthor: \nAuthor-email: \nLicense: Apache License 2.0\nLocation: c:\\users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\nRequires: appdirs, autograd, autoray, cachetools, networkx, numpy, pennylane-lightning, requests, rustworkx, scipy, semantic-version, toml, typing-extensions\nRequired-by: PennyLane-Lightning\n\nPlatform info:           Windows-10-10.0.22621-SP0\nPython version:          3.9.16\nNumpy version:           1.23.5\nScipy version:           1.10.0\nInstalled devices:\n- default.gaussian (PennyLane-0.28.0)\n- default.mixed (PennyLane-0.28.0)\n- default.qubit (PennyLane-0.28.0)\n- default.qubit.autograd (PennyLane-0.28.0)\n- default.qubit.jax (PennyLane-0.28.0)\n- default.qubit.tf (PennyLane-0.28.0)\n- default.qubit.torch (PennyLane-0.28.0)\n- default.qutrit (PennyLane-0.28.0)\n- null.qubit (PennyLane-0.28.0)\n- lightning.qubit (PennyLane-Lightning-0.30.0)\n\nThe code I\u2019m struggling with is\ndev = qml.device(\"default.qubit\", wires=4)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.Hadamard(wires=0)\n    return qml.expval(qml.PauliX(0)), qml.expval(qml.PauliY(0)), qml.expval(qml.PauliZ(0))\n\nprint(circuit())\n\nThis yields the error about\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[191], line 8\n      5     qml.Hadamard(wires=0)\n      6     return qml.expval(qml.PauliX(0)), qml.expval(qml.PauliY(0)), qml.expval(qml.PauliZ(0))\n----> 8 print(circuit())\n\nFile c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\pennylane\\qnode.py:847, in QNode.__call__(self, *args, **kwargs)\n    843     self._update_original_device()\n    845     return res\n--> 847 res = qml.execute(\n    848     [self.tape],\n    849     device=self.device,\n    850     gradient_fn=self.gradient_fn,\n    851     interface=self.interface,\n    852     gradient_kwargs=self.gradient_kwargs,\n    853     override_shots=override_shots,\n    854     **self.execute_kwargs,\n    855 )\n    857 if old_interface == \"auto\":\n    858     self.interface = \"auto\"\n\nFile c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\pennylane\\interfaces\\execution.py:619, in execute(tapes, device, gradient_fn, interface, mode, gradient_kwargs, cache, cachesize, max_diff, override_shots, expand_fn, max_expansion, device_batch_transform)\n    617 if device_batch_transform:\n    618     dev_batch_transform = set_shots(device, override_shots)(device.batch_transform)\n--> 619     tapes, batch_fn = qml.transforms.map_batch_transform(dev_batch_transform, tapes)\n    620 else:\n    621     batch_fn = lambda res: res\n\nFile c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\pennylane\\transforms\\batch_transform.py:471, in map_batch_transform(transform, tapes)\n    465 tape_counts = []\n    467 for t in tapes:\n    468     # Preprocess the tapes by applying batch transforms\n    469     # to each tape, and storing corresponding tapes\n    470     # for execution, processing functions, and list of tape lengths.\n--> 471     new_tapes, fn = transform(t)\n    472     execution_tapes.extend(new_tapes)\n    473     batch_fns.append(fn)\n\nFile c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\contextlib.py:79, in ContextDecorator.__call__..inner(*args, **kwds)\n     76 @wraps(func)\n     77 def inner(*args, **kwds):\n     78     with self._recreate_cm():\n---> 79         return func(*args, **kwds)\n\nFile c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\pennylane\\_device.py:769, in Device.batch_transform(self, circuit)\n    758     circuits, hamiltonian_fn = qml.transforms.sum_expand(circuit)\n    760 elif (\n    761     len(circuit._obs_sharing_wires) > 0\n    762     and not hamiltonian_in_obs\n   (...)\n    767     # Check for case of non-commuting terms and that there are no Hamiltonians\n    768     # TODO: allow for Hamiltonians in list of observables as well.\n--> 769     circuits, hamiltonian_fn = qml.transforms.split_non_commuting(circuit)\n    771 else:\n    772     # otherwise, return the output of an identity transform\n    773     circuits = [circuit]\n\nFile c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\pennylane\\transforms\\batch_transform.py:331, in batch_transform.__call__(self, *targs, **tkwargs)\n    326     return self._device_wrapper(*targs, **tkwargs)(qnode)\n    328 if isinstance(qnode, qml.tape.QuantumScript):\n    329     # Input is a quantum tape.\n    330     # tapes, fn = some_transform(tape, *transform_args)\n--> 331     return self._tape_wrapper(*targs, **tkwargs)(qnode)\n    333 if isinstance(qnode, (qml.QNode, qml.ExpvalCost)):\n    334     # Input is a QNode:\n    335     # result = some_transform(qnode, *transform_args)(*qnode_args)\n    336     wrapper = self.qnode_wrapper(qnode, targs, tkwargs)\n\nFile c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\pennylane\\transforms\\batch_transform.py:421, in batch_transform._tape_wrapper..(tape)\n    420 def _tape_wrapper(self, *targs, **tkwargs):\n--> 421     return lambda tape: self.construct(tape, *targs, **tkwargs)\n\nFile c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\pennylane\\transforms\\batch_transform.py:403, in batch_transform.construct(self, tape, *args, **kwargs)\n    400 if expand and self.expand_fn is not None:\n    401     tape = self.expand_fn(tape, *args, **kwargs)\n--> 403 tapes, processing_fn = self.transform_fn(tape, *args, **kwargs)\n    405 if processing_fn is None:\n    407     def processing_fn(x):\n\nFile c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\pennylane\\transforms\\split_non_commuting.py:160, in split_non_commuting(tape)\n    157 obs_list = tape.observables\n    159 # If there is more than one group of commuting observables, split tapes\n--> 160 groups, group_coeffs = qml.pauli.group_observables(obs_list, range(len(obs_list)))\n    161 if len(groups) > 1:\n    162     # make one tape per commuting group\n    163     tapes = []\n\nFile c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\pennylane\\pauli\\grouping\\group_observables.py:227, in group_observables(observables, coefficients, grouping_type, method)\n    183 \"\"\"Partitions a list of observables (Pauli operations and tensor products thereof) into\n    184 groupings according to a binary relation (qubit-wise commuting, fully-commuting, or\n    185 anticommuting).\n   (...)\n    223 [[0.97, 4.21], [1.43]]\n    224 \"\"\"\n    226 if coefficients is not None:\n--> 227     if qml.math.shape(coefficients)[0] != len(observables):\n    228         raise IndexError(\n    229             \"The coefficients list must be the same length as the observables list.\"\n    230         )\n    232 pauli_grouping = PauliGroupingStrategy(\n    233     observables, grouping_type=grouping_type, graph_colourer=method\n    234 )\n\nIndexError: tuple index out of range\n\nThe other code I implemented is\ndev = qml.device(\"default.qubit\", wires=4)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.Hadamard(wires=0)\n    return qml.expval(qml.PauliX(0), qml.PauliY(0), qml.PauliZ(0))\n\nprint(circuit())\n\nThe error by this code is\nUnexpected exception formatting exception. Falling back to standard exception\nTraceback (most recent call last):\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\IPython\\core\\interactiveshell.py\", line 3505, in run_code\n    exec(code_obj, self.user_global_ns, self.user_ns)\n  File \"C:\\Users\\user1\\AppData\\Local\\Temp\\ipykernel_4752\\1396563536.py\", line 8, in <module>\n    print(circuit())\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\pennylane\\qnode.py\", line 800, in __call__\n    return \"adjoint\", {}, device\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\pennylane\\qnode.py\", line 711, in construct\n    Returns:\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\pennylane\\tape\\qscript.py\", line 1346, in wrapper\n  File \"C:\\Users\\user1\\AppData\\Local\\Temp\\ipykernel_4752\\1396563536.py\", line 6, in circuit\n    return qml.expval(qml.PauliX(0), qml.PauliY(0), qml.PauliZ(0))\nTypeError: expval() takes 1 positional argument but 3 were given\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\IPython\\core\\interactiveshell.py\", line 2102, in showtraceback\n    stb = self.InteractiveTB.structured_traceback(\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\IPython\\core\\ultratb.py\", line 1310, in structured_traceback\n    return FormattedTB.structured_traceback(\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\IPython\\core\\ultratb.py\", line 1199, in structured_traceback\n    return VerboseTB.structured_traceback(\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\IPython\\core\\ultratb.py\", line 1052, in structured_traceback\n    formatted_exception = self.format_exception_as_a_whole(etype, evalue, etb, number_of_lines_of_context,\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\IPython\\core\\ultratb.py\", line 978, in format_exception_as_a_whole\n    frames.append(self.format_record(record))\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\IPython\\core\\ultratb.py\", line 878, in format_record\n    frame_info.lines, Colors, self.has_colors, lvals\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\IPython\\core\\ultratb.py\", line 712, in lines\n    return self._sd.lines\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\stack_data\\utils.py\", line 145, in cached_property_wrapper\n    value = obj.__dict__[self.func.__name__] = self.func(obj)\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\stack_data\\core.py\", line 698, in lines\n    pieces = self.included_pieces\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\stack_data\\utils.py\", line 145, in cached_property_wrapper\n    value = obj.__dict__[self.func.__name__] = self.func(obj)\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\stack_data\\core.py\", line 649, in included_pieces\n    pos = scope_pieces.index(self.executing_piece)\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\stack_data\\utils.py\", line 145, in cached_property_wrapper\n    value = obj.__dict__[self.func.__name__] = self.func(obj)\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\stack_data\\core.py\", line 628, in executing_piece\n    return only(\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\executing\\executing.py\", line 164, in only\n    raise NotOneValueFound('Expected one value, found 0')\nexecuting.executing.NotOneValueFound: Expected one value, found 0\n\nI think the measurement values for commuting variables (e.g., Pauli observables) for a single wire can be calculated. However, I cannot get the values by implementing the above codes.\nActually, I was calculating the measurements on a single wire using variational parameters with an 8-qubit device. I made it simple for debugging.\nFurthermore, is there any available Pennylane version for multiple measurements on a single wire? I used to make multiple measurements on a single wire before.\nThanks!\n\n\n Solved by CatalinaAlbornoz in post #2 \n\n\n                Hi @leo, welcome to the Forum! \nI\u2019m being able to run your first snippet of code with no problems. It\u2019s strange but your PennyLane version seems right, however your device versions are not updated. This might be causing the issue you\u2019re seeing. \nI would recommend that you try the following options u\u2026\n              \n", "link": "https://discuss.pennylane.ai//t/multiple-measurements-on-a-single-wire/3391/1"}, "1": {"author": "CatalinaAlbornoz", "date": "1693945401483", "content": "Hi @leo, welcome to the Forum!\nI\u2019m being able to run your first snippet of code with no problems. It\u2019s strange but your PennyLane version seems right, however your device versions are not updated. This might be causing the issue you\u2019re seeing.\nI would recommend that you try the following options until default.qubit (in your installed devices) is PennyLane-0.32.0. Then run your first snippet of code again and please let me know if it now works.\n\nRun python -m pip install pennylane --upgrade\nRun python -m pip install --upgrade --force-reinstall pennylane\nCreate a new virtual environment with conda create --name <your_env_name> python=3.10 and activate it with conda activate <your_env_name>. Then python -m pip install pennylane\n\nPlease let me know if none of these work for you.\nYour second code snippet won\u2019t work because expval only takes one argument.\nLet me know if you have any additional questions.\nAlso, we have a new PennyLane survey. Let us know your thoughts about PennyLane in order to keep bringing you amazing features .Solution", "link": "https://discuss.pennylane.ai//t/multiple-measurements-on-a-single-wire/3391/2"}, "2": {"author": "leo", "date": "1694752030458", "content": "Hi @CatalinaAlbornoz, thanks for your kind reply.\nI was able to run the code with new virtual environment.\nThanks!2", "link": "https://discuss.pennylane.ai//t/multiple-measurements-on-a-single-wire/3391/3"}, "3": {"author": "leo", "date": "1693809771210", "content": "Hi, I had some trouble getting measurements of the quantum circuit.\nI want to get measurements for a single wire.\nMy Pennylane version is\nName: PennyLane\nVersion: 0.32.0\nSummary: PennyLane is a Python quantum machine learning library by Xanadu Inc.\nHome-page: https://github.com/PennyLaneAI/pennylane\nAuthor: \nAuthor-email: \nLicense: Apache License 2.0\nLocation: c:\\users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\nRequires: appdirs, autograd, autoray, cachetools, networkx, numpy, pennylane-lightning, requests, rustworkx, scipy, semantic-version, toml, typing-extensions\nRequired-by: PennyLane-Lightning\n\nPlatform info:           Windows-10-10.0.22621-SP0\nPython version:          3.9.16\nNumpy version:           1.23.5\nScipy version:           1.10.0\nInstalled devices:\n- default.gaussian (PennyLane-0.28.0)\n- default.mixed (PennyLane-0.28.0)\n- default.qubit (PennyLane-0.28.0)\n- default.qubit.autograd (PennyLane-0.28.0)\n- default.qubit.jax (PennyLane-0.28.0)\n- default.qubit.tf (PennyLane-0.28.0)\n- default.qubit.torch (PennyLane-0.28.0)\n- default.qutrit (PennyLane-0.28.0)\n- null.qubit (PennyLane-0.28.0)\n- lightning.qubit (PennyLane-Lightning-0.30.0)\n\nThe code I\u2019m struggling with is\ndev = qml.device(\"default.qubit\", wires=4)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.Hadamard(wires=0)\n    return qml.expval(qml.PauliX(0)), qml.expval(qml.PauliY(0)), qml.expval(qml.PauliZ(0))\n\nprint(circuit())\n\nThis yields the error about\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nCell In[191], line 8\n      5     qml.Hadamard(wires=0)\n      6     return qml.expval(qml.PauliX(0)), qml.expval(qml.PauliY(0)), qml.expval(qml.PauliZ(0))\n----> 8 print(circuit())\n\nFile c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\pennylane\\qnode.py:847, in QNode.__call__(self, *args, **kwargs)\n    843     self._update_original_device()\n    845     return res\n--> 847 res = qml.execute(\n    848     [self.tape],\n    849     device=self.device,\n    850     gradient_fn=self.gradient_fn,\n    851     interface=self.interface,\n    852     gradient_kwargs=self.gradient_kwargs,\n    853     override_shots=override_shots,\n    854     **self.execute_kwargs,\n    855 )\n    857 if old_interface == \"auto\":\n    858     self.interface = \"auto\"\n\nFile c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\pennylane\\interfaces\\execution.py:619, in execute(tapes, device, gradient_fn, interface, mode, gradient_kwargs, cache, cachesize, max_diff, override_shots, expand_fn, max_expansion, device_batch_transform)\n    617 if device_batch_transform:\n    618     dev_batch_transform = set_shots(device, override_shots)(device.batch_transform)\n--> 619     tapes, batch_fn = qml.transforms.map_batch_transform(dev_batch_transform, tapes)\n    620 else:\n    621     batch_fn = lambda res: res\n\nFile c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\pennylane\\transforms\\batch_transform.py:471, in map_batch_transform(transform, tapes)\n    465 tape_counts = []\n    467 for t in tapes:\n    468     # Preprocess the tapes by applying batch transforms\n    469     # to each tape, and storing corresponding tapes\n    470     # for execution, processing functions, and list of tape lengths.\n--> 471     new_tapes, fn = transform(t)\n    472     execution_tapes.extend(new_tapes)\n    473     batch_fns.append(fn)\n\nFile c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\contextlib.py:79, in ContextDecorator.__call__..inner(*args, **kwds)\n     76 @wraps(func)\n     77 def inner(*args, **kwds):\n     78     with self._recreate_cm():\n---> 79         return func(*args, **kwds)\n\nFile c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\pennylane\\_device.py:769, in Device.batch_transform(self, circuit)\n    758     circuits, hamiltonian_fn = qml.transforms.sum_expand(circuit)\n    760 elif (\n    761     len(circuit._obs_sharing_wires) > 0\n    762     and not hamiltonian_in_obs\n   (...)\n    767     # Check for case of non-commuting terms and that there are no Hamiltonians\n    768     # TODO: allow for Hamiltonians in list of observables as well.\n--> 769     circuits, hamiltonian_fn = qml.transforms.split_non_commuting(circuit)\n    771 else:\n    772     # otherwise, return the output of an identity transform\n    773     circuits = [circuit]\n\nFile c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\pennylane\\transforms\\batch_transform.py:331, in batch_transform.__call__(self, *targs, **tkwargs)\n    326     return self._device_wrapper(*targs, **tkwargs)(qnode)\n    328 if isinstance(qnode, qml.tape.QuantumScript):\n    329     # Input is a quantum tape.\n    330     # tapes, fn = some_transform(tape, *transform_args)\n--> 331     return self._tape_wrapper(*targs, **tkwargs)(qnode)\n    333 if isinstance(qnode, (qml.QNode, qml.ExpvalCost)):\n    334     # Input is a QNode:\n    335     # result = some_transform(qnode, *transform_args)(*qnode_args)\n    336     wrapper = self.qnode_wrapper(qnode, targs, tkwargs)\n\nFile c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\pennylane\\transforms\\batch_transform.py:421, in batch_transform._tape_wrapper..(tape)\n    420 def _tape_wrapper(self, *targs, **tkwargs):\n--> 421     return lambda tape: self.construct(tape, *targs, **tkwargs)\n\nFile c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\pennylane\\transforms\\batch_transform.py:403, in batch_transform.construct(self, tape, *args, **kwargs)\n    400 if expand and self.expand_fn is not None:\n    401     tape = self.expand_fn(tape, *args, **kwargs)\n--> 403 tapes, processing_fn = self.transform_fn(tape, *args, **kwargs)\n    405 if processing_fn is None:\n    407     def processing_fn(x):\n\nFile c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\pennylane\\transforms\\split_non_commuting.py:160, in split_non_commuting(tape)\n    157 obs_list = tape.observables\n    159 # If there is more than one group of commuting observables, split tapes\n--> 160 groups, group_coeffs = qml.pauli.group_observables(obs_list, range(len(obs_list)))\n    161 if len(groups) > 1:\n    162     # make one tape per commuting group\n    163     tapes = []\n\nFile c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\pennylane\\pauli\\grouping\\group_observables.py:227, in group_observables(observables, coefficients, grouping_type, method)\n    183 \"\"\"Partitions a list of observables (Pauli operations and tensor products thereof) into\n    184 groupings according to a binary relation (qubit-wise commuting, fully-commuting, or\n    185 anticommuting).\n   (...)\n    223 [[0.97, 4.21], [1.43]]\n    224 \"\"\"\n    226 if coefficients is not None:\n--> 227     if qml.math.shape(coefficients)[0] != len(observables):\n    228         raise IndexError(\n    229             \"The coefficients list must be the same length as the observables list.\"\n    230         )\n    232 pauli_grouping = PauliGroupingStrategy(\n    233     observables, grouping_type=grouping_type, graph_colourer=method\n    234 )\n\nIndexError: tuple index out of range\n\nThe other code I implemented is\ndev = qml.device(\"default.qubit\", wires=4)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.Hadamard(wires=0)\n    return qml.expval(qml.PauliX(0), qml.PauliY(0), qml.PauliZ(0))\n\nprint(circuit())\n\nThe error by this code is\nUnexpected exception formatting exception. Falling back to standard exception\nTraceback (most recent call last):\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\IPython\\core\\interactiveshell.py\", line 3505, in run_code\n    exec(code_obj, self.user_global_ns, self.user_ns)\n  File \"C:\\Users\\user1\\AppData\\Local\\Temp\\ipykernel_4752\\1396563536.py\", line 8, in <module>\n    print(circuit())\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\pennylane\\qnode.py\", line 800, in __call__\n    return \"adjoint\", {}, device\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\pennylane\\qnode.py\", line 711, in construct\n    Returns:\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\pennylane\\tape\\qscript.py\", line 1346, in wrapper\n  File \"C:\\Users\\user1\\AppData\\Local\\Temp\\ipykernel_4752\\1396563536.py\", line 6, in circuit\n    return qml.expval(qml.PauliX(0), qml.PauliY(0), qml.PauliZ(0))\nTypeError: expval() takes 1 positional argument but 3 were given\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\IPython\\core\\interactiveshell.py\", line 2102, in showtraceback\n    stb = self.InteractiveTB.structured_traceback(\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\IPython\\core\\ultratb.py\", line 1310, in structured_traceback\n    return FormattedTB.structured_traceback(\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\IPython\\core\\ultratb.py\", line 1199, in structured_traceback\n    return VerboseTB.structured_traceback(\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\IPython\\core\\ultratb.py\", line 1052, in structured_traceback\n    formatted_exception = self.format_exception_as_a_whole(etype, evalue, etb, number_of_lines_of_context,\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\IPython\\core\\ultratb.py\", line 978, in format_exception_as_a_whole\n    frames.append(self.format_record(record))\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\IPython\\core\\ultratb.py\", line 878, in format_record\n    frame_info.lines, Colors, self.has_colors, lvals\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\IPython\\core\\ultratb.py\", line 712, in lines\n    return self._sd.lines\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\stack_data\\utils.py\", line 145, in cached_property_wrapper\n    value = obj.__dict__[self.func.__name__] = self.func(obj)\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\stack_data\\core.py\", line 698, in lines\n    pieces = self.included_pieces\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\stack_data\\utils.py\", line 145, in cached_property_wrapper\n    value = obj.__dict__[self.func.__name__] = self.func(obj)\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\stack_data\\core.py\", line 649, in included_pieces\n    pos = scope_pieces.index(self.executing_piece)\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\stack_data\\utils.py\", line 145, in cached_property_wrapper\n    value = obj.__dict__[self.func.__name__] = self.func(obj)\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\stack_data\\core.py\", line 628, in executing_piece\n    return only(\n  File \"c:\\Users\\user1\\anaconda3\\envs\\qsvdd\\lib\\site-packages\\executing\\executing.py\", line 164, in only\n    raise NotOneValueFound('Expected one value, found 0')\nexecuting.executing.NotOneValueFound: Expected one value, found 0\n\nI think the measurement values for commuting variables (e.g., Pauli observables) for a single wire can be calculated. However, I cannot get the values by implementing the above codes.\nActually, I was calculating the measurements on a single wire using variational parameters with an 8-qubit device. I made it simple for debugging.\nFurthermore, is there any available Pennylane version for multiple measurements on a single wire? I used to make multiple measurements on a single wire before.\nThanks!\n\n\n Solved by CatalinaAlbornoz in post #2 \n\n\n                Hi @leo, welcome to the Forum! \nI\u2019m being able to run your first snippet of code with no problems. It\u2019s strange but your PennyLane version seems right, however your device versions are not updated. This might be causing the issue you\u2019re seeing. \nI would recommend that you try the following options u\u2026\n              \n", "link": "https://discuss.pennylane.ai//t/multiple-measurements-on-a-single-wire/3391/4"}}