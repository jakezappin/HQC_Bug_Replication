{"0": {"author": "Dhawal_Verma", "date": "1697111056899", "content": "I cannot obtain the second-order approximation of exp(-itU). This is my code:\ndef v0(t):\n    \"\"\"Calculates the first column of the PREPARE matrix, v0.\n\n    Args:\n        t (float): the time we evolve for.\n\n    Returns:\n        (array): v0 = [v00, v01, v02, v03] normalized\n    \"\"\"\n    ##################\n    # YOUR CODE HERE #\n    ##################\n    v00 = 1\n    v01 = np.sqrt(t)\n    v02 = t/np.sqrt(2)\n    v03 = 0\n    \n    return np.array([v00, v01, v02, v03])/np.sqrt(1+t+1/2*t**2)\n\n    \ndef exp_U_second(unitaries, t):\n    \"\"\"Implements the second-order approximation to Hamiltonian time evolution. \n\n    Args:\n        unitaries (list): A list containing 4 unitary operations in this order:\n        (U0, U1, U2, U3).\n        t (float): The Hamiltonian evolution time. \n    \"\"\"\n    ##################\n    # YOUR CODE HERE #\n    ##################\n    qml.MottonenStatePreparation(state_vector=v0(t),wires=range(2))\n    select(unitaries)\n    qml.MottonenStatePreparation(state_vector=np.transpose(np.conjugate(v0(t))),wires=range(2))\n    \n\n", "link": "https://discuss.pennylane.ai//t/hamiltonian-linear-combination-of-unitaries/3543/1"}, "1": {"author": "isaacdevlugt", "date": "1697121332308", "content": "Hey @Dhawal_Verma!\nI recommend trying to use your prepare function that you had to have completed in H.9.4a. Make sure you use qml.adjoint when applicable! Let me know if this helps ", "link": "https://discuss.pennylane.ai//t/hamiltonian-linear-combination-of-unitaries/3543/2"}, "2": {"author": "isaacdevlugt", "date": "1697142376819", "content": "I didn\u2019t see anything wrong with your v0 function:\ndef v0(t):\n    \"\"\"Calculates the first column of the PREPARE matrix, v0.\n\n    Args:\n        t (float): the time we evolve for.\n\n    Returns:\n        (array): v0 = [v00, v01, v02, v03] normalized\n    \"\"\"\n    ##################\n    # YOUR CODE HERE #\n    ##################\n    v00 = 1\n    v01 = np.sqrt(t)\n    v02 = t/np.sqrt(2)\n    v03 = 0\n    \n    return np.array([v00, v01, v02, v03])/np.sqrt(1+t+1/2*t**2)\n\nBut your exp_U_second function isn\u2019t right. The algorithm is PREP, SELECT, then PREP ^\\dagger, and your prepare function should be this (or very similar) from H.6.4a:\ndef prepare(coeffs):\n    qml.MottonenStatePreparation(normalize(coeffs), wires=aux)\n\nHope this helps!2 Replies1", "link": "https://discuss.pennylane.ai//t/hamiltonian-linear-combination-of-unitaries/3543/3"}, "3": {"author": "isaacdevlugt", "date": "1697483661731", "content": "Awesome! Glad to hear \nWe have a new PennyLane survey  1. Let us know your thoughts about PennyLane so that we can keep bringing you amazing features .", "link": "https://discuss.pennylane.ai//t/hamiltonian-linear-combination-of-unitaries/3543/4"}, "4": {"author": "Dhawal_Verma", "date": "1697111056899", "content": "I cannot obtain the second-order approximation of exp(-itU). This is my code:\ndef v0(t):\n    \"\"\"Calculates the first column of the PREPARE matrix, v0.\n\n    Args:\n        t (float): the time we evolve for.\n\n    Returns:\n        (array): v0 = [v00, v01, v02, v03] normalized\n    \"\"\"\n    ##################\n    # YOUR CODE HERE #\n    ##################\n    v00 = 1\n    v01 = np.sqrt(t)\n    v02 = t/np.sqrt(2)\n    v03 = 0\n    \n    return np.array([v00, v01, v02, v03])/np.sqrt(1+t+1/2*t**2)\n\n    \ndef exp_U_second(unitaries, t):\n    \"\"\"Implements the second-order approximation to Hamiltonian time evolution. \n\n    Args:\n        unitaries (list): A list containing 4 unitary operations in this order:\n        (U0, U1, U2, U3).\n        t (float): The Hamiltonian evolution time. \n    \"\"\"\n    ##################\n    # YOUR CODE HERE #\n    ##################\n    qml.MottonenStatePreparation(state_vector=v0(t),wires=range(2))\n    select(unitaries)\n    qml.MottonenStatePreparation(state_vector=np.transpose(np.conjugate(v0(t))),wires=range(2))\n    \n\n", "link": "https://discuss.pennylane.ai//t/hamiltonian-linear-combination-of-unitaries/3543/5"}, "5": {"author": "isaacdevlugt", "date": "1697142376819", "content": "I didn\u2019t see anything wrong with your v0 function:\ndef v0(t):\n    \"\"\"Calculates the first column of the PREPARE matrix, v0.\n\n    Args:\n        t (float): the time we evolve for.\n\n    Returns:\n        (array): v0 = [v00, v01, v02, v03] normalized\n    \"\"\"\n    ##################\n    # YOUR CODE HERE #\n    ##################\n    v00 = 1\n    v01 = np.sqrt(t)\n    v02 = t/np.sqrt(2)\n    v03 = 0\n    \n    return np.array([v00, v01, v02, v03])/np.sqrt(1+t+1/2*t**2)\n\nBut your exp_U_second function isn\u2019t right. The algorithm is PREP, SELECT, then PREP ^\\dagger\u2020, and your prepare function should be this (or very similar) from H.6.4a:\ndef prepare(coeffs):\n    qml.MottonenStatePreparation(normalize(coeffs), wires=aux)\n\nHope this helps!2 Replies1", "link": "https://discuss.pennylane.ai//t/hamiltonian-linear-combination-of-unitaries/3543/6"}}