{"0": {"author": "jolle", "date": "1679309919486", "content": "I want to simulate an optical cavity interacting with a two-level system (a qubit) that depends on some parameters that I then want to optimize. My knowledge on Pennylane/StrawberryFields is very limited, so this is probably a very basic question.\nI understand that I should instantiate two devices:\ncavity_device = qml.device('default.qubit', wires=1)\nqubit_device = qml.device('default.gaussian', wires=1)\n\nwith which I should then create one (or two?) QNode(s). The qubit is prepared in a state that depends on some parameters. Then the qubit and the cavity interact according to a Jaynes-Cummings interaction for some time, after which the state of the cavity depends on the parameters with which the qubit was prepared. After this interaction, the qubit gets traced out and a loss function gets computed for the cavity.\nMy question is how to set up this optimization problem in such a way that I will be able to take gradients of a loss function in the cavity side that implicitly depends on the parameters of the qubit. Any help will be appreciated.", "link": "https://discuss.pennylane.ai//t/optimizing-a-cavity-qubit-system/2741/1"}, "1": {"author": "isaacdevlugt", "date": "1679578251094", "content": "Hey @jolle! Welcome to the forum !\nI\u2019m not sure I understand the nuances of your problem. But, if there are any parameters in your circuit that you want to differentiate over, you can \u201cflag\u201d them to PennyLane as differentiable with requires_grad = True. For parameters that you don\u2019t want to differentiate over, you would specify False instead. Here\u2019s an example of a circuit with one qubit and two rotation gates, one of which I want to flag in order to take derivatives of.\nimport pennylane as qml\nfrom pennylane import numpy as np\ndev = qml.device(\"default.qubit\", wires=1)\n\n@qml.qnode(dev)\ndef circuit(angle1, angle2):\n    qml.RX(angle1, wires=0)\n    qml.RY(angle2, wires=0)\n    return qml.expval(qml.PauliX(0))\n\nangle1 = np.array(np.pi/3, requires_grad=True) # Differentiate w.r.t. this angle\nangle2 = np.array(np.pi/4, requires_grad=False) # will remain constant \n\nangles = [angle1, angle2]\n\nopt = qml.GradientDescentOptimizer(0.1)\n\nfor _ in range(3):\n    angles, loss = opt.step_and_cost(circuit, *angles)\n    print(angles)\n\n'''output:\n0.29.1\n[tensor(1.10843479, requires_grad=True), tensor(0.78539816, requires_grad=False)]\n[tensor(1.17172096, requires_grad=True), tensor(0.78539816, requires_grad=False)]\n[tensor(1.23687525, requires_grad=True), tensor(0.78539816, requires_grad=False)]\n'''\n\nNote that angle1 changes, while angle2 does not!\nI hope this helps, but if it doesn\u2019t, please respond back with more questions!1", "link": "https://discuss.pennylane.ai//t/optimizing-a-cavity-qubit-system/2741/2"}, "2": {"author": "jolle", "date": "1679671239038", "content": "Hi @isaacdevlugt ! Thanks for your answer \nUnfortunately this wasn\u2019t really my question. My question is more whether there is support for a qml.device that includes both a cavity (i.e. a quantum harmonic oscillator Hilbert space) and qubits, or whether there is a way to combine two different devices into a single device", "link": "https://discuss.pennylane.ai//t/optimizing-a-cavity-qubit-system/2741/3"}, "3": {"author": "isaacdevlugt", "date": "1679923643617", "content": "@jolle ah! Thank you for clarifying . Unfortunately, no \u2014 there isn\u2019t a way to do this in PennyLane currently. We are slowly extending the qubit framework to qutrits/qudits, but heterogeneous Hilbert spaces need some careful thought!", "link": "https://discuss.pennylane.ai//t/optimizing-a-cavity-qubit-system/2741/4"}, "4": {"author": "isaacdevlugt", "date": "1680617024152", "content": "Hey @jolle! It might be worthwhile to check out Mr Mustard: Mr Mustard Documentation \u2014 Mr Mustard 0.4.1 documentation 1\nYou can impose any cutoff in any mode. So, a qubit could be a mode with a cutoff of 2.", "link": "https://discuss.pennylane.ai//t/optimizing-a-cavity-qubit-system/2741/5"}, "5": {"author": "jolle", "date": "1679309919486", "content": "I want to simulate an optical cavity interacting with a two-level system (a qubit) that depends on some parameters that I then want to optimize. My knowledge on Pennylane/StrawberryFields is very limited, so this is probably a very basic question.\nI understand that I should instantiate two devices:\ncavity_device = qml.device('default.qubit', wires=1)\nqubit_device = qml.device('default.gaussian', wires=1)\n\nwith which I should then create one (or two?) QNode(s). The qubit is prepared in a state that depends on some parameters. Then the qubit and the cavity interact according to a Jaynes-Cummings interaction for some time, after which the state of the cavity depends on the parameters with which the qubit was prepared. After this interaction, the qubit gets traced out and a loss function gets computed for the cavity.\nMy question is how to set up this optimization problem in such a way that I will be able to take gradients of a loss function in the cavity side that implicitly depends on the parameters of the qubit. Any help will be appreciated.", "link": "https://discuss.pennylane.ai//t/optimizing-a-cavity-qubit-system/2741/6"}}