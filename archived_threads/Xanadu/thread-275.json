{"0": {"author": "cuhrazatee", "date": "1632936077305", "content": "I want to generate statevectors from the underlying measured bitstrings. What order are the bitstring arrays returned as? That is, is [1, 0, 0, 0] = '1000' or '0001'?", "link": "https://discuss.pennylane.ai//t/what-is-the-endianness-of-returned-bitstrings-from-sample/1384/1"}, "1": {"author": "Tom_Bromley", "date": "1632945910209", "content": "Hey @cuhrazatee!\nThe following circuit provides PennyLane code to check:\nimport pennylane as qml\nfrom pennylane import numpy as np\n\nn_wires = 4\ndev = qml.device(\"default.qubit\", wires=n_wires, shots=10)\n\n@qml.qnode(dev)\ndef samples(bitstring):\n    qml.BasisState(bitstring, wires=range(n_wires))\n    return [qml.sample(qml.PauliZ(i)) for i in range(n_wires)]\n\nb = [1, 1, 0, 0]\n\nYou can see that evaluating this circuit gives:\n>>> samples(b).T\narray([[-1, -1,  1,  1],\n       [-1, -1,  1,  1],\n       [-1, -1,  1,  1],\n       [-1, -1,  1,  1],\n       [-1, -1,  1,  1],\n       [-1, -1,  1,  1],\n       [-1, -1,  1,  1],\n       [-1, -1,  1,  1],\n       [-1, -1,  1,  1],\n       [-1, -1,  1,  1]])\n\nThe output samples have values 1 and -1. The 1 corresponds to the +1 eigenstate of the Pauli matrix \\sigma_{z}, which is |0\\rangle. The -1 corresponds to the -1 eigenstate of \\sigma_{z}, which is |1\\rangle. In other words, in the above -1 maps to |1\\rangle and 1 maps to |0\\rangle.\nHence, we see that for qubit i corresponds to the i-th column of samples(b).T.", "link": "https://discuss.pennylane.ai//t/what-is-the-endianness-of-returned-bitstrings-from-sample/1384/2"}, "2": {"author": "cuhrazatee", "date": "1632936077305", "content": "I want to generate statevectors from the underlying measured bitstrings. What order are the bitstring arrays returned as? That is, is [1, 0, 0, 0] = '1000' or '0001'?", "link": "https://discuss.pennylane.ai//t/what-is-the-endianness-of-returned-bitstrings-from-sample/1384/3"}, "3": {"author": "Tom_Bromley", "date": "1632945910209", "content": "Hey @cuhrazatee!\nThe following circuit provides PennyLane code to check:\nimport pennylane as qml\nfrom pennylane import numpy as np\n\nn_wires = 4\ndev = qml.device(\"default.qubit\", wires=n_wires, shots=10)\n\n@qml.qnode(dev)\ndef samples(bitstring):\n    qml.BasisState(bitstring, wires=range(n_wires))\n    return [qml.sample(qml.PauliZ(i)) for i in range(n_wires)]\n\nb = [1, 1, 0, 0]\n\nYou can see that evaluating this circuit gives:\n>>> samples(b).T\narray([[-1, -1,  1,  1],\n       [-1, -1,  1,  1],\n       [-1, -1,  1,  1],\n       [-1, -1,  1,  1],\n       [-1, -1,  1,  1],\n       [-1, -1,  1,  1],\n       [-1, -1,  1,  1],\n       [-1, -1,  1,  1],\n       [-1, -1,  1,  1],\n       [-1, -1,  1,  1]])\n\nThe output samples have values 1 and -1. The 1 corresponds to the +1 eigenstate of the Pauli matrix \\sigma_{z}\u03c3z, which is |0\\rangle|0\u27e9. The -1 corresponds to the -1 eigenstate of \\sigma_{z}\u03c3z, which is |1\\rangle|1\u27e9. In other words, in the above -1 maps to |1\\rangle|1\u27e9 and 1 maps to |0\\rangle|0\u27e9.\nHence, we see that for qubit ii corresponds to the i-thi\u2212th column of samples(b).T.", "link": "https://discuss.pennylane.ai//t/what-is-the-endianness-of-returned-bitstrings-from-sample/1384/4"}}