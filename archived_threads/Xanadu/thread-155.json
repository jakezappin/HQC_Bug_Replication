{"0": {"author": "Kyleyip", "date": "1575447361718", "content": "hi,\nI am trying to rotate a qubit using the ibmq device.But it calculate so slow and about 3min per step. I check my IBMQ Experience result and found it seems like every step the optimization is performed, the qnode must revisit the device.\nI am curious how to speed up the calculation and reduce the waiting time for the ibm device.\nCode\nimport pennylane as qml\nfrom pennylane import numpy as np\nfrom qiskit import IBMQ\nfrom qiskit.providers.ibmq import least_busy\nprovider = IBMQ.load_account()\nprint(\u201c\\n(IBMQ Backends)\u201d)\nfor backend in provider.backends():\nprint(backend.status())\ntry:\nleast_busy_device = least_busy(provider.backends(simulator=False))\nexcept:\nprint(\u201cAll devices are currently unavailable.\u201d)\nlbd = str(least_busy_device)\nprint(\"Running on current least busy device: \", lbd)\ndev1 = qml.device(\u201cqiskit.ibmq\u201d, wires=1, backend=lbd)\n@qml.qnode(dev1)\ndef circuit(params):\nqml.RX(params[0],wires=0)\nqml.RY(params[1],wires=0)\nreturn qml.expval(qml.PauliZ(0))\ndef cost(var):\nreturn circuit(var)\ninit_params = np.array([0.011,0.012])\nprint(cost(init_params))\nopt = qml.GradientDescentOptimizer(stepsize=0.4)\nsteps = 100\nparams = init_params\nfor i in range(steps):\nparams = opt.step(cost, params)\nif (i+1) % 5 == 0:\nprint(\u201cCost after step{:5d}:{:.7f}\u201d.format(i+1, cost(params)))\nprint(\u201cOptimizer rotation angles:{}\u201d.format(params))\nI delete my API_TOKEN in the code.\nand the result show in IBMQ Experience\n\n11996\u00d7504 24.8 KB\n\nTime spent on one step.\n\nWechatIMG41876\u00d7316 8.36 KB\n\nIn the end the spin quantum was not completed because it took too long time and did not seem to return an updated value.\nIs my method of using the device wrong?\nplease help", "link": "https://discuss.pennylane.ai//t/every-step-revisit-qiskit-backend/289/1"}, "1": {"author": "nathan", "date": "1575470354854", "content": "Hi @Kyleyip,\nAs you\u2019ve noticed, using IBM\u2019s HW over the cloud means you will be sitting in the queue for every evaluation. This is a constraint with how IBM\u2019s HW access is set up. If you have access to Rigetti\u2019s hardware, you can reserve dedicated time on the QPU (no queue).\nOne common workflow is to first train on a simulator, then once the model is trained, use the hardware to evaluate the final real-world performance. It\u2019s usually just a one-line switch in your code to go between HW and simulator.2", "link": "https://discuss.pennylane.ai//t/every-step-revisit-qiskit-backend/289/2"}, "2": {"author": "Kyleyip", "date": "1575528593568", "content": "Hi @nathan ,\nThank you for your suggestions ,I will try to follow the workflow.\nI am wondering how to properly compare the performance of QML and classical machine learning. For example used to classify MNIST dataset.I care more about how to compare but not about comparison results.", "link": "https://discuss.pennylane.ai//t/every-step-revisit-qiskit-backend/289/3"}, "3": {"author": "nathan", "date": "1575555800355", "content": "Hi @Kyleyip\nAre you asking about what steps to go through to compare, or about possible figures of merit you might use to compare the two approaches?\nThe steps are pretty simple: treat your ML algorithm as a black box, and just count the resources or performance of either the QML or classical ML models.\nIn terms of figures of merit, you could look at a number of things:\n\ntraining performance (cost function value on training data)\ngeneralization performance (cost function value on test data)\nnumber of steps needed for convergence\nnumber of resources needed in model to achieve same level or performance\n\u201cwall time\u201d to train model\netc.\n", "link": "https://discuss.pennylane.ai//t/every-step-revisit-qiskit-backend/289/4"}, "4": {"author": "Kyleyip", "date": "1575634837186", "content": "thank you @nathan for your quick response.\nYour answer gives me a lot of inspiration:smiley:", "link": "https://discuss.pennylane.ai//t/every-step-revisit-qiskit-backend/289/5"}, "5": {"author": "Kyleyip", "date": "1575447361718", "content": "hi,\nI am trying to rotate a qubit using the ibmq device.But it calculate so slow and about 3min per step. I check my IBMQ Experience result and found it seems like every step the optimization is performed, the qnode must revisit the device.\nI am curious how to speed up the calculation and reduce the waiting time for the ibm device.\nCode\nimport pennylane as qml\nfrom pennylane import numpy as np\nfrom qiskit import IBMQ\nfrom qiskit.providers.ibmq import least_busy\nprovider = IBMQ.load_account()\nprint(\u201c\\n(IBMQ Backends)\u201d)\nfor backend in provider.backends():\nprint(backend.status())\ntry:\nleast_busy_device = least_busy(provider.backends(simulator=False))\nexcept:\nprint(\u201cAll devices are currently unavailable.\u201d)\nlbd = str(least_busy_device)\nprint(\"Running on current least busy device: \", lbd)\ndev1 = qml.device(\u201cqiskit.ibmq\u201d, wires=1, backend=lbd)\n@qml.qnode(dev1)\ndef circuit(params):\nqml.RX(params[0],wires=0)\nqml.RY(params[1],wires=0)\nreturn qml.expval(qml.PauliZ(0))\ndef cost(var):\nreturn circuit(var)\ninit_params = np.array([0.011,0.012])\nprint(cost(init_params))\nopt = qml.GradientDescentOptimizer(stepsize=0.4)\nsteps = 100\nparams = init_params\nfor i in range(steps):\nparams = opt.step(cost, params)\nif (i+1) % 5 == 0:\nprint(\u201cCost after step{:5d}:{:.7f}\u201d.format(i+1, cost(params)))\nprint(\u201cOptimizer rotation angles:{}\u201d.format(params))\nI delete my API_TOKEN in the code.\nand the result show in IBMQ Experience\n\n11996\u00d7504 24.8 KB\n\nTime spent on one step.\n\nWechatIMG41876\u00d7316 8.36 KB\n\nIn the end the spin quantum was not completed because it took too long time and did not seem to return an updated value.\nIs my method of using the device wrong?\nplease help", "link": "https://discuss.pennylane.ai//t/every-step-revisit-qiskit-backend/289/6"}}