{"0": {"author": "raghavv", "date": "1639757158910", "content": "Hi All,\nI tried to create Hamiltonian for the molecule reported in the work (https://www.nature.com/articles/s41524-021-00540-6 8). The work was carried out in IBM Qiskit, I wanted to create a ground state Hamiltonian of the molecule with Active Space invoked. It gave me a following error.\n\u201cUnable to allocate 255. GiB for an array with shape (430, 430, 430, 430) and data type float64\u201d .\nI am running the calc. on 370GB RAM and 48 core system. I also noticed that throughout the job, not all the cores were occupied. I am not sure if the process is parallelized or not. Kindly help me in this regard.\nI have attached the jupyter notebook I used to run the calculation for your kind reference. Also attached the files where no. of cores and memory occupied is noted down.", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/1"}, "1": {"author": "CatalinaAlbornoz", "date": "1639761363081", "content": "Hi @raghavv, thank you for your question!\nI don\u2019t see any code attached though. Could you please copy-paste the part of your code where you create the device?\nThanks!", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/2"}, "2": {"author": "raghavv", "date": "1639767936897", "content": "CPUDataDump_1Xanad.txt (20 KB) DataDumpMemoryfil_171221.txt (56 KB) PSPCz-Copy1.txt (24.3 KB)\nThanks for the reply @CatalinaAlbornoz. Attached the files.\nKindly change PSPCz-Copy1.txt into .ipynb file to view on Jupyter notebook.\nThank you.1 Reply", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/3"}, "3": {"author": "CatalinaAlbornoz", "date": "1640130428437", "content": "Hi @raghavv!\nThe molecule you\u2019re trying to simulate is way too big for your computer. I would suggest starting with a very small example and then start growing to larger ones. Have you tried with smaller molecules?", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/4"}, "4": {"author": "maliasadi", "date": "1640133847817", "content": "Hi @raghavv. Thank you for reaching out! I went through your Jupyter notebook and it seems this error is due to the overcommit handling mode in your OS. If you are using Linux, setting  overcommit_memory to 1 may fix the problem:\n $ echo 1 > /proc/sys/vm/overcommit_memory\nMoreover, this is also worth to try psi4 instead of pyscf as the error occurred in  pyscf, to do so you need to update your code as follows,\nH, qubits = qchem.molecular_hamiltonian(\n    symbols,\n    coordinates,\n    charge=0,\n    name='PSPCz',\n    mult=1,\n    basis='6-31G*',\n    package='psi4',\n   active_electrons=2,\n    active_orbitals=1,\n)\n\nThese are quantum chemistry packages used to solve the mean field electronic structure problem; you can find more information here 2. I hope these help to fix the problem.2", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/5"}, "5": {"author": "raghavv", "date": "1640193330520", "content": "@maliasadi. Thank you for kind response. It worked fine for a small molecule like NH3.\nWhen I run the same molecule I had reported earlier , I am getting the following error.\nError Starts\n/home/subbu/Raghav/2021/9_Sep/XANADU/OpenFermion-Psi4/openfermionpsi4/_run_psi4.py:224: Warning: No calculation saved. Psi4 segmentation fault possible.\nwarnings.warn('No calculation saved. \u2019\nFileNotFoundError                         Traceback (most recent call last)\n in \n~/psi4conda/envs/penny/lib/python3.8/site-packages/pennylane_qchem/qchem/structure.py in molecular_hamiltonian(symbols, coordinates, name, charge, mult, basis, package, active_electrons, active_orbitals, mapping, outpath, wires)\n829     hf_file = meanfield(symbols, coordinates, name, charge, mult, basis, package, outpath)\n830\n\u2013> 831     molecule = openfermion.MolecularData(filename=hf_file)\n832\n833     core, active = active_space(\n~/psi4conda/envs/penny/lib/python3.8/site-packages/openfermion/chem/molecular_data.py in init(self, geometry, basis, multiplicity, charge, description, filename, data_directory)\n343                 else:\n344                     self.filename = filename\n\u2013> 345                 self.load()\n346                 self.init_lazy_properties()\n347                 return\n~/psi4conda/envs/penny/lib/python3.8/site-packages/openfermion/chem/molecular_data.py in load(self)\n720         geometry = \n721\n\u2013> 722         with h5py.File(\"{}.hdf5\".format(self.filename), \u201cr\u201d) as f:\n723             # Load geometry:\n724             data = f[\u201cgeometry/atoms\u201d]\n~/psi4conda/envs/penny/lib/python3.8/site-packages/h5py/_hl/files.py in init(self, name, mode, driver, libver, userblock_size, swmr, rdcc_nslots, rdcc_nbytes, rdcc_w0, track_order, fs_strategy, fs_persist, fs_threshold, **kwds)\n440             with phil:\n441                 fapl = make_fapl(driver, libver, rdcc_nslots, rdcc_nbytes, rdcc_w0, **kwds)\n\u2013> 442                 fid = make_fid(name, mode, userblock_size,\n443                                fapl, fcpl=make_fcpl(track_order=track_order, fs_strategy=fs_strategy,\n444                                fs_persist=fs_persist, fs_threshold=fs_threshold),\n~/psi4conda/envs/penny/lib/python3.8/site-packages/h5py/_hl/files.py in make_fid(name, mode, userblock_size, fapl, fcpl, swmr)\n193         if swmr and swmr_support:\n194             flags |= h5f.ACC_SWMR_READ\n\u2013> 195         fid = h5f.open(name, flags, fapl=fapl)\n196     elif mode == \u2018r+\u2019:\n197         fid = h5f.open(name, h5f.ACC_RDWR, fapl=fapl)\nh5py/_objects.pyx in h5py._objects.with_phil.wrapper()\nh5py/_objects.pyx in h5py._objects.with_phil.wrapper()\nh5py/h5f.pyx in h5py.h5f.open()\nFileNotFoundError: [Errno 2] Unable to open file (unable to open file: name = \u2018./PSPCz_631Gd_psi4_6-31G*.hdf5\u2019, errno = 2, error message = \u2018No such file or directory\u2019, flags = 0, o_flags = 0)\nError Ends\nI am not sure what I am missing here, as this molecule did well with the basis set 3-21G. Also, I noticed that the job is running on only one core and the memory being used is 8 GB. Is there a keyword that I can use to increase the memory and assign more no. of cores to the job. I am not sure, just a guess, do you think making the job run in parallel and occupy more memory can solve the problem. I am working on linux system with 48 cores and about 380 GB RAM. Kindly help me in this regard.\nThank you. @CatalinaAlbornoz .", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/6"}, "6": {"author": "maliasadi", "date": "1640203573899", "content": "Hi @raghavv. This is de facto a FileNotFoundError and to fix this you should ensure that you have PSPCz_631Gd_psi4_6-31G*.hdf5 in the right path. In the following, I will do my best to address your concerns,\n\n\nTo run the job in parallel: PennyLane qchem uses pyscf through openfermion and you may want to try mpi4pyscf 3. Not sure how to do though!\n\n\nTo fix the memory problem: as I mentioned earlier this is on pyscf that is trying to load too many 2e integrals. If setting  overcommit_memory  to 1 didn\u2019t fix the problem, please try to decrease the basis set to sto-3g or maybe 6-31g.\n\n\nI hope taking advantage of smaller basis set fix this problem. Please let us know if you get any concerns or problems.\nPS. You may find \" Building molecular Hamiltonians 2\" tutorial helpful too.1", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/7"}, "7": {"author": "raghavv", "date": "1640502470264", "content": "Thank you for your kind reply @maliasadi and @CatalinaAlbornoz. I will summarize the list of calculations I have done below over the past few days.\nI ran the calculation systematically with 321G,631G and 631G* and cc-PVDZ. 6-31G* and ccPVDZ gave FileNotFoundError error. Initially my guess was that , in the linux shell , it is unable to write the file PSPCz_Psi4_631GD_psi4_6-31G* because in linux shell it can read it only as PSPCz_Psi4_631GD_psi4_6-31G * .out. However, when I tried to run the same molecule usign ccPVDZ, it gave the same error. To verify the observation, I also did the same Hamiltonian construction for the molecule NH3 using basis sets, STO3G,321G,6-31G,6-31G,ccPVDZ. And of them ran successfully. At this moment, I am unable to reason out why for the molecule PSPCz (45 Atoms, 200 electrons with Active Space=2 and no. of active electrons=2) is giving errors while using higher basis sets such as 6-31G or ccPVDZ. Kindly suggest how to proceed about this.\nPlease let me know if I am not clear.\nAlso, wish you a merry Christmas and happy a New Year 2022.\nThank you", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/8"}, "8": {"author": "sjahangiri", "date": "1641485118589", "content": "Hi @raghavv, thanks for the question and sorry for the late reply.\nIt seems to me that, for larger basis sets, the pyscf output hdf5 file is not created at all either because the Hartree-Fock iteerations crash or you ran out of disc space. Could you please run independednt pyscf calculations for the same molecule follwoing the examples provided here 3 and see if you can successfully compute the Hartree-Fock energy with pyscf? If you can run pyscf successfully, then we can track the problem through the pipeline. Please let me know if you face any issues with the calculations.", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/9"}, "9": {"author": "raghavv", "date": "1642140662203", "content": "Dear @sjahangiri, thank you for the kind response. Sorry for the delayed response. I have been trying to construct the Hamiltonian from outside of Pennylane as you have suggested. I have not had much of a success yet. I am working on it and will update once I figure it out. If you there are any other suggestions/directions, kindly request you to share. Will keep things updated sir. Thank you very much.", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/10"}, "10": {"author": "sjahangiri", "date": "1642170667629", "content": "Thanks @raghavv for the update. If you post the molecular geometry here, in xyz format for example, I can also give it a try.", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/11"}, "11": {"author": "raghavv", "date": "1642184929036", "content": "Dear Sir @sjahangiri, Below I have given the coordinates of water which I am trying to use PySCF or any other chemistry package to construct Hamiltonian and have it written in the form of .HDF5 file format.\nH \t-0.0399  -0.0038  0.0\nO \t 1.5780  0.8540 \t0.0\nH \t 2.7909  -0.5159   0.0\nThanks for your kind support sir.", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/12"}, "12": {"author": "sjahangiri", "date": "1642200188798", "content": "Hi @raghavv. The following code creates the molecular Hamiltonian for water step by step. Could you please run the code for both water and   PSPCz and let me know at what stage the code breaks? Please modify the molecular info given between the dashed lines for the new molecule. Thanks!\nimport pennylane as qml\nimport openfermion\nfrom pennylane import numpy as np\nfrom openfermionpyscf import run_pyscf\n\n#------------------------\nsymbols = [\"O\", \"H\", \"H\"]\nx = np.array([0.0000000000,  0.0000000000,  0.1501668459,\n              0.0000000000,  0.7580826553, -0.4856334229,\n              0.0000000000, -0.7580826553, -0.4856334229])\nmult = 1\ncharge = 0\nbasis = 'sto-3g'\ncore = [0, 1, 2, 3]\nactive = [4, 5]\nfilename = './water'\n#------------------------\n\ngeometry = [[s, tuple(x[3 * i : 3 * i + 3])] for i, s in enumerate(symbols)]\n\nmolecule = openfermion.MolecularData(geometry, basis, mult, charge, filename=filename)\n\nrun_pyscf(molecule, run_scf=1, verbose=0)\n\nmolecule_ = openfermion.MolecularData(filename=filename)\n\nht = molecule_.get_molecular_hamiltonian(occupied_indices=core, active_indices=active)\n\nhf = openfermion.transforms.get_fermion_operator(ht) # fermion hamiltonian\n\nhq = openfermion.transforms.jordan_wigner(hf) # qubit hamiltonian\n\nhp = qml.qchem.convert_observable(hq) # PennyLane hamiltonian\n\nprint(hp)\n\nThe output for water should be\n  (-74.19370628334303) [I0]\n+ (-0.15460393042639708) [Z2]\n+ (-0.15460393042639708) [Z3]\n+ (0.13038589407848444) [Z0]\n+ (0.13038589407848444) [Z1]\n+ (0.138284189609364) [Z0 Z2]\n+ (0.138284189609364) [Z1 Z3]\n+ (0.14767808197773874) [Z0 Z3]\n+ (0.14767808197773874) [Z1 Z2]\n+ (0.14966950988795605) [Z2 Z3]\n+ (0.22003977334376112) [Z0 Z1]\n+ (-0.00939389236837476) [Y0 Y1 X2 X3]\n+ (-0.00939389236837476) [X0 X1 Y2 Y3]\n+ (0.00939389236837476) [Y0 X1 X2 Y3]\n+ (0.00939389236837476) [X0 Y1 Y2 X3]", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/13"}, "13": {"author": "raghavv", "date": "1642209293249", "content": "Dear Sir, @sjahangiri . Thanks for sharing the code. It ran smooth for both water and PSPCz. Earlier, I had tried within Pennylane using \u201cqchem.molecular_hamiltonian\u201d  (as shown above) and it took me a very long time to complete the job and create a corresponding HDF5 with Hamiltonian written to it. It had ran on only one core. The code you suggested ran like a gem and completed within few minutes. Thank you so much for sharing the code. I have attached the code with PSPCz molecular coordinates for your kind reference. The qubit Hamiltonian that was output is pasted below for your quick reference.\nPSPCz_Hamiltonian_Externally.py (3.2 KB)\n(-322.1043666152533) [I0]\n\n(8.87674183162617) [Z2]\n(8.87674183162617) [Z3]\n(10.218927690523312) [Z0]\n(10.218927690523312) [Z1]\n(-0.006447940283844799) [Y1 Y3]\n(-0.006447940283844799) [X1 X3]\n(0.004959753825945462) [Y0 Y2]\n(0.004959753825945462) [X0 X2]\n(0.02545094913478638) [Z0 Z2]\n(0.02545094913478638) [Z1 Z3]\n(0.02674734205767252) [Z0 Z3]\n(0.02674734205767252) [Z1 Z2]\n(0.07156347202814556) [Z0 Z1]\n(0.08691649983952954) [Z2 Z3]\n(0.14484917836670383) [Y0 Z1 Y2]\n(0.14484917836670383) [X0 Z1 X2]\n(0.14484917836670383) [Y1 Z2 Y3]\n(0.14484917836670383) [X1 Z2 X3]\n(-0.0064479402838447985) [Y0 Z1 Y2 Z3]\n(-0.0064479402838447985) [X0 Z1 X2 Z3]\n(-0.0012963929228861414) [Y0 Y1 X2 X3]\n(-0.0012963929228861414) [X0 X1 Y2 Y3]\n(0.0012963929228861414) [Y0 X1 X2 Y3]\n(0.0012963929228861414) [X0 Y1 Y2 X3]\n(0.004959753825945462) [Z0 Y1 Z2 Y3]\n(0.004959753825945462) [Z0 X1 Z2 X3]\n\nI am not sure why using \u201cqchem.molecular_hamiltonian\u201d took such a long time to create the Hamiltonian or it even crashed. Here,  I am assuming calling the function \u2018qchem.molecular_hamiltonian\u2019 would still go to PySCF and ask for a Hartree-Fock level of calculation to be run. Then why does it take a longer time. Can you kindly clarify.\nPlease let me know if I am not clear.\nThank you.", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/14"}, "14": {"author": "sjahangiri", "date": "1642457218051", "content": "Hi @raghavv. This is a very interesting molecule!\nYes, qml.qchem.molecular_hamiltonian just calls openfermion under the hood.\nI computed the PSPCz Hamiltonian with both\nqml.qchem.molecular_hamiltonian and the stepwise code using sto-3g basis and 2 active electrons and 2 active orbitals. Both methods take the same time, ~11 minutes, and the size of the hdf5 files are both 4.8G. I am not sure why qml.qchem.molecular_hamiltonian takes longer time in your examples with larger basis sets.\nHowever, there is no fundamental difference between the two approaches. We are actually considering to refactor qml.qchem.molecular_hamiltonian and ask the users to call the external libraries on their side. So, you can safely use this code example if it works better for your system.\nPlease feel free to let us know if you have any other questions.1", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/15"}, "15": {"author": "raghavv", "date": "1643133957311", "content": "Dear Sir @sjahangiri. Sorry for the delayed response. I was trying to understand the code and the physics behind it all. As of now working on it will update here. Thank you very much for kind responses. Will keep you posted.", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/16"}, "16": {"author": "raghavv", "date": "1643376417043", "content": "Dear Sir @sjahangiri, hope you are well.\nI tried for quite sometime to combine the Pennylane\u2019s mol-geom-opt (Optimization of molecular geometries \u2014 PennyLane documentation) and adaptive circuit (Adaptive circuits for quantum chemistry \u2014 PennyLane documentation) tutorials to try to optimized molecule using Full Configuration Interaction method. After several attempts, I managed to combine the two codes , however I am unable to run optimization on the molecule. It only runs a single point calculation. I am not sure what I am missing here. It would be really helpful if you could kindly look into the code and suggest what I am missing.\nI have downloaded the jupyter notebook file in .py format to be able to upload here.\nKindly let me know if I am not clear enough.\nThank youCombined_Code_That_Run-For-Question.py (7.8 KB)", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/17"}, "17": {"author": "Alain_Delgado_Gran", "date": "1643400487935", "content": "Dear @raghavv,\nThank you very much for sharing your question.\nI noted that you are using/mixing functionalities from PennyLane, OpenFermion and PySCF. This is typically not a good strategy, it makes the code less readable and harder to debug. All the functionalities you need for molecular geometry optimization are available in PennyLane.\nI suggest the following:\n1- For now, please keep the adaptive method to select the excitation operations independent from the geometry optization code. I understand from your message that this is working fine.\n2- For the geometry optimization I recommend following the tutorial Optimization of molecular geometries.\n\nI noted you have used multiple functions to build the Hamiltonian of LiH molecule. This should be simpler. For the LiH molecule in a minimal basis sto-3g, you have 4 electrons and a total of 6 orbitals ( => 12 qubits). That would give you a relatively large Hamiltonian with 631 Pauli strings. The latter can be reduced by defining an active space. For example, you could chose 2 electrons and 3 active orbitals (=> 6 qubits, 62 Pauli strings). This can be done as follows:\n\nimport pennylane as qml\n\nsymbols = [\"Li\", \"H\"]\nx = np.array([0.0, 0.0, 0.0, 0.0, 0.0, 2.969280527], requires_grad=True)\n\ndef H(x):\n    return qml.qchem.molecular_hamiltonian(symbols, x, active_electrons=2,  active_orbitals=3))[0]\n\nPlease, note that from this point on your algorithm (including the quantum circuit) to optimize the geometry of LiH, within this approximation, is identical to the one in the above mentioned tutorial.\nCould you please try this and let us know whether it works for you or not? If it works, you can proceed to refine the simulation by including more orbitals and excitation operations.\nPlease, do not hesitate to come back to us. It is always a pleasure to help!\nBest regards.2", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/18"}, "18": {"author": "raghavv", "date": "1643842275950", "content": "Dear sir @Alain_Delgado_Gran. Thank you for the kind response. I tried the method you suggested to calculate the Hamiltonian of the molecule.\nI carried out the calculation for LiH and it worked. I was unable to construct Hamiltonian for the bigger molecule such as PSPCz which I had mentioned in the first comment. That is why @sjahangiri had suggested me a work around. However, as you mentioned when the Hamiltonian is borrowed from Openfermion, I guess the nuclear gradient did not run.\nI am trying to optimize molecule PSPCz using Pennylane. I will keep you updated on that.\nMeanwhile, I have a couple questions regarding the XYZ format that the code prints out and the molecular orbitals. I kindly request you to help me understand these.\n\nThe following code has the number \u20183\u2019 in it which properly prints out the coordinate in XYZ format. I am not sure what is the significance of the no. \u20183\u2019 in it. Also, it goes like 3i , 3i+1 and 3*i+2. I am not sure what these help us achieve, can you please help me understand.\n\nAlso looks like the coordinates being printed are in Bohr units. I would like to convert them into angstrom units. I tried something like ({x[3 * i]:.4f} *0.529177210903), but it did not work.\nfor i, atom in enumerate(symbols):\nprint(f\"  {atom}    {x[3 * i]:.4f}   {x[3 * i + 1]:.4f}   {x[3 * i + 2]:.4f}\")\n\nIs there a way to extract molecular orbital information and their energies in Pennylane.\n\nThank you.", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/19"}, "19": {"author": "Alain_Delgado_Gran", "date": "1643935155252", "content": "Dear @raghavv,\nI am glad to hear that the geometry optimization of the LiH molecule went well.\nRegarding your questions:\n\n\nThe following code has the number \u20183\u2019 in it which properly prints out the coordinate in XYZ format. I am not sure what is the significance of the no. \u20183\u2019 in it. Also, it goes like 3 i , 3 i+1 and 3*i+2. I am not sure what these help us achieve, can you please help me understand.\n\n\nThis 3 comes from the fact that the array x is a one-dimensional array storing 3N coordinates [x_0, x_1, ... , x_{3N-1}] where N is the number of atoms in your molecule. Thus, if you want to print the nuclear coordinates in the XYZ format, you have to account for this. For example, you can access the coordinates of the first atom (i=0) as: x = x[0], y = x[1], z=x[2] .\nFor printing the coordinates in Angstroms you could simply do:\nx_a = x*0.529177210903\n\nprint(\"%s %4s %8s %8s\" % (\"symbol\", \"x\", \"y\", \"z\"))\nfor i, atom in enumerate(symbols):\n    print(f\"  {atom}    {x_a[3 * i]:.4f}   {x_a[3 * i + 1]:.4f}   {x_a[3 * i + 2]:.4f}\")\n\n\n\nIs there a way to extract molecular orbital information and their energies in Pennylane.\n\n\nYes. You can use first the meanfield function to generate the file containing the molecular orbitals data for LiH. Next, you can use OpenFermion MolecularData class to access the energies and the wave functions of the orbitals. Please, see the example below:\nimport pennylane as qml\nfrom pennylane import numpy as np\nfrom openfermion import MolecularData\n\nsymb = [\"Li\", \"H\"]\nx = np.array([0.0, 0.0, 0.0, 0.0, 0.0, 2.969280527], requires_grad=True)\n\nlih = qml.qchem.meanfield(symb, x)\nmol = MolecularData(filename=lih)\n\nprint(\"Number of orbitals: \", mol.n_orbitals)\nprint(\"Orbital energies: \", mol.orbital_energies)\nprint(\"Expansion coefficients: \", mol.canonical_orbitals)\n\nFYI: New utility functions are being implemented in PennyLane to access this information natively, and also for visualizing atomic and molecular orbitals and much more! They will be released soon. Stay tuned!\nHope this helps. Do not hesitate to get back to us if you need further clarifications.\nThank you.1", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/20"}, "20": {"author": "raghavv", "date": "1644643028249", "content": "Dear Sir @Alain_Delgado_Gran. Thank you for sharing the information regarding significance of \u20183\u2019 in coordinates and helping to convert into from Bohr to Angstrom as well. Also, thanks for sharing the information on how to get the molecular orbitals.\nSometime ago, I had also tried to get molecular orbital energies using OpenFermion. I have written some lines to get the frontier molecular orbital energies and their positions. I am just sharing the lines below.\n\u201c\u201d\"\nimport pennylane as qml\nfrom pennylane import numpy as np\nfrom openfermion import MolecularData\nsymb = [\u201cLi\u201d, \u201cH\u201d]\nx = np.array([0.0, 0.0, 0.0, 0.0, 0.0, 2.969280527], requires_grad=True)\nlih = qml.qchem.meanfield(symb, x)\nmol_LiH = MolecularData(filename=lih)\nprint(\"Number of orbitals: \", mol_LiH.n_orbitals)\nprint(\"Orbital energies: \", mol_LiH.orbital_energies)\nprint(\"Expansion coefficients: \", mol_LiH.canonical_orbitals)\nmolecule = mol_LiH\nbasis = \u2018STO3G\u2019\ntotal_MOs = (molecule.canonical_orbitals.shape[0])\nprint(\u201cNo. of orbitals generated for basis set\u201d,basis, molecule.canonical_orbitals.shape[0])\nnum_electrons = molecule.n_electrons\noccupied_orbitals = round(num_electrons/2)\nprint(\u201cNo. of Occupied MOs for basis set\u201d,basis, occupied_orbitals)\nunoccupied_orbitals = total_MOs - occupied_orbitals\nprint(\u201cNo. of Unoccupied MOs for basis set\u201d,basis, unoccupied_orbitals)\nHOMO_position = round((num_electrons/2)-1)\nLUMO_position = round((num_electrons/2)+0)\nprint(\u201cThe HOMO and LUMO positions are\u201d,HOMO_position,LUMO_position)\nHOMO_energy = molecule.orbital_energies[HOMO_position]\nLUMO_energy = molecule.orbital_energies[LUMO_position]\nH_L_Gap = LUMO_energy - HOMO_energy\nprint(\u201cThe HOMO and LUMO energies are\u201d,round(HOMO_energy,5),round(LUMO_energy,5),\u201crespectively in Hartrees\u201d)\nprint(\u201cThe HOMO-LUMO gap is\u201d, round(H_L_Gap,5),\u201cin Hartrees\u201d)\nprint(\u201cThe HOMO-LUMO gap is\u201d, round(H_L_Gap*27.2114,3),\u201cin eV\u201d)\n\u201c\u201d\"\nAlso, regarding  constructing the Hamiltonian, can you kindly help me understand the reason for \u2019 [0] \u2019 in the following line.\n\u201cdef H(x):\nreturn qml.qchem.molecular_hamiltonian(symbols, x, active_electrons=2,  active_orbitals=3))[0]\u201d\nI am also working on obtaining ground state energies of a few small molecules. I will share the information with you after consolidating the results.\nThank you very much for your kind help.", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/21"}, "21": {"author": "Alain_Delgado_Gran", "date": "1644878088704", "content": "Hi @raghavv,\nThank you for the update.\nRegarding your question below:\n\nAlso, regarding constructing the Hamiltonian, can you kindly help me understand the reason for \u2019  [0]  \u2019 in the following line.\n\nPlease, note that the molecular_hamiltonian function returns a tuple containing the built Hamiltonian and the number of qubits needed to represent it. Since you only need the Hamiltonian (for the example we have been discussing) the H(x) function returns the first element of the tuple.\nThank you!1", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/22"}, "22": {"author": "raghavv", "date": "1644919217267", "content": "Dear Sir @Alain_Delgado_Gran, thank you for your kind response, I understand the importance of [0] now.\nI am also learning the the chemical reaction tutorial of Pennylane (https://pennylane.ai/qml/demos/tutorial_chemical_reactions.html) and I am just curious to know if we can calculate the zero point vibrational energy in Pennylane while calculating dissociation energy of the molecule.\nThank you.1 Reply", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/23"}, "23": {"author": "CatalinaAlbornoz", "date": "1644968497194", "content": "Hi @raghavv,\nIn principle you can calculate the zero point vibrational energy in PennyLane while calculating the dissociation energy of the molecule.\n@Alain_Delgado_Gran is looking into what functionalities are available for this.1", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/24"}, "24": {"author": "Alain_Delgado_Gran", "date": "1645118285222", "content": "Hi @raghavv,\nThank you for your question.\nYes, you can compute the zero-point energy correction from the vibrational frequencies of the molecule. In the harmonic approximation, they are given by the non-zero eigenvalues of the energy Hessian matrix defined as \\frac{\\partial^2E({\\bf R})}{\\partial R_i \\partial R_j}\u22022E(R)\u2202Ri\u2202Rj. Here,E({\\bf R})E(R) is the total electronic energy of the ground or excited states of the molecule and {\\bf R}R denotes the optimized nuclear coordinates for  a given electronic state (e.g. the ground state).\nAt present, we don\u2019t have a tutorial showing how to compute the Hessian matrix elements \\frac{\\partial^2E({\\bf R})}{\\partial R_i \\partial R_j}\u22022E(R)\u2202Ri\u2202Rj but I try to outline here how this can be done by combining different functionalities available in PennyLane. To that aim, I encourage you to check this paper 1 by Mitarai et al. about computing analytical energy derivatives for the VQE algorithm. This contribution reports the expression to compute the second-order derivative of the energy with respect to the nuclear coordinates (See Eqs. (8) and (10) ). Evaluating this expression requires the following:\n\nThe equilibrium geometry of the molecule and the optimized circuit parameters to prepare its (electronic) ground-state.\nCompute expectation values of the first- and second-order derivatives\nof the electronic Hamiltonian (defined for the optimized geometry) with respect to the nuclear coordinates. The Hamiltonian derivatives can be computed using finite-difference approximations or more accurate automatic differentiation tools 1 available in PennyLane.\nCompute the second-order derivative of the circuit (expectation value\nof the Hamiltonian) with respect to the gate parameters (Hessian of the circuit). See example here 1\n\n\nPlease,  see the attached notebook with a working example to compute the second-order energy derivative for the trihydrogen cation.\nHope this helps!\nThank you (3.7 KB)", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/25"}, "25": {"author": "CatalinaAlbornoz", "date": "1645147117889", "content": "Hi @raghavv, here\u2019s the file @Alain_Delgado_Gran had shared but in .py format. You should be able to paste it into a Jupyter notebook and run it.\nsecond_derivative.py (2.2 KB)1", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/26"}, "26": {"author": "raghavv", "date": "1645199715501", "content": "Thank you sir @Alain_Delgado_Gran for such a beautiful explanation with appropriate references. I will go thorugh them.\nThank you @CatalinaAlbornoz for sharing the code.\nI tried to run the code, upon running the line \" hessian = qml.jacobian(qml.grad(energy, argnum=0))(opt_param) \", it gave me the following error.\n\u201c\u201d\"\nAttributeError                            Traceback (most recent call last)\n/tmp/ipykernel_1076/1091415110.py in \n1 # compute the Hessian of the quantum circuit\n2 energy = expval(H(coord), opt_param)\n----> 3 hessian = qml.jacobian(qml.grad(energy, argnum=0))(opt_param)\n~/psi4conda/envs/pennylane/lib/python3.9/site-packages/pennylane/_grad.py in _jacobian_function(*args, **kwargs)\n179\n180         if len(argnum) == 1:\n\u2013> 181             return _jacobian(func, argnum[0])(*args, **kwargs)\n182\n183         return np.stack([_jacobian(func, arg)(*args, **kwargs) for arg in argnum]).T\n~/psi4conda/envs/pennylane/lib/python3.9/site-packages/autograd/wrap_util.py in nary_f(*args, **kwargs)\n18             else:\n19                 x = tuple(args[i] for i in argnum)\n\u2014> 20             return unary_operator(unary_f, x, *nary_op_args, **nary_op_kwargs)\n21         return nary_f\n22     return nary_operator\n~/psi4conda/envs/pennylane/lib/python3.9/site-packages/autograd/differential_operators.py in jacobian(fun, x)\n55     (out1, out2, \u2026) then the Jacobian has shape (out1, out2, \u2026, in1, in2, \u2026).\n56     \u201c\u201d\"\n\u2014> 57     vjp, ans = _make_vjp(fun, x)\n58     ans_vspace = vspace(ans)\n59     jacobian_shape = ans_vspace.shape + vspace(x).shape\n~/psi4conda/envs/pennylane/lib/python3.9/site-packages/autograd/core.py in make_vjp(fun, x)\n8 def make_vjp(fun, x):\n9     start_node = VJPNode.new_root()\n\u2014> 10     end_value, end_node =  trace(start_node, fun, x)\n11     if end_node is None:\n12         def vjp(g): return vspace(x).zeros()\n~/psi4conda/envs/pennylane/lib/python3.9/site-packages/autograd/tracer.py in trace(start_node, fun, x)\n8     with trace_stack.new_trace() as t:\n9         start_box = new_box(x, t, start_node)\n\u2014> 10         end_box = fun(start_box)\n11         if isbox(end_box) and end_box._trace == start_box._trace:\n12             return end_box._value, end_box._node\n~/psi4conda/envs/pennylane/lib/python3.9/site-packages/autograd/wrap_util.py in unary_f(x)\n13                 else:\n14                     subargs = subvals(args, zip(argnum, x))\n\u2014> 15                 return fun(*subargs, **kwargs)\n16             if isinstance(argnum, int):\n17                 x = args[argnum]\n~/psi4conda/envs/pennylane/lib/python3.9/site-packages/pennylane/_grad.py in call(self, *args, **kwargs)\n99         \u201c\u201d\u201cEvaluates the gradient function, and saves the function value\n100         calculated during the forward pass in :attr:.forward.\u201d\"\"\n\u2013> 101         grad_value, ans = self._get_grad_fn(args)(*args, **kwargs)\n102         self._forward = ans\n103         return grad_value\n~/psi4conda/envs/pennylane/lib/python3.9/site-packages/autograd/wrap_util.py in nary_f(*args, **kwargs)\n18             else:\n19                 x = tuple(args[i] for i in argnum)\n\u2014> 20             return unary_operator(unary_f, x, *nary_op_args, **nary_op_kwargs)\n21         return nary_f\n22     return nary_operator\n~/psi4conda/envs/pennylane/lib/python3.9/site-packages/pennylane/_grad.py in _grad_with_forward(fun, x)\n116         difference being that it returns both the gradient and the forward pass\n117         value.\"\"\"\n\u2013> 118         vjp, ans = _make_vjp(fun, x)\n119\n120         if not vspace(ans).size == 1:\n~/psi4conda/envs/pennylane/lib/python3.9/site-packages/autograd/core.py in make_vjp(fun, x)\n8 def make_vjp(fun, x):\n9     start_node = VJPNode.new_root()\n\u2014> 10     end_value, end_node =  trace(start_node, fun, x)\n11     if end_node is None:\n12         def vjp(g): return vspace(x).zeros()\n~/psi4conda/envs/pennylane/lib/python3.9/site-packages/autograd/tracer.py in trace(start_node, fun, x)\n8     with trace_stack.new_trace() as t:\n9         start_box = new_box(x, t, start_node)\n\u2014> 10         end_box = fun(start_box)\n11         if isbox(end_box) and end_box._trace == start_box._trace:\n12             return end_box._value, end_box._node\n~/psi4conda/envs/pennylane/lib/python3.9/site-packages/autograd/wrap_util.py in unary_f(x)\n13                 else:\n14                     subargs = subvals(args, zip(argnum, x))\n\u2014> 15                 return fun(*subargs, **kwargs)\n16             if isinstance(argnum, int):\n17                 x = args[argnum]\n/tmp/ipykernel_1076/3145879875.py in funct(params)\n2 def expval(obs, params):\n3     def funct(params):\n----> 4         return circuit(params, obs, wires=range(qubits))\n5     return funct\n~/psi4conda/envs/pennylane/lib/python3.9/site-packages/pennylane/qnode.py in call(self, *args, **kwargs)\n604         if self.mutable or self.qtape is None:\n605             # construct the tape\n\u2013> 606             self.construct(args, kwargs)\n607\n608         # Execute the tape.\n~/psi4conda/envs/pennylane/lib/python3.9/site-packages/pennylane/qnode.py in construct(self, args, kwargs)\n523\n524         with self.qtape:\n\u2013> 525             self.qfunc_output = self.func(*args, **kwargs)\n526\n527         if not isinstance(self.qfunc_output, Sequence):\n/tmp/ipykernel_1076/3280061623.py in circuit(params, obs, wires)\n6     qml.DoubleExcitation(params[0], wires=[0, 1, 2, 3])\n7     qml.DoubleExcitation(params[1], wires=[0, 1, 4, 5])\n----> 8     return qml.expval(obs)\n~/psi4conda/envs/pennylane/lib/python3.9/site-packages/pennylane/measure.py in expval(op)\n233     if not isinstance(op, (Observable, qml.Hamiltonian)):\n234         raise qml.QuantumFunctionError(\n\u2013> 235             \u201c{} is not an observable or Hamiltonian: cannot be used with expval\u201d.format(op.name)\n236         )\n237\nAttributeError: \u2018tensor\u2019 object has no attribute \u2018name\u2019\n\u201c\u201d\".\nI am not sure why this error pops up. Can you help me troubleshoot this.\nThankyou.", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/27"}, "27": {"author": "CatalinaAlbornoz", "date": "1645200177255", "content": "Hi @raghavv, what version of Python and PennyLane are you using?1", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/28"}, "28": {"author": "raghavv", "date": "1645203235591", "content": "Hi @CatalinaAlbornoz, Pennylane is 0.19.1 and Python is 3.8.12. Do you think I should upgrade.\nThank you.", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/29"}, "29": {"author": "Alain_Delgado_Gran", "date": "1645240016151", "content": "Hi @raghavv,\nYes, installing the latest release of PennyLane should fix the problem.\nLet us know.\nThank you.1", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/30"}, "30": {"author": "raghavv", "date": "1645240397960", "content": "Thank you sir @Alain_Delgado_Gran. Will try upgrading and update the progress.\nThank you", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/31"}, "31": {"author": "raghavv", "date": "1645502633075", "content": "Thank you sir @Alain_Delgado_Gran and @CatalinaAlbornoz. Will install latest Pennylane and try the Vibrational calculation and update.", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/32"}, "32": {"author": "sjahangiri", "date": "1645634698611", "content": "Hi @raghavv.\nRegarding this:\n\nI carried out the calculation for LiH and it worked. I was unable to construct Hamiltonian for the bigger molecule such as PSPCz which I had mentioned in the first comment. That is why @sjahangiri had suggested me a work around. However, as you mentioned when the Hamiltonian is borrowed from Openfermion, I guess the nuclear gradient did not run.\n\nYou can run the geometry optimisation tutorial by building your Hamiltonian directly with OpenFermion. You just need to replace the H(x) function in the tutorial with the following, or something similar:\ndef H(x):\n    geometry = [[s, tuple(x[3 * i : 3 * i + 3])] for i, s in enumerate(symbols)] # convert geometry to OF format\n    molecule = openfermion.MolecularData(geometry, basis, multiplicity, charge)  # create molecule object\n    hamiltonian = run_pyscf(molecule).get_molecular_hamiltonian()                # construct Hamiltonian\n    hamiltonian = jordan_wigner(get_fermion_operator(hamiltonian))               # transform to qubit basis\n    return qml.qchem.convert_observable(hamiltonian)                             # convert to PL Hamiltonian\n\nHowever, please note that the black-box finite_diff function used in this tutorial will be deprecated soon. You can also have a look at the differentiable Hartree-Fock implementation which allows computing the gradients with qml.grad.\nFinally, since your questions are important and other users might benefit from seeing them, I highly recommend creating new topics for different problems.\nHope this info is helpful.1", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/33"}, "33": {"author": "raghavv", "date": "1647512365445", "content": "Hi Sir @sjahangiri. I am very sorry for the delayed response. Thank you for your detailed explanations.\nThank you sharing the code to optimize geometry as well and sharing the status of finite_diff.\nAlso, regarding the questions and answers, thank you for the remark. I thought it will be easier to go through from the same thread. But I will compile the questions and answers given  by @sjahangiri, @CatalinaAlbornoz and @Alain_Delgado_Gran @maliasadi   and create seperate threads and post them so that it will be visible to all of us.\nI am working on optimizing the molecules. I will keep things updated.\nReally thankful  you for the immense support.", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/34"}, "34": {"author": "CatalinaAlbornoz", "date": "1647561016296", "content": "Thank you for the update @raghavv! Let us know how it goes when optimizing the molecules.", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/35"}, "35": {"author": "raghavv", "date": "1650911746223", "content": "Dear @sjahangiri @Alain_Delgado_Gran @CatalinaAlbornoz. Thank you for your most valuable inputs. With an objective to optimize molecules using quantum computers, I have tried to integrate geom_opt and adaptive-circuit codes, with the help discussions carried out here. I am attaching the status of work here.\nI will be grateful if you could kindly provide me a your esteemed feedback on it.\nThe attached file has extension .txt, kindly request you change it to .pdf for reading.\nPlease let me know if you need any further information.\nThank you\nVariationalandGeometryOptimization.txt (2.1 MB)", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/36"}, "36": {"author": "CatalinaAlbornoz", "date": "1650989459192", "content": "Hi @raghavv, thanks for sharing this with us. Here are a few notes:\n\nWe usually write PennyLane with a capital P and a capital L (no spaces in the word)\nYou can add a citation for PennyLane (the software itself, not the demos) like this:\nVille Bergholm, Josh Izaac, Maria Schuld, Christian Gogolin, M. Sohaib Alam, Shahnawaz Ahmed, Juan Miguel Arrazola, Carsten Blank, Alain Delgado, Soran Jahangiri, Keri McKiernan, Johannes Jakob Meyer, Zeyue Niu, Antal Sz\u00e1va, and Nathan Killoran.  PennyLane: Automatic differentiation of hybrid quantum-classical computations.  2018. arXiv:1811.04968\n\nYou write \u201cThe quantum computer by Xanadu uses the paltofrom called Pennylane\u201d. However PennyLane is a software that is not tied to any particular hardware so you might want to remove this phrase.\n\nI can\u2019t really comment on the contents but feel free to post this on our Slack and ask other members of the community to give you feedback.\nGreat initiative to write this!1", "link": "https://discuss.pennylane.ai//t/unable-to-construct-hamiltonian/1564/37"}}