{"0": {"author": "mass_of_15", "date": "1694952663664", "content": "Hi, how do I put error mitigation schemes into my Pennylane code?\nSo my code is:\n# QML\nimport pennylane as qml\n\nwires=4\ndev4 = qml.device('qiskit.ibmq', wires=wires, backend='ibm_nairobi',\n                  ibmqx_token='XXX', hub='ibm-q', group='open',\n                  project='main', shots=100)\ncoupling_map = dev4.backend.configuration().to_dict()[\"coupling_map\"]\n\ndev4.set_transpile_args(\n    **{\n        \"optimization_level\": 1,\n        \"coupling_map\": coupling_map,\n        \"layout_method\": \"sabre\",\n        \"routing_method\": \"sabre\",\n    }\n)\n\n@qml.qnode(dev4)\n\ndef CONVCircuit(phi, wires, i=0):\n    \"\"\"\n    quantum convolution Node\n    \"\"\"\n    # parameter\n    theta = np.pi / 2\n    \n    qml.RX(phi[0] * np.pi, wires=0)\n    qml.RX(phi[1] * np.pi, wires=1)\n    qml.RX(phi[2] * np.pi, wires=2)\n    qml.RX(phi[3] * np.pi, wires=3)\n\n    qml.CRZ(theta, wires=[1, 0])\n    qml.CRZ(theta, wires=[3, 2])\n    qml.CRX(theta, wires=[1, 0])\n    qml.CRX(theta, wires=[3, 2])\n    qml.CRZ(theta, wires=[2, 0])\n    qml.CRX(theta, wires=[2, 0])\n    \n    # Expectation value\n    measurement = qml.expval(qml.PauliZ(wires=0))\n\n    return measurement\n\nIn the above code, where should I put the error mitigation techniques like M3 error mitigation , Digital ZNE and others?\nIn Qiskit, we use:\noptions = Options(resilience_level = 1)\nwith Session(service=service, backend=backend):\n    # M3 error mitigation\n    sampler = Sampler(options=options)\n    job = sampler.run(circuits=qc, shots=4000)\n\nHow do I define such error mitigation schemes in Pennylane so that I can run it on IBM Quantum Hardware?", "link": "https://discuss.pennylane.ai//t/quantum-error-mitigation/3438/1"}, "1": {"author": "CatalinaAlbornoz", "date": "1695059298670", "content": "Hi @mass_of_15 ,\nYou can use PennyLane\u2019s error mitigation transforms. In the documentation for the zero-noise extrapolation transform 1 you will find some examples.\nThe key here is adding the transform right above your qnode. You can check this in the example below. Note: I ran it on qiskit.aer because the queues for the hardware backends are super long.\nWe also have a demo on differentiating quantum error mitigation transforms and another demo on error mitigation via zero noise extrapolation based on a recent IBM paper. They can both be great resources to get a deeper understanding on how these transforms work and to use them in PennyLane.\nimport pennylane as qml\nfrom pennylane import numpy as np\nimport qiskit_ibm_provider\nfrom pennylane.transforms import fold_global, richardson_extrapolate\n\n# Save your API token\nIBM_token = 'Your IBM Token'# Insert your token here\ntry:\n    qiskit_ibm_provider.IBMProvider()\nexcept:\n    qiskit_ibm_provider.IBMProvider.save_account(token=IBM_token, overwrite=True)\n\n# Define the backend that you will run on\nb = \"ibmq_qasm_simulator\"\n#b = \"ibm_perth\"\n\n# Create your device\n\"\"\"dev = qml.device(\n    \"qiskit.ibmq\",\n    wires=4,\n    backend=b,\n    shots = 10\n)\"\"\"\n\ndev = qml.device(\n    \"qiskit.aer\",\n    wires=4,\n    shots = 10\n)\n\n# Create a QNode\n@qml.transforms.mitigate_with_zne([1., 2., 3.], fold_global, richardson_extrapolate)\n@qml.qnode(dev)\ndef circuit(phi):\n    qml.CNOT(wires=[0, 1])\n    qml.CNOT(wires=[2, 3])\n    qml.CNOT(wires=[1, 3])\n    qml.CNOT(wires=[1, 2])\n    qml.CNOT(wires=[2, 3])\n    qml.CNOT(wires=[0, 3])\n    qml.RX(phi,wires=0)\n    return qml.probs(wires=[0, 1, 2, 3])\n\nphi=np.array(0.1,requires_grad=True)\n\n# Print your circuit\nprint(qml.draw(circuit)(phi))\ncircuit(phi)\n\nLet me know if you have any questions about this!", "link": "https://discuss.pennylane.ai//t/quantum-error-mitigation/3438/2"}, "2": {"author": "mass_of_15", "date": "1694952663664", "content": "Hi, how do I put error mitigation schemes into my Pennylane code?\nSo my code is:\n# QML\nimport pennylane as qml\n\nwires=4\ndev4 = qml.device('qiskit.ibmq', wires=wires, backend='ibm_nairobi',\n                  ibmqx_token='XXX', hub='ibm-q', group='open',\n                  project='main', shots=100)\ncoupling_map = dev4.backend.configuration().to_dict()[\"coupling_map\"]\n\ndev4.set_transpile_args(\n    **{\n        \"optimization_level\": 1,\n        \"coupling_map\": coupling_map,\n        \"layout_method\": \"sabre\",\n        \"routing_method\": \"sabre\",\n    }\n)\n\n@qml.qnode(dev4)\n\ndef CONVCircuit(phi, wires, i=0):\n    \"\"\"\n    quantum convolution Node\n    \"\"\"\n    # parameter\n    theta = np.pi / 2\n    \n    qml.RX(phi[0] * np.pi, wires=0)\n    qml.RX(phi[1] * np.pi, wires=1)\n    qml.RX(phi[2] * np.pi, wires=2)\n    qml.RX(phi[3] * np.pi, wires=3)\n\n    qml.CRZ(theta, wires=[1, 0])\n    qml.CRZ(theta, wires=[3, 2])\n    qml.CRX(theta, wires=[1, 0])\n    qml.CRX(theta, wires=[3, 2])\n    qml.CRZ(theta, wires=[2, 0])\n    qml.CRX(theta, wires=[2, 0])\n    \n    # Expectation value\n    measurement = qml.expval(qml.PauliZ(wires=0))\n\n    return measurement\n\nIn the above code, where should I put the error mitigation techniques like M3 error mitigation , Digital ZNE and others?\nIn Qiskit, we use:\noptions = Options(resilience_level = 1)\nwith Session(service=service, backend=backend):\n    # M3 error mitigation\n    sampler = Sampler(options=options)\n    job = sampler.run(circuits=qc, shots=4000)\n\nHow do I define such error mitigation schemes in Pennylane so that I can run it on IBM Quantum Hardware?", "link": "https://discuss.pennylane.ai//t/quantum-error-mitigation/3438/3"}}