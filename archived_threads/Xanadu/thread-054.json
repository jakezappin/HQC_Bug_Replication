{"0": {"author": "RX1", "date": "1663660555678", "content": "I tried to modify the quantum kernel Demo, but the following problem occurred. I haven\u2019t played Pennylane for a long time, and I didn\u2019t even know that the parameters (\u201cparams\u201d in code) now have dimensions. It has always been a one-dimensional vector before. There is also no documentation for the current parameter explaining why it automatically becomes a multidimensional vector. Please give a reasonable explanation of the custom parameter dimension.\ndef QuantumKernel(x, params, wires):\n    \"\"\"The embedding ansatz\"\"\"\n    i = 0\n    for j, wire in enumerate(wires):\n        qml.RZ(params[j], wires=[wire])\n        qml.Hadamard(wires=[wire])\n        qml.U1(2*x[i], wires=[wire])\n        i += 1\n    for i in range(len(x)):\n        for j in np.arange(i + 1, len(x), 1):\n            qml.CNOT(wires=[i,j])\n            qml.U1(2*(np.pi - x[i])*(np.pi - x[j]), wires=j)\n            qml.CNOT(wires=[i,j])\n\ninit_params = random_params(num_wires=X.shape[1], num_layers=1)\nprint(init_params, init_params.dtype)\nkernel_value = kernel(X[0], X[0], init_params)\nprint(kernel_value)\nqml.drawer.use_style('black_white')\nfig, ax = qml.draw_mpl(kernel_circuit, show_all_wires=True)(X[0], X[0], init_params)\nfig.set_size_inches((10, 5))\n#print(f\"The kernel value between the first and second datapoint is {kernel_value:.3f}\")\ninit_kernel = lambda x1, x2: kernel(x1, x2, init_params)\nprint(X)\nK_init = qml.kernels.square_kernel_matrix(X, init_kernel, assume_normalized_kernel=True)\n\nwith np.printoptions(precision=3, suppress=True):\n    print(K_init)\n\n\n[[[5.79224151 0.81098457 1.42666494]\n[3.92941447 0.87498623 4.73891606]]] float64\nValueError                                Traceback (most recent call last)\nInput In [102], in <cell line: 3>()\n1 init_params = random_params(num_wires=X.shape[1], num_layers=1)\n2 print(init_params, init_params.dtype)\n----> 3 kernel_value = kernel(X[0], X[0], init_params)\n4 print(kernel_value)\n5 qml.drawer.use_style(\u2018black_white\u2019)\nInput In [100], in kernel(x1, x2, params)\n42 def kernel(x1, x2, params):\n\u2014> 43     return kernel_circuit(x1, x2, params)[0]\nFile d:\\miniconda3\\lib\\site-packages\\pennylane\\qnode.py:610, in QNode.call(self, *args, **kwargs)\n607         set_shots(self._original_device, override_shots)(self._update_gradient_fn)()\n609 # construct the tape\n \u2192 610 self.construct(args, kwargs)\n612 cache = self.execute_kwargs.get(\u201ccache\u201d, False)\n613 using_custom_cache = (\n614     hasattr(cache, \u201cgetitem\u201d)\n615     and hasattr(cache, \u201csetitem\u201d)\n616     and hasattr(cache, \u201cdelitem\u201d)\n617 )\nFile d:\\miniconda3\\lib\\site-packages\\pennylane\\qnode.py:525, in QNode.construct(self, args, kwargs)\n522 self._tape = qml.tape.QuantumTape()\n524 with self.tape:\n \u2192 525     self._qfunc_output = self.func(*args, **kwargs)\n526 self._tape._qfunc_output = self._qfunc_output\n528 params = self.tape.get_parameters(trainable_only=False)\nInput In [100], in kernel_circuit(x1, x2, params)\n36 @qml.qnode(dev)\n37 def kernel_circuit(x1, x2, params):\n\u2014> 38     QuantumKernel(x1, params, wires)\n39     adjoint_ansatz(x2, params, wires)\n40     return qml.probs(wires=wires)\nInput In [100], in QuantumKernel(x, params, wires)\n8 i = 0\n9 for j, wire in enumerate(wires):\n\u2014> 10     qml.RZ(params[j], wires=[wire])\n11     qml.Hadamard(wires=[wire])\n12     qml.U1(2*x[i], wires=[wire])\nFile d:\\miniconda3\\lib\\site-packages\\pennylane\\ops\\qubit\\parametric_ops.py:253, in RZ.init(self, phi, wires, do_queue, id)\n252 def init(self, phi, wires, do_queue=True, id=None):\n \u2192 253     super().init(phi, wires=wires, do_queue=do_queue, id=id)\nFile d:\\miniconda3\\lib\\site-packages\\pennylane\\operation.py:1521, in Operation.init(self, wires, do_queue, id, *params)\n1518 def init(self, *params, wires=None, do_queue=True, id=None):\n1520     self._inverse = False\n \u2192 1521     super().init(*params, wires=wires, do_queue=do_queue, id=id)\n1523     # check the grad_recipe validity\n1524     if self.grad_recipe is None:\n1525         # Make sure grad_recipe is an iterable of correct length instead of None\nFile d:\\miniconda3\\lib\\site-packages\\pennylane\\operation.py:894, in Operator.init(self, wires, do_queue, id, *params)\n888 if self.num_wires not in {AllWires, AnyWires} and len(self._wires) != self.num_wires:\n889     raise ValueError(\n890         f\"{self.name}: wrong number of wires. \"\n891         f\"{len(self._wires)} wires given, {self.num_wires} expected.\"\n892     )\n \u2192 894 self._check_batching(params)\n896 self.data = list(params)  #: list[Any]: parameters of the operator\n898 if do_queue:\nFile d:\\miniconda3\\lib\\site-packages\\pennylane\\operation.py:935, in Operator.check_batching(self, params)\n930 ndims_matches = [\n931     (ndim == exp_ndim, ndim == exp_ndim + 1)\n932     for ndim, exp_ndim in zip(ndims, self.ndim_params)\n933 ]\n934 if not all(correct or batched for correct, batched in ndims_matches):\n \u2192 935     raise ValueError(\n936         f\"{self.name}: wrong number(s) of dimensions in parameters. \"\n937         f\"Parameters with ndims {ndims} passed, {self.ndim_params} expected.\"\n938     )\n940 first_dims = [\n941     qml.math.shape(p)[0] for (, batched), p in zip(ndims_matches, params) if batched\n942 ]\n943 if not qml.math.allclose(first_dims, first_dims[0]):\nValueError: RZ: wrong number(s) of dimensions in parameters. Parameters with ndims (2,) passed, (0,) expected.\n", "link": "https://discuss.pennylane.ai//t/rz-wrong-number-s-of-dimensions-in-parameters-parameters-with-ndims-2-passed-0-expected/2167/1"}, "1": {"author": "CatalinaAlbornoz", "date": "1663710737329", "content": "Hi @RX1, it\u2019s great to see that you\u2019re playing with PennyLane again!\n\u2018params\u2019 has always had a dimension. In fact, since you define the initial parameters (init_params), you are defining the dimension of params. However, not any dimension of init_params works, and this is why you\u2019re getting the error.\nThe RZ gate only takes 2 parameters: an angle and a wire (or set of wires). If init_params[0] isn\u2019t a number, then you will get an error.\nIn your case I can see that init_params[0] is a matrix so the RZ gate throws an error. My recommendation is to take a look at the shape of your data to make sure that it aligns with the shape of the original dataset in the demo. This will help reduce problems.", "link": "https://discuss.pennylane.ai//t/rz-wrong-number-s-of-dimensions-in-parameters-parameters-with-ndims-2-passed-0-expected/2167/2"}, "2": {"author": "RX1", "date": "1663660555678", "content": "I tried to modify the quantum kernel Demo, but the following problem occurred. I haven\u2019t played Pennylane for a long time, and I didn\u2019t even know that the parameters (\u201cparams\u201d in code) now have dimensions. It has always been a one-dimensional vector before. There is also no documentation for the current parameter explaining why it automatically becomes a multidimensional vector. Please give a reasonable explanation of the custom parameter dimension.\ndef QuantumKernel(x, params, wires):\n    \"\"\"The embedding ansatz\"\"\"\n    i = 0\n    for j, wire in enumerate(wires):\n        qml.RZ(params[j], wires=[wire])\n        qml.Hadamard(wires=[wire])\n        qml.U1(2*x[i], wires=[wire])\n        i += 1\n    for i in range(len(x)):\n        for j in np.arange(i + 1, len(x), 1):\n            qml.CNOT(wires=[i,j])\n            qml.U1(2*(np.pi - x[i])*(np.pi - x[j]), wires=j)\n            qml.CNOT(wires=[i,j])\n\ninit_params = random_params(num_wires=X.shape[1], num_layers=1)\nprint(init_params, init_params.dtype)\nkernel_value = kernel(X[0], X[0], init_params)\nprint(kernel_value)\nqml.drawer.use_style('black_white')\nfig, ax = qml.draw_mpl(kernel_circuit, show_all_wires=True)(X[0], X[0], init_params)\nfig.set_size_inches((10, 5))\n#print(f\"The kernel value between the first and second datapoint is {kernel_value:.3f}\")\ninit_kernel = lambda x1, x2: kernel(x1, x2, init_params)\nprint(X)\nK_init = qml.kernels.square_kernel_matrix(X, init_kernel, assume_normalized_kernel=True)\n\nwith np.printoptions(precision=3, suppress=True):\n    print(K_init)\n\n\n[[[5.79224151 0.81098457 1.42666494]\n[3.92941447 0.87498623 4.73891606]]] float64\nValueError                                Traceback (most recent call last)\nInput In [102], in <cell line: 3>()\n1 init_params = random_params(num_wires=X.shape[1], num_layers=1)\n2 print(init_params, init_params.dtype)\n----> 3 kernel_value = kernel(X[0], X[0], init_params)\n4 print(kernel_value)\n5 qml.drawer.use_style(\u2018black_white\u2019)\nInput In [100], in kernel(x1, x2, params)\n42 def kernel(x1, x2, params):\n\u2014> 43     return kernel_circuit(x1, x2, params)[0]\nFile d:\\miniconda3\\lib\\site-packages\\pennylane\\qnode.py:610, in QNode.call(self, *args, **kwargs)\n607         set_shots(self._original_device, override_shots)(self._update_gradient_fn)()\n609 # construct the tape\n \u2192 610 self.construct(args, kwargs)\n612 cache = self.execute_kwargs.get(\u201ccache\u201d, False)\n613 using_custom_cache = (\n614     hasattr(cache, \u201cgetitem\u201d)\n615     and hasattr(cache, \u201csetitem\u201d)\n616     and hasattr(cache, \u201cdelitem\u201d)\n617 )\nFile d:\\miniconda3\\lib\\site-packages\\pennylane\\qnode.py:525, in QNode.construct(self, args, kwargs)\n522 self._tape = qml.tape.QuantumTape()\n524 with self.tape:\n \u2192 525     self._qfunc_output = self.func(*args, **kwargs)\n526 self._tape._qfunc_output = self._qfunc_output\n528 params = self.tape.get_parameters(trainable_only=False)\nInput In [100], in kernel_circuit(x1, x2, params)\n36 @qml.qnode(dev)\n37 def kernel_circuit(x1, x2, params):\n\u2014> 38     QuantumKernel(x1, params, wires)\n39     adjoint_ansatz(x2, params, wires)\n40     return qml.probs(wires=wires)\nInput In [100], in QuantumKernel(x, params, wires)\n8 i = 0\n9 for j, wire in enumerate(wires):\n\u2014> 10     qml.RZ(params[j], wires=[wire])\n11     qml.Hadamard(wires=[wire])\n12     qml.U1(2*x[i], wires=[wire])\nFile d:\\miniconda3\\lib\\site-packages\\pennylane\\ops\\qubit\\parametric_ops.py:253, in RZ.init(self, phi, wires, do_queue, id)\n252 def init(self, phi, wires, do_queue=True, id=None):\n \u2192 253     super().init(phi, wires=wires, do_queue=do_queue, id=id)\nFile d:\\miniconda3\\lib\\site-packages\\pennylane\\operation.py:1521, in Operation.init(self, wires, do_queue, id, *params)\n1518 def init(self, *params, wires=None, do_queue=True, id=None):\n1520     self._inverse = False\n \u2192 1521     super().init(*params, wires=wires, do_queue=do_queue, id=id)\n1523     # check the grad_recipe validity\n1524     if self.grad_recipe is None:\n1525         # Make sure grad_recipe is an iterable of correct length instead of None\nFile d:\\miniconda3\\lib\\site-packages\\pennylane\\operation.py:894, in Operator.init(self, wires, do_queue, id, *params)\n888 if self.num_wires not in {AllWires, AnyWires} and len(self._wires) != self.num_wires:\n889     raise ValueError(\n890         f\"{self.name}: wrong number of wires. \"\n891         f\"{len(self._wires)} wires given, {self.num_wires} expected.\"\n892     )\n \u2192 894 self._check_batching(params)\n896 self.data = list(params)  #: list[Any]: parameters of the operator\n898 if do_queue:\nFile d:\\miniconda3\\lib\\site-packages\\pennylane\\operation.py:935, in Operator.check_batching(self, params)\n930 ndims_matches = [\n931     (ndim == exp_ndim, ndim == exp_ndim + 1)\n932     for ndim, exp_ndim in zip(ndims, self.ndim_params)\n933 ]\n934 if not all(correct or batched for correct, batched in ndims_matches):\n \u2192 935     raise ValueError(\n936         f\"{self.name}: wrong number(s) of dimensions in parameters. \"\n937         f\"Parameters with ndims {ndims} passed, {self.ndim_params} expected.\"\n938     )\n940 first_dims = [\n941     qml.math.shape(p)[0] for (, batched), p in zip(ndims_matches, params) if batched\n942 ]\n943 if not qml.math.allclose(first_dims, first_dims[0]):\nValueError: RZ: wrong number(s) of dimensions in parameters. Parameters with ndims (2,) passed, (0,) expected.\n", "link": "https://discuss.pennylane.ai//t/rz-wrong-number-s-of-dimensions-in-parameters-parameters-with-ndims-2-passed-0-expected/2167/3"}}