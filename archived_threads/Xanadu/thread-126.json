{"0": {"author": "sillygoose", "date": "1686347903050", "content": "Hello! I am trying to optimize the linear entropy of a time evolved, then traced out density matrix using pennylane. The Hamiltonian used to time evolve my state is what is being parameterized.\nHowever, I receive an error: AttributeError: 'ArrayBox' object has no attribute 'dot'. Any help in solving this error and/or pointing me towards a better way to optimize the linear entropy of a time evolved, then traced out density matrix would be greatly appreciated! What I am doing is precisely the following.\nFirst, I am dealing with qubit systems. Let us fix the system to be a system of three qubits and define an initial density matrix of this three qubit system. I will also define the parameters to be optimized.\nimport pennylane as qml\nfrom pennylane import numpy as np\nimport jax\nimport qutip as qtp\nfrom scipy.optimize import minimize\n\nn = 3 # total number of qubits\nd = 2**n # dimension of composite system\nH = isingHam # native Hamiltonian\ntau = 1 # characteristic time\n\nrho = np.zeros((d, d), dtype=np.complex128)\nval = 0.25\nrho[0, 0] = val\nrho[1, 1] = val\nrho[2, 2] = val\nrho[3, 3] = val\nrho = np.array(rho) # initial density matrix\n\nwireList = list(range(n))\nthetas = np.array(np.random.randn((d**2-1), requires_grad = True)) # random initial parameters for optimization\n\nI also start with a fixed Hamiltonian, say the 1D Ising model Hamiltonian with boundary conditions:\ncoeffs = [0.5]*3\nops = [qml.PauliZ(0) @ qml.PauliZ(1), qml.PauliZ(1) @ qml.PauliZ(2), qml.PauliZ(0) @ qml.PauliZ(2)]\nisingHam = qml.Hamiltonian(coeffs, ops) # native Hamiltonian\n\nNext, I time evolve the initial density matrix by a \u201cscrambled Hamiltonian\u201d and then trace out of the environment of the initial density matrix. By \u201cscrambled Hamiltonian\u201d, I mean the fixed Hamiltonian defined earlier conjugated by a special unitary operator, parameterized by the thetas.\ndevRho = qml.device(\"default.mixed\", wires=3)\n@qml.qnode(devRho)\ndef processRho(n, H, tau, thetas, rho):\n    '''\n    Time evolves rho using scrambled Hamiltonian by characteristic time, then traces out of environment.\n    Inputs:\n     - n: total number of qubits\n     - H: native Hamiltonian to be scrambled\n     - tau: characteristic time\n     - thetas: parameters to scramble H\n     - rho: initial density matrix\n    \n    Outputs:\n     - rhoTau: time evolved, then traced out density matrix\n    '''\n    qml.QubitDensityMatrix(rho, wires=wireList)\n    qml.adjoint(qml.SpecialUnitary(thetas, wires=wireList))\n    qml.ApproxTimeEvolution(H, tau, 100)\n    qml.SpecialUnitary(thetas, wires=wireList)\n    return qml.density_matrix([0])\n\n#print(qml.draw(circuit)(n, isingHam, tau, thetas, rho))\n\nI initialize the reduced density matrix returned from processRho() and take its purity. Finally, I define my cost function, i.e. the linear entropy:\n@qml.qnode(devRho)\ndef purity(thetas):\n    '''\n    Initializes a density matrix and takes its purity.\n    '''\n    qml.QubitDensityMatrix(processRho(n, H, tau, thetas, rho), wires=0)\n    return qml.purity(0)\n\ndef cost(thetas):\n    '''\n    Computes linear entropy from purity. \n    '''\n    return 1 - purity(thetas)\n\nJust as a simple test, I thought to test optimization using:\nminimize(purity, thetas, method='BFGS', jac=qml.grad(cost, argnum=0))\n\nHowever, running all of the code (in particular, running the optimization) gives me the error message:\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n<ipython-input-69-1d027bdc7de1> in <module>\n----> 1 minimize(purity, thetas, method='BFGS', jac=qml.grad(cost, argnum=0))\n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/optimize/_minimize.py in minimize(fun, x0, args, method, jac, hess, hessp, bounds, constraints, tol, callback, options)\n    612         return _minimize_cg(fun, x0, args, jac, callback, **options)\n    613     elif meth == 'bfgs':\n--> 614         return _minimize_bfgs(fun, x0, args, jac, callback, **options)\n    615     elif meth == 'newton-cg':\n    616         return _minimize_newtoncg(fun, x0, args, jac, hess, hessp, callback,\n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/optimize/optimize.py in _minimize_bfgs(fun, x0, args, jac, callback, gtol, norm, eps, maxiter, disp, return_all, finite_diff_rel_step, **unknown_options)\n   1133         maxiter = len(x0) * 200\n   1134 \n-> 1135     sf = _prepare_scalar_function(fun, x0, jac, args=args, epsilon=eps,\n   1136                                   finite_diff_rel_step=finite_diff_rel_step)\n   1137 \n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/optimize/optimize.py in _prepare_scalar_function(fun, x0, jac, args, bounds, epsilon, finite_diff_rel_step, hess)\n    259     # ScalarFunction caches. Reuse of fun(x) during grad\n    260     # calculation reduces overall function evaluations.\n--> 261     sf = ScalarFunction(fun, x0, args, grad, hess,\n    262                         finite_diff_rel_step, bounds, epsilon=epsilon)\n    263 \n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/optimize/_differentiable_functions.py in __init__(self, fun, x0, args, grad, hess, finite_diff_rel_step, finite_diff_bounds, epsilon)\n    153 \n    154         self._update_grad_impl = update_grad\n--> 155         self._update_grad()\n    156 \n    157         # Hessian Evaluation\n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/optimize/_differentiable_functions.py in _update_grad(self)\n    229     def _update_grad(self):\n    230         if not self.g_updated:\n--> 231             self._update_grad_impl()\n    232             self.g_updated = True\n    233 \n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/optimize/_differentiable_functions.py in update_grad()\n    143 \n    144             def update_grad():\n--> 145                 self.g = grad_wrapped(self.x)\n    146 \n    147         elif grad in FD_METHODS:\n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/optimize/_differentiable_functions.py in grad_wrapped(x)\n    140             def grad_wrapped(x):\n    141                 self.ngev += 1\n--> 142                 return np.atleast_1d(grad(x, *args))\n    143 \n    144             def update_grad():\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/_grad.py in __call__(self, *args, **kwargs)\n    115             return ()\n    116 \n--> 117         grad_value, ans = grad_fn(*args, **kwargs)  # pylint: disable=not-callable\n    118         self._forward = ans\n    119 \n\n~/opt/anaconda3/lib/python3.8/site-packages/autograd/wrap_util.py in nary_f(*args, **kwargs)\n     18             else:\n     19                 x = tuple(args[i] for i in argnum)\n---> 20             return unary_operator(unary_f, x, *nary_op_args, **nary_op_kwargs)\n     21         return nary_f\n     22     return nary_operator\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/_grad.py in _grad_with_forward(fun, x)\n    133         difference being that it returns both the gradient *and* the forward pass\n    134         value.\"\"\"\n--> 135         vjp, ans = _make_vjp(fun, x)\n    136 \n    137         if not vspace(ans).size == 1:\n\n~/opt/anaconda3/lib/python3.8/site-packages/autograd/core.py in make_vjp(fun, x)\n      8 def make_vjp(fun, x):\n      9     start_node = VJPNode.new_root()\n---> 10     end_value, end_node =  trace(start_node, fun, x)\n     11     if end_node is None:\n     12         def vjp(g): return vspace(x).zeros()\n\n~/opt/anaconda3/lib/python3.8/site-packages/autograd/tracer.py in trace(start_node, fun, x)\n      8     with trace_stack.new_trace() as t:\n      9         start_box = new_box(x, t, start_node)\n---> 10         end_box = fun(start_box)\n     11         if isbox(end_box) and end_box._trace == start_box._trace:\n     12             return end_box._value, end_box._node\n\n~/opt/anaconda3/lib/python3.8/site-packages/autograd/wrap_util.py in unary_f(x)\n     13                 else:\n     14                     subargs = subvals(args, zip(argnum, x))\n---> 15                 return fun(*subargs, **kwargs)\n     16             if isinstance(argnum, int):\n     17                 x = args[argnum]\n\n<ipython-input-68-d9c8029c0ea7> in cost(thetas)\n     11     Computes linear entropy from purity.\n     12     '''\n---> 13     return 1 - purity(thetas)\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/qnode.py in __call__(self, *args, **kwargs)\n    851 \n    852         # construct the tape\n--> 853         self.construct(args, kwargs)\n    854 \n    855         cache = self.execute_kwargs.get(\"cache\", False)\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/qnode.py in construct(self, args, kwargs)\n    755             self.interface = qml.math.get_interface(*args, *list(kwargs.values()))\n    756 \n--> 757         self._tape = make_qscript(self.func)(*args, **kwargs)\n    758         self._qfunc_output = self.tape._qfunc_output\n    759 \n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/tape/qscript.py in wrapper(*args, **kwargs)\n   1376     def wrapper(*args, **kwargs):\n   1377         with AnnotatedQueue() as q:\n-> 1378             result = fn(*args, **kwargs)\n   1379 \n   1380         qscript = QuantumScript.from_queue(q)\n\n<ipython-input-68-d9c8029c0ea7> in purity(thetas)\n      4     Initializes a density matrix and takes its purity.\n      5     '''\n----> 6     qml.QubitDensityMatrix(processRho(n, H, tau, thetas, rho), wires=0)\n      7     return qml.purity(0)\n      8 \n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/qnode.py in __call__(self, *args, **kwargs)\n    865                 self.execute_kwargs.pop(\"mode\")\n    866             # pylint: disable=unexpected-keyword-arg\n--> 867             res = qml.execute(\n    868                 [self.tape],\n    869                 device=self.device,\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/interfaces/execution.py in execute(tapes, device, gradient_fn, interface, grad_on_execution, gradient_kwargs, cache, cachesize, max_diff, override_shots, expand_fn, max_expansion, device_batch_transform)\n    405     if gradient_fn == \"backprop\" or interface is None:\n    406         return batch_fn(\n--> 407             qml.interfaces.cache_execute(\n    408                 batch_execute, cache, return_tuple=False, expand_fn=expand_fn\n    409             )(tapes)\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/interfaces/execution.py in wrapper(tapes, **kwargs)\n    202         else:\n    203             # execute all unique tapes that do not exist in the cache\n--> 204             res = fn(execution_tapes.values(), **kwargs)\n    205 \n    206         final_res = []\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/interfaces/execution.py in fn(tapes, **kwargs)\n    128         def fn(tapes: Sequence[QuantumTape], **kwargs):  # pylint: disable=function-redefined\n    129             tapes = [expand_fn(tape) for tape in tapes]\n--> 130             return original_fn(tapes, **kwargs)\n    131 \n    132     @wraps(fn)\n\n~/opt/anaconda3/lib/python3.8/contextlib.py in inner(*args, **kwds)\n     73         def inner(*args, **kwds):\n     74             with self._recreate_cm():\n---> 75                 return func(*args, **kwds)\n     76         return inner\n     77 \n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/_qubit_device.py in batch_execute(self, circuits)\n    586             self.reset()\n    587 \n--> 588             res = self.execute(circuit)\n    589             results.append(res)\n    590 \n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/devices/default_mixed.py in execute(self, circuit, **kwargs)\n    657                 wires_list.append(m.wires)\n    658             self.measured_wires = qml.wires.Wires.all_wires(wires_list)\n--> 659         return super().execute(circuit, **kwargs)\n    660 \n    661     def _execute_legacy(self, circuit, **kwargs):\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/_qubit_device.py in execute(self, circuit, **kwargs)\n    316 \n    317         # apply all circuit operations\n--> 318         self.apply(circuit.operations, rotations=self._get_diagonalizing_gates(circuit), **kwargs)\n    319 \n    320         # generate computational basis samples\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/devices/default_mixed.py in apply(self, operations, rotations, **kwargs)\n    725 \n    726         for operation in operations:\n--> 727             self._apply_operation(operation)\n    728 \n    729         # store the pre-rotated state\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/devices/default_mixed.py in _apply_operation(self, operation)\n    589             return\n    590 \n--> 591         matrices = self._get_kraus(operation)\n    592 \n    593         if operation in diagonal_in_z_basis:\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/devices/default_mixed.py in _get_kraus(self, operation)\n    280             return operation.kraus_matrices()\n    281 \n--> 282         return [operation.matrix()]\n    283 \n    284     def _apply_channel(self, kraus, wires):\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/operation.py in matrix(self, wire_order)\n    743             tensor_like: matrix representation\n    744         \"\"\"\n--> 745         canonical_matrix = self.compute_matrix(*self.parameters, **self.hyperparameters)\n    746 \n    747         if wire_order is None or self.wires == Wires(wire_order):\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/ops/qubit/special_unitary.py in compute_matrix(theta, num_wires)\n    447             # jax.numpy.expm does not support broadcasting\n    448             return qml.math.stack([qml.math.expm(1j * _A) for _A in A])\n--> 449         return qml.math.expm(1j * A)\n    450 \n    451     def get_one_parameter_generators(self, interface=None):\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/math/multi_dispatch.py in wrapper(*args, **kwargs)\n    149             kwargs[\"like\"] = interface\n    150 \n--> 151             return fn(*args, **kwargs)\n    152 \n    153         return wrapper\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/math/multi_dispatch.py in expm(tensor, like)\n    815     from scipy.linalg import expm as scipy_expm\n    816 \n--> 817     return scipy_expm(tensor)\n    818 \n    819 \n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/linalg/matfuncs.py in expm(A)\n    253     # Input checking and conversion is provided by sparse.linalg.expm().\n    254     import scipy.sparse.linalg\n--> 255     return scipy.sparse.linalg.expm(A)\n    256 \n    257 \n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/sparse/linalg/matfuncs.py in expm(A)\n    589             [  0.        ,   0.        ,  20.08553692]])\n    590     \"\"\"\n--> 591     return _expm(A, use_exact_onenorm='auto')\n    592 \n    593 \n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/sparse/linalg/matfuncs.py in _expm(A, use_exact_onenorm)\n    638 \n    639     # Try Pade order 3.\n--> 640     eta_1 = max(h.d4_loose, h.d6_loose)\n    641     if eta_1 < 1.495585217958292e-002 and _ell(h.A, 3) == 0:\n    642         U, V = h.pade3()\n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/sparse/linalg/matfuncs.py in d4_loose(self)\n    441     def d4_loose(self):\n    442         if self.use_exact_onenorm:\n--> 443             return self.d4_tight\n    444         if self._d4_exact is not None:\n    445             return self._d4_exact\n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/sparse/linalg/matfuncs.py in d4_tight(self)\n    417     def d4_tight(self):\n    418         if self._d4_exact is None:\n--> 419             self._d4_exact = _onenorm(self.A4)**(1/4.)\n    420         return self._d4_exact\n    421 \n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/sparse/linalg/matfuncs.py in A4(self)\n    390         if self._A4 is None:\n    391             self._A4 = _smart_matrix_product(\n--> 392                     self.A2, self.A2, structure=self.structure)\n    393         return self._A4\n    394 \n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/sparse/linalg/matfuncs.py in A2(self)\n    382     def A2(self):\n    383         if self._A2 is None:\n--> 384             self._A2 = _smart_matrix_product(\n    385                     self.A, self.A, structure=self.structure)\n    386         return self._A2\n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/sparse/linalg/matfuncs.py in _smart_matrix_product(A, B, alpha, structure)\n    164     else:\n    165         if alpha is None:\n--> 166             out = A.dot(B)\n    167         else:\n    168             out = alpha * A.dot(B)\n\nAttributeError: 'ArrayBox' object has no attribute 'dot'\n\nHere is my output from qml.about():\nName: PennyLane\nVersion: 0.30.0\nSummary: PennyLane is a Python quantum machine learning library by Xanadu Inc.\nHome-page: https://github.com/XanaduAI/pennylane\nAuthor: \nAuthor-email: \nLicense: Apache License 2.0\nLocation: /Users/carl/opt/anaconda3/lib/python3.8/site-packages\nRequires: appdirs, autograd, autoray, cachetools, networkx, numpy, pennylane-lightning, requests, rustworkx, scipy, semantic-version, toml\nRequired-by: PennyLane-Lightning\n\nPlatform info:           macOS-10.16-x86_64-i386-64bit\nPython version:          3.8.8\nNumpy version:           1.22.0\nScipy version:           1.6.2\nInstalled devices:\n- default.gaussian (PennyLane-0.30.0)\n- default.mixed (PennyLane-0.30.0)\n- default.qubit (PennyLane-0.30.0)\n- default.qubit.autograd (PennyLane-0.30.0)\n- default.qubit.jax (PennyLane-0.30.0)\n- default.qubit.tf (PennyLane-0.30.0)\n- default.qubit.torch (PennyLane-0.30.0)\n- default.qutrit (PennyLane-0.30.0)\n- null.qubit (PennyLane-0.30.0)\n- lightning.qubit (PennyLane-Lightning-0.30.0)\n", "link": "https://discuss.pennylane.ai//t/attributeerror-when-optimizing-purity-of-reduced-density-matrix/3032/1"}, "1": {"author": "Solomon", "date": "1686481697595", "content": "See these:\n\ngithub.com/HIPS/autograd\n\n\n\n\n\n\n\n\nAttributeError: 'ArrayBox' object has no attribute 'exp' (very simple code example)  1\n\n\n\n        opened \n\n\n\nOct 12, 2018\n\n\n\n          closed \n\n\n\nOct 12, 2018\n\n\n\n\n\n          Duncanswilson\n        \n\n\n\n\n\n\n\nI'm having trouble getting anything to work the way I'm defining my functions, i\u2026t's probably user error, but my example is terse. \n\nI'm just trying to define a simple neural network and keep running into issues using `np.tanh()` or `np.exp()` and the only similar errors I could find are from having nested data structures, which I don't have. \n\nHere's my full code snippet: \n\n```\nimport autograd.numpy as np\nfrom autograd import grad\n\naction_dim = 2\nfeature_dim = 6\nlayer_dim = 4 \nw1 = np.random.rand(feature_dim, layer_dim)\nb1 = np.random.rand(layer_dim)\nw2 = np.random.rand(layer_dim, action_dim)\nb2 = np.random.rand(action_dim)\n\ndef continuous_policy_function(w1, b1, w2, b2):\n    x = observation.dot(w1) + b1\n    x = 1.0 / (1.0 + np.exp(-x))  # sigmoid \"squashing\" function to interval [0,1]\n    out = x.dot(w2) + b2\n    return out \n\ngrad_function = grad(continuous_policy_function)\nobservation = np.random.rand(feature_dim)\naction = continuous_policy_function(w1, b1, w2, b2)\nprint(grad_function(w1, b1, w2, b2))\n```\n\nand the full trace: \n```\nTraceback (most recent call last):\n  File \"annoying_autograd.py\", line 55, in <module>\n    print(grad_function(w1, b1, w2, b2))\n  File \"/usr/local/Cellar/python3/3.6.4/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/autograd/wrap_util.py\", line 20, in nary_f\n    return unary_operator(unary_f, x, *nary_op_args, **nary_op_kwargs)\n  File \"/usr/local/Cellar/python3/3.6.4/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/autograd/differential_operators.py\", line 24, in grad\n    vjp, ans = _make_vjp(fun, x)\n  File \"/usr/local/Cellar/python3/3.6.4/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/autograd/core.py\", line 10, in make_vjp\n    end_value, end_node =  trace(start_node, fun, x)\n  File \"/usr/local/Cellar/python3/3.6.4/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/autograd/tracer.py\", line 10, in trace\n    end_box = fun(start_box)\n  File \"/usr/local/Cellar/python3/3.6.4/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/autograd/wrap_util.py\", line 15, in unary_f\n    return fun(*subargs, **kwargs)\n  File \"annoying_autograd.py\", line 29, in continuous_policy_function\n    x = 1.0 / (1.0 + np.exp(-x))  # sigmoid \"squashing\" function to interval [0,1]\n  File \"/usr/local/Cellar/python3/3.6.4/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/autograd/tracer.py\", line 48, in f_wrapped\n    return f_raw(*args, **kwargs)\nAttributeError: 'ArrayBox' object has no attribute 'exp'\n```\n\nI'm using Python 3.6.4 and and autograd 1.2 which I pulled from pip this morning. \n\nPlease let me know what I'm doing wrong here! :)\n\n\n\n\n\n\n\n\n\n\nAutograd ArrayBox type intermediate output from optimizer PennyLane Help\n\n\n    Thanks @leongfy, I see the issue now  This arises because cost_n is computed via a side effect of your cost function. That is, your cost function is updating a global variable, rather than returning the cost. \nWhen using Autograd with PennyLane, cost functions must be pure \u2014 they cannot perform side effects (such as updating external variables), otherwise: \n\nYou will see ArrayBox objects rather than NumPy arrays, and\nThe values stored via the side-effect will no longer be different\u2026\n  \n\n", "link": "https://discuss.pennylane.ai//t/attributeerror-when-optimizing-purity-of-reduced-density-matrix/3032/2"}, "2": {"author": "sillygoose", "date": "1686488352740", "content": "Sorry, I am not seeing how the linked posts help here. In both the linked cases, the author of the code has explicitly defined a quantity or done something within the definition of their cost function which is not compatible with pennylane such that the ArrayBox error is raised.\nIn my case, I have only used native pennylane functions and have not modified global variables in the qnodes leading up to my cost function. I did try to use qml.math.toarray() on the final output of my cost function. I also made sure to specify requires_grad=False to each input to the cost function.2 Replies", "link": "https://discuss.pennylane.ai//t/attributeerror-when-optimizing-purity-of-reduced-density-matrix/3032/3"}, "3": {"author": "Solomon", "date": "1686490285315", "content": "Your stack trace indicates that the exception is thrown from scipy, which is probably being invoked in the minimisation process.\npython3.8/site-packages/scipy/sparse/linalg/matfuncs.py in _smart_matrix_product(A, B, alpha, structure)\n    164     else:\n    165         if alpha is None:\n--> 166             out = A.dot(B)\n    167         else:\n    168             out = alpha * A.dot(B)\n\nAttributeError: 'ArrayBox' object has no attribute 'dot'\n\nI suggested the first link since they are using autograd which you may wish to explore as an alternative, and the second uses the qml build in optimiser.\nBTW, I am trying to help you as a fellow programmer, I am not from the Xanadu support team.", "link": "https://discuss.pennylane.ai//t/attributeerror-when-optimizing-purity-of-reduced-density-matrix/3032/4"}, "4": {"author": "isaacdevlugt", "date": "1686597200001", "content": "Hey @sillygoose! Welcome to the forum \nI managed to narrow in on what\u2019s going on and it seems like your error stems from something akin to this example:\ndev = qml.device(\"default.qubit\", wires=2)\n\n\n@qml.qnode(dev)\ndef circuit_sun(x):\n    qml.SpecialUnitary(x, wires=dev.wires)\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(0))\n\n\n@qml.qnode(dev)\ndef circuit_rx(x):\n    qml.RX(x[0], wires=0)\n    qml.RX(x[1], wires=1)\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(0))\n\n\ndef cost_sun(x):\n    return np.abs(circuit_sun(x) - 0.5) ** 2\n\ndef cost_rx(x):\n    return np.abs(circuit_rx(x) - 0.5) ** 2\n\nx_sun = np.random.uniform(0, 1, size=(15,), requires_grad=True)\nx_rx = np.random.uniform(0, 1, size=(2,), requires_grad=True)\n\nminimize(cost_rx, x_rx, method=\"BFGS\", jac=qml.grad(cost_rx, argnum=0)) # works\nminimize(cost_sun, x_sun, method=\"BFGS\", jac=qml.grad(cost_sun, argnum=0)) # doesn't work\n\nSeems to be an issue with SpecialUnitary. Curiously, without the jac keyword argument everything works fine. I\u2019m going to check in with someone on the development team and I will get back to you ASAP!1", "link": "https://discuss.pennylane.ai//t/attributeerror-when-optimizing-purity-of-reduced-density-matrix/3032/5"}, "5": {"author": "sillygoose", "date": "1686619811301", "content": "Thank you very much :)!", "link": "https://discuss.pennylane.ai//t/attributeerror-when-optimizing-purity-of-reduced-density-matrix/3032/6"}, "6": {"author": "Wierichs", "date": "1686643000523", "content": "Hi @sillygoose,\nThe problem indeed is with SpecialUnitary. Because it uses the function scipy.linalg.expm, which is not differentiable in Autograd, differentiation of SpecialUnitary with automatic differentiation (as is used here by default in your and @isaacdevlugt\u2019s examples) is not supported. Also see the docs for more information on the operation.\nThe reason for the MWE running if you skip the jac keyword is that - as far as I know - scipy will default to using finite differences to compute the gradient if you don\u2019t pass a method to do so. I\u2019d not recommend this, in particular for larger examples.\nAlternatively, I\u2019d recommend to\n\nMove to one of the other machine learning frameworks: JAX, Tensorflow, Pytorch. They all support differentiation of SpecialUnitary (via support for expm).\nContinue to pass the jac keyword argument explicitly, to avoid finite differences.\n\nThe following should work \nimport pennylane as qml\nimport numpy as np\nfrom jax import numpy as jnp\nimport jax\njax.config.update(\"jax_enable_x64\", True)\nfrom scipy.optimize import minimize\n\nn = 3 # total number of qubits\nd = 2**n # dimension of composite system\n\ncoeffs = [0.5]*3\nops = [qml.PauliZ(0) @ qml.PauliZ(1), qml.PauliZ(1) @ qml.PauliZ(2), qml.PauliZ(0) @ qml.PauliZ(2)]\nisingHam = qml.Hamiltonian(coeffs, ops)\nH = isingHam # native Hamiltonian\ntau = 1 # characteristic time\n\nrho = np.zeros((d, d), dtype=np.complex128)\nval = 0.25\nrho[0, 0] = val\nrho[1, 1] = val\nrho[2, 2] = val\nrho[3, 3] = val\nrho = np.array(rho) # initial density matrix\n\nwireList = list(range(n))\nthetas = jnp.array(np.random.randn((d**2-1)))\n\ndevRho = qml.device(\"default.mixed\", wires=3)\n@qml.qnode(devRho)\ndef processRho(n, H, tau, thetas, rho):\n    '''\n    Time evolves rho using scrambled Hamiltonian by characteristic time, then traces out of environment.\n    Inputs:\n     - n: total number of qubits\n     - H: native Hamiltonian to be scrambled\n     - tau: characteristic time\n     - thetas: parameters to scramble H\n     - rho: initial density matrix\n    \n    Outputs:\n     - rhoTau: time evolved, then traced out density matrix\n    '''\n    qml.QubitDensityMatrix(rho, wires=wireList)\n    qml.adjoint(qml.SpecialUnitary(thetas, wires=wireList))\n    qml.ApproxTimeEvolution(H, tau, 100)\n    qml.SpecialUnitary(thetas, wires=wireList)\n    return qml.density_matrix([0])\n\n@qml.qnode(devRho)\ndef purity(thetas):\n    '''\n    Initializes a density matrix and takes its purity.\n    '''\n    qml.QubitDensityMatrix(processRho(n, H, tau, thetas, rho), wires=0)\n    return qml.purity(0)\n\ndef cost(thetas):\n    '''\n    Computes linear entropy from purity. \n    '''\n    return 1 - purity(thetas)\n\nthetas = jnp.array(thetas)\n\nminimize(purity, thetas, method='BFGS', jac=jax.grad(cost, argnums=0))\n\nHope this helps! Happy coding 2", "link": "https://discuss.pennylane.ai//t/attributeerror-when-optimizing-purity-of-reduced-density-matrix/3032/7"}, "7": {"author": "sillygoose", "date": "1686347903050", "content": "Hello! I am trying to optimize the linear entropy of a time evolved, then traced out density matrix using pennylane. The Hamiltonian used to time evolve my state is what is being parameterized.\nHowever, I receive an error: AttributeError: 'ArrayBox' object has no attribute 'dot'. Any help in solving this error and/or pointing me towards a better way to optimize the linear entropy of a time evolved, then traced out density matrix would be greatly appreciated! What I am doing is precisely the following.\nFirst, I am dealing with qubit systems. Let us fix the system to be a system of three qubits and define an initial density matrix of this three qubit system. I will also define the parameters to be optimized.\nimport pennylane as qml\nfrom pennylane import numpy as np\nimport jax\nimport qutip as qtp\nfrom scipy.optimize import minimize\n\nn = 3 # total number of qubits\nd = 2**n # dimension of composite system\nH = isingHam # native Hamiltonian\ntau = 1 # characteristic time\n\nrho = np.zeros((d, d), dtype=np.complex128)\nval = 0.25\nrho[0, 0] = val\nrho[1, 1] = val\nrho[2, 2] = val\nrho[3, 3] = val\nrho = np.array(rho) # initial density matrix\n\nwireList = list(range(n))\nthetas = np.array(np.random.randn((d**2-1), requires_grad = True)) # random initial parameters for optimization\n\nI also start with a fixed Hamiltonian, say the 1D Ising model Hamiltonian with boundary conditions:\ncoeffs = [0.5]*3\nops = [qml.PauliZ(0) @ qml.PauliZ(1), qml.PauliZ(1) @ qml.PauliZ(2), qml.PauliZ(0) @ qml.PauliZ(2)]\nisingHam = qml.Hamiltonian(coeffs, ops) # native Hamiltonian\n\nNext, I time evolve the initial density matrix by a \u201cscrambled Hamiltonian\u201d and then trace out of the environment of the initial density matrix. By \u201cscrambled Hamiltonian\u201d, I mean the fixed Hamiltonian defined earlier conjugated by a special unitary operator, parameterized by the thetas.\ndevRho = qml.device(\"default.mixed\", wires=3)\n@qml.qnode(devRho)\ndef processRho(n, H, tau, thetas, rho):\n    '''\n    Time evolves rho using scrambled Hamiltonian by characteristic time, then traces out of environment.\n    Inputs:\n     - n: total number of qubits\n     - H: native Hamiltonian to be scrambled\n     - tau: characteristic time\n     - thetas: parameters to scramble H\n     - rho: initial density matrix\n    \n    Outputs:\n     - rhoTau: time evolved, then traced out density matrix\n    '''\n    qml.QubitDensityMatrix(rho, wires=wireList)\n    qml.adjoint(qml.SpecialUnitary(thetas, wires=wireList))\n    qml.ApproxTimeEvolution(H, tau, 100)\n    qml.SpecialUnitary(thetas, wires=wireList)\n    return qml.density_matrix([0])\n\n#print(qml.draw(circuit)(n, isingHam, tau, thetas, rho))\n\nI initialize the reduced density matrix returned from processRho() and take its purity. Finally, I define my cost function, i.e. the linear entropy:\n@qml.qnode(devRho)\ndef purity(thetas):\n    '''\n    Initializes a density matrix and takes its purity.\n    '''\n    qml.QubitDensityMatrix(processRho(n, H, tau, thetas, rho), wires=0)\n    return qml.purity(0)\n\ndef cost(thetas):\n    '''\n    Computes linear entropy from purity. \n    '''\n    return 1 - purity(thetas)\n\nJust as a simple test, I thought to test optimization using:\nminimize(purity, thetas, method='BFGS', jac=qml.grad(cost, argnum=0))\n\nHowever, running all of the code (in particular, running the optimization) gives me the error message:\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n<ipython-input-69-1d027bdc7de1> in <module>\n----> 1 minimize(purity, thetas, method='BFGS', jac=qml.grad(cost, argnum=0))\n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/optimize/_minimize.py in minimize(fun, x0, args, method, jac, hess, hessp, bounds, constraints, tol, callback, options)\n    612         return _minimize_cg(fun, x0, args, jac, callback, **options)\n    613     elif meth == 'bfgs':\n--> 614         return _minimize_bfgs(fun, x0, args, jac, callback, **options)\n    615     elif meth == 'newton-cg':\n    616         return _minimize_newtoncg(fun, x0, args, jac, hess, hessp, callback,\n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/optimize/optimize.py in _minimize_bfgs(fun, x0, args, jac, callback, gtol, norm, eps, maxiter, disp, return_all, finite_diff_rel_step, **unknown_options)\n   1133         maxiter = len(x0) * 200\n   1134 \n-> 1135     sf = _prepare_scalar_function(fun, x0, jac, args=args, epsilon=eps,\n   1136                                   finite_diff_rel_step=finite_diff_rel_step)\n   1137 \n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/optimize/optimize.py in _prepare_scalar_function(fun, x0, jac, args, bounds, epsilon, finite_diff_rel_step, hess)\n    259     # ScalarFunction caches. Reuse of fun(x) during grad\n    260     # calculation reduces overall function evaluations.\n--> 261     sf = ScalarFunction(fun, x0, args, grad, hess,\n    262                         finite_diff_rel_step, bounds, epsilon=epsilon)\n    263 \n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/optimize/_differentiable_functions.py in __init__(self, fun, x0, args, grad, hess, finite_diff_rel_step, finite_diff_bounds, epsilon)\n    153 \n    154         self._update_grad_impl = update_grad\n--> 155         self._update_grad()\n    156 \n    157         # Hessian Evaluation\n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/optimize/_differentiable_functions.py in _update_grad(self)\n    229     def _update_grad(self):\n    230         if not self.g_updated:\n--> 231             self._update_grad_impl()\n    232             self.g_updated = True\n    233 \n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/optimize/_differentiable_functions.py in update_grad()\n    143 \n    144             def update_grad():\n--> 145                 self.g = grad_wrapped(self.x)\n    146 \n    147         elif grad in FD_METHODS:\n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/optimize/_differentiable_functions.py in grad_wrapped(x)\n    140             def grad_wrapped(x):\n    141                 self.ngev += 1\n--> 142                 return np.atleast_1d(grad(x, *args))\n    143 \n    144             def update_grad():\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/_grad.py in __call__(self, *args, **kwargs)\n    115             return ()\n    116 \n--> 117         grad_value, ans = grad_fn(*args, **kwargs)  # pylint: disable=not-callable\n    118         self._forward = ans\n    119 \n\n~/opt/anaconda3/lib/python3.8/site-packages/autograd/wrap_util.py in nary_f(*args, **kwargs)\n     18             else:\n     19                 x = tuple(args[i] for i in argnum)\n---> 20             return unary_operator(unary_f, x, *nary_op_args, **nary_op_kwargs)\n     21         return nary_f\n     22     return nary_operator\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/_grad.py in _grad_with_forward(fun, x)\n    133         difference being that it returns both the gradient *and* the forward pass\n    134         value.\"\"\"\n--> 135         vjp, ans = _make_vjp(fun, x)\n    136 \n    137         if not vspace(ans).size == 1:\n\n~/opt/anaconda3/lib/python3.8/site-packages/autograd/core.py in make_vjp(fun, x)\n      8 def make_vjp(fun, x):\n      9     start_node = VJPNode.new_root()\n---> 10     end_value, end_node =  trace(start_node, fun, x)\n     11     if end_node is None:\n     12         def vjp(g): return vspace(x).zeros()\n\n~/opt/anaconda3/lib/python3.8/site-packages/autograd/tracer.py in trace(start_node, fun, x)\n      8     with trace_stack.new_trace() as t:\n      9         start_box = new_box(x, t, start_node)\n---> 10         end_box = fun(start_box)\n     11         if isbox(end_box) and end_box._trace == start_box._trace:\n     12             return end_box._value, end_box._node\n\n~/opt/anaconda3/lib/python3.8/site-packages/autograd/wrap_util.py in unary_f(x)\n     13                 else:\n     14                     subargs = subvals(args, zip(argnum, x))\n---> 15                 return fun(*subargs, **kwargs)\n     16             if isinstance(argnum, int):\n     17                 x = args[argnum]\n\n<ipython-input-68-d9c8029c0ea7> in cost(thetas)\n     11     Computes linear entropy from purity.\n     12     '''\n---> 13     return 1 - purity(thetas)\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/qnode.py in __call__(self, *args, **kwargs)\n    851 \n    852         # construct the tape\n--> 853         self.construct(args, kwargs)\n    854 \n    855         cache = self.execute_kwargs.get(\"cache\", False)\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/qnode.py in construct(self, args, kwargs)\n    755             self.interface = qml.math.get_interface(*args, *list(kwargs.values()))\n    756 \n--> 757         self._tape = make_qscript(self.func)(*args, **kwargs)\n    758         self._qfunc_output = self.tape._qfunc_output\n    759 \n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/tape/qscript.py in wrapper(*args, **kwargs)\n   1376     def wrapper(*args, **kwargs):\n   1377         with AnnotatedQueue() as q:\n-> 1378             result = fn(*args, **kwargs)\n   1379 \n   1380         qscript = QuantumScript.from_queue(q)\n\n<ipython-input-68-d9c8029c0ea7> in purity(thetas)\n      4     Initializes a density matrix and takes its purity.\n      5     '''\n----> 6     qml.QubitDensityMatrix(processRho(n, H, tau, thetas, rho), wires=0)\n      7     return qml.purity(0)\n      8 \n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/qnode.py in __call__(self, *args, **kwargs)\n    865                 self.execute_kwargs.pop(\"mode\")\n    866             # pylint: disable=unexpected-keyword-arg\n--> 867             res = qml.execute(\n    868                 [self.tape],\n    869                 device=self.device,\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/interfaces/execution.py in execute(tapes, device, gradient_fn, interface, grad_on_execution, gradient_kwargs, cache, cachesize, max_diff, override_shots, expand_fn, max_expansion, device_batch_transform)\n    405     if gradient_fn == \"backprop\" or interface is None:\n    406         return batch_fn(\n--> 407             qml.interfaces.cache_execute(\n    408                 batch_execute, cache, return_tuple=False, expand_fn=expand_fn\n    409             )(tapes)\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/interfaces/execution.py in wrapper(tapes, **kwargs)\n    202         else:\n    203             # execute all unique tapes that do not exist in the cache\n--> 204             res = fn(execution_tapes.values(), **kwargs)\n    205 \n    206         final_res = []\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/interfaces/execution.py in fn(tapes, **kwargs)\n    128         def fn(tapes: Sequence[QuantumTape], **kwargs):  # pylint: disable=function-redefined\n    129             tapes = [expand_fn(tape) for tape in tapes]\n--> 130             return original_fn(tapes, **kwargs)\n    131 \n    132     @wraps(fn)\n\n~/opt/anaconda3/lib/python3.8/contextlib.py in inner(*args, **kwds)\n     73         def inner(*args, **kwds):\n     74             with self._recreate_cm():\n---> 75                 return func(*args, **kwds)\n     76         return inner\n     77 \n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/_qubit_device.py in batch_execute(self, circuits)\n    586             self.reset()\n    587 \n--> 588             res = self.execute(circuit)\n    589             results.append(res)\n    590 \n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/devices/default_mixed.py in execute(self, circuit, **kwargs)\n    657                 wires_list.append(m.wires)\n    658             self.measured_wires = qml.wires.Wires.all_wires(wires_list)\n--> 659         return super().execute(circuit, **kwargs)\n    660 \n    661     def _execute_legacy(self, circuit, **kwargs):\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/_qubit_device.py in execute(self, circuit, **kwargs)\n    316 \n    317         # apply all circuit operations\n--> 318         self.apply(circuit.operations, rotations=self._get_diagonalizing_gates(circuit), **kwargs)\n    319 \n    320         # generate computational basis samples\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/devices/default_mixed.py in apply(self, operations, rotations, **kwargs)\n    725 \n    726         for operation in operations:\n--> 727             self._apply_operation(operation)\n    728 \n    729         # store the pre-rotated state\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/devices/default_mixed.py in _apply_operation(self, operation)\n    589             return\n    590 \n--> 591         matrices = self._get_kraus(operation)\n    592 \n    593         if operation in diagonal_in_z_basis:\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/devices/default_mixed.py in _get_kraus(self, operation)\n    280             return operation.kraus_matrices()\n    281 \n--> 282         return [operation.matrix()]\n    283 \n    284     def _apply_channel(self, kraus, wires):\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/operation.py in matrix(self, wire_order)\n    743             tensor_like: matrix representation\n    744         \"\"\"\n--> 745         canonical_matrix = self.compute_matrix(*self.parameters, **self.hyperparameters)\n    746 \n    747         if wire_order is None or self.wires == Wires(wire_order):\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/ops/qubit/special_unitary.py in compute_matrix(theta, num_wires)\n    447             # jax.numpy.expm does not support broadcasting\n    448             return qml.math.stack([qml.math.expm(1j * _A) for _A in A])\n--> 449         return qml.math.expm(1j * A)\n    450 \n    451     def get_one_parameter_generators(self, interface=None):\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/math/multi_dispatch.py in wrapper(*args, **kwargs)\n    149             kwargs[\"like\"] = interface\n    150 \n--> 151             return fn(*args, **kwargs)\n    152 \n    153         return wrapper\n\n~/opt/anaconda3/lib/python3.8/site-packages/pennylane/math/multi_dispatch.py in expm(tensor, like)\n    815     from scipy.linalg import expm as scipy_expm\n    816 \n--> 817     return scipy_expm(tensor)\n    818 \n    819 \n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/linalg/matfuncs.py in expm(A)\n    253     # Input checking and conversion is provided by sparse.linalg.expm().\n    254     import scipy.sparse.linalg\n--> 255     return scipy.sparse.linalg.expm(A)\n    256 \n    257 \n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/sparse/linalg/matfuncs.py in expm(A)\n    589             [  0.        ,   0.        ,  20.08553692]])\n    590     \"\"\"\n--> 591     return _expm(A, use_exact_onenorm='auto')\n    592 \n    593 \n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/sparse/linalg/matfuncs.py in _expm(A, use_exact_onenorm)\n    638 \n    639     # Try Pade order 3.\n--> 640     eta_1 = max(h.d4_loose, h.d6_loose)\n    641     if eta_1 < 1.495585217958292e-002 and _ell(h.A, 3) == 0:\n    642         U, V = h.pade3()\n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/sparse/linalg/matfuncs.py in d4_loose(self)\n    441     def d4_loose(self):\n    442         if self.use_exact_onenorm:\n--> 443             return self.d4_tight\n    444         if self._d4_exact is not None:\n    445             return self._d4_exact\n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/sparse/linalg/matfuncs.py in d4_tight(self)\n    417     def d4_tight(self):\n    418         if self._d4_exact is None:\n--> 419             self._d4_exact = _onenorm(self.A4)**(1/4.)\n    420         return self._d4_exact\n    421 \n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/sparse/linalg/matfuncs.py in A4(self)\n    390         if self._A4 is None:\n    391             self._A4 = _smart_matrix_product(\n--> 392                     self.A2, self.A2, structure=self.structure)\n    393         return self._A4\n    394 \n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/sparse/linalg/matfuncs.py in A2(self)\n    382     def A2(self):\n    383         if self._A2 is None:\n--> 384             self._A2 = _smart_matrix_product(\n    385                     self.A, self.A, structure=self.structure)\n    386         return self._A2\n\n~/opt/anaconda3/lib/python3.8/site-packages/scipy/sparse/linalg/matfuncs.py in _smart_matrix_product(A, B, alpha, structure)\n    164     else:\n    165         if alpha is None:\n--> 166             out = A.dot(B)\n    167         else:\n    168             out = alpha * A.dot(B)\n\nAttributeError: 'ArrayBox' object has no attribute 'dot'\n\nHere is my output from qml.about():\nName: PennyLane\nVersion: 0.30.0\nSummary: PennyLane is a Python quantum machine learning library by Xanadu Inc.\nHome-page: https://github.com/XanaduAI/pennylane\nAuthor: \nAuthor-email: \nLicense: Apache License 2.0\nLocation: /Users/carl/opt/anaconda3/lib/python3.8/site-packages\nRequires: appdirs, autograd, autoray, cachetools, networkx, numpy, pennylane-lightning, requests, rustworkx, scipy, semantic-version, toml\nRequired-by: PennyLane-Lightning\n\nPlatform info:           macOS-10.16-x86_64-i386-64bit\nPython version:          3.8.8\nNumpy version:           1.22.0\nScipy version:           1.6.2\nInstalled devices:\n- default.gaussian (PennyLane-0.30.0)\n- default.mixed (PennyLane-0.30.0)\n- default.qubit (PennyLane-0.30.0)\n- default.qubit.autograd (PennyLane-0.30.0)\n- default.qubit.jax (PennyLane-0.30.0)\n- default.qubit.tf (PennyLane-0.30.0)\n- default.qubit.torch (PennyLane-0.30.0)\n- default.qutrit (PennyLane-0.30.0)\n- null.qubit (PennyLane-0.30.0)\n- lightning.qubit (PennyLane-Lightning-0.30.0)\n", "link": "https://discuss.pennylane.ai//t/attributeerror-when-optimizing-purity-of-reduced-density-matrix/3032/8"}}