{"0": {"author": "Nikhil_Narayanan", "date": "1683730969115", "content": "I am trying to train a parametrized quantum circuit with gradients calculated using parameter shift. I am trying to use the following class  in my run_circuit() function (which has the qnode decorator) but it doesn\u2019t work.\nclass Loader(Operation):\n    num_params = 1\n    num_wires = 2\n    par_domain = \"R\"\n\n    grad_method = \"A\"  # Analytic differentiation with Parameter shift\n    grad_recipe = None\n\n    @staticmethod\n    def compute_decomposition(theta: float, wires: int | list):\n      qml.RY(theta, wires=0)\n      qml.RY(theta, wires=1)\n      qml.IsingXX(theta, wires=[0, 1])\n      qml.RY(theta, wires=0)\n      qml.RY(theta, wires=1)\n\nMoreover, here is the run circuit function:\n@qml.qnode(dev, diff_method = \"parameter-shift\")\ndef run_circuit(phi, weight0, weight1, weight2, weight3, weight4, weight5):\n    \"\"\"\n    Input a numpy array feature (which encodes a single normalized angle encoded spot price)\n    \"\"\"\n    loader.Loader(phi, wires=[0,1])\n    qml.StronglyEntanglingLayers(np.tensor([[[weight0, weight1, weight2] , [weight3, weight4, weight5]]]), wires=[0,1])\n    return qml.expval(qml.PauliZ(0))\n\nIt works as expected when I modify as such:\n@qml.qnode(dev, diff_method = \"parameter-shift\")\ndef run_circuit(phi, weight0, weight1, weight2, weight3, weight4, weight5):\n    \"\"\"\n    Input a numpy array feature (which encodes a single normalized angle encoded spot price)\n    \"\"\"\n    qml.RY(theta, wires=0)\n    qml.RY(theta, wires=1)\n    qml.IsingXX(theta, wires=[0, 1])\n    qml.RY(theta, wires=0)\n    qml.RY(theta, wires=1)\n    qml.StronglyEntanglingLayers(np.tensor([[[weight0, weight1, weight2] , [weight3, weight4, weight5]]]), wires=[0,1])\n    return qml.expval(qml.PauliZ(0))\n", "link": "https://discuss.pennylane.ai//t/how-to-extend-cvoperation-to-support-parameter-shift-for-given-circuit/2929/1"}, "1": {"author": "isaacdevlugt", "date": "1683746384411", "content": "Hey @Nikhil_Narayanan! Welcome to the forum \nIn v0.22 of PennyLane, there were some changes to how one can make custom operations:\n\n\nNo two-term parameter-shift rule is assumed anymore by default. (#2227). Previously, operations marked for analytic differentiation that did not provide a generator, parameter_frequencies or a custom grad_recipe were assumed to satisfy the two-term shift rule. This now has to be made explicit for custom operations by adding any of the above attributes.\n\n\nHere\u2019s a simpler and complete example using your operator.\nimport pennylane as qml\nfrom pennylane import numpy as np\n\nclass Loader(qml.operation.Operation):\n    num_params = 1\n    num_wires = 2\n    par_domain = \"R\"\n\n    grad_method = \"A\"  # Analytic differentiation with Parameter shift\n    grad_recipe = None\n\n    @staticmethod\n    def compute_decomposition(theta, wires):\n      qml.RY(theta, wires=wires[0])\n      qml.RY(theta, wires=wires[1])\n      qml.IsingXX(theta, wires=wires)\n      qml.RY(theta, wires=wires[0])\n      qml.RY(theta, wires=wires[1])\n\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.qnode(dev, diff_method = \"parameter-shift\")\ndef run_circuit(phi):\n    Loader(phi, wires=[0, 1])\n    return qml.expval(qml.PauliX(0))\n\ntheta = np.array(0.1, requires_grad=True)\nprint(qml.grad(run_circuit)(theta))\n\n'''\nOperatorPropertyUndefined: The operation Loader does not have a grad_recipe, parameter_frequencies or a generator defined. No parameter shift rule can be applied.\n'''\n\nWhen I try to use your operator with v0.30 (the latest version), I get the error above . So, you need to define one of:\n\ngrad_recipe(see here 1 for an example) ,\nparameter_frequencies (see here for an example), or\ngenerator (see here for an example),\n\nin order for it to work. Hope this helps!", "link": "https://discuss.pennylane.ai//t/how-to-extend-cvoperation-to-support-parameter-shift-for-given-circuit/2929/2"}, "2": {"author": "Nikhil_Narayanan", "date": "1683814422574", "content": "Hi Isaac, thank you very much for your reply! I tried adding the following line to my class:\ngrad_recipe = ([[0.5, 1, pi / 2], [-0.5, 1, -pi / 2]],)\n\nWhile the code does run fine, when computing the gradient, it seems that all the values are 0 (this is not the case when I try using the prebuilt templates from pennylane. Could you help me find where I can understand what exactly the grad_recipe/generator/parameter_frequencies are? I don\u2019t think I understand what they wrote in the documentation (as to why the gradients are becoming 0 for me).", "link": "https://discuss.pennylane.ai//t/how-to-extend-cvoperation-to-support-parameter-shift-for-given-circuit/2929/3"}, "3": {"author": "isaacdevlugt", "date": "1683818399151", "content": "Glad this helped a bit! I tried running this and the gradients aren\u2019t zero for me \nimport pennylane as qml\nfrom pennylane import numpy as np\n\nclass Loader(qml.operation.Operation):\n    num_params = 1\n    num_wires = 2\n    par_domain = \"R\"\n\n    grad_method = \"A\"  # Analytic differentiation with Parameter shift\n    grad_recipe = ([[0.5, 1, np.pi / 2], [-0.5, 1, -np.pi / 2]],)\n\n    @staticmethod\n    def compute_decomposition(theta, wires):\n      qml.RY(theta, wires=wires[0])\n      qml.RY(theta, wires=wires[1])\n      qml.IsingXX(theta, wires=wires)\n      qml.RY(theta, wires=wires[0])\n      qml.RY(theta, wires=wires[1])\n\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.qnode(dev, diff_method = \"parameter-shift\")\ndef run_circuit(phi):\n    \"\"\"\n    Input a numpy array feature (which encodes a single normalized angle encoded spot price)\n    \"\"\"\n    Loader(phi, wires=[0, 1])\n    return qml.expval(qml.PauliX(0))\n\ntheta = np.array(0.1, requires_grad=True)\n\nopt = qml.GradientDescentOptimizer(0.1)\n\nfor _ in range(10):\n    theta = opt.step(run_circuit, theta)\n    print(qml.grad(run_circuit)(theta), theta)\n\n'''\n0.009722806259971711 0.09900830809618949\n0.009534309646146294 0.09803602747019231\n0.009351215857823753 0.09708259650557768\n0.00917332152676964 0.0961474749197953\n0.009000432705141143 0.09523014276711834\n0.008832364350146032 0.09433009949660423\n0.008668939841056184 0.09344686306158963\n0.008509990526297917 0.092579969077484\n0.00835535529850992 0.09172897002485421\n0.008204880195630204 0.09089343449500321\n'''\n\n\nCould you help me find where I can understand what exactly the grad_recipe/generator/parameter_frequencies are?\n\nGreat question! I recommend going through some of our content to get a better understanding of how the parameter-shift rule works:\n\nhttps://youtu.be/CRafKy6wsbY 1\nThe stochastic parameter-shift rule | PennyLane Demos\nParameter-shift rules \u2014 PennyLane 1\nhttps://arxiv.org/pdf/1811.11184.pdf\n\nLet me know if these help!", "link": "https://discuss.pennylane.ai//t/how-to-extend-cvoperation-to-support-parameter-shift-for-given-circuit/2929/4"}, "4": {"author": "Nikhil_Narayanan", "date": "1684153651751", "content": "I got the following code to work; but have a style question, what is the recommended way to deal with multiple parameters when using Loader classes - it is quite clunky to use arrays of pennylane.numpy tensors for example\nimport pennylane as qml\nfrom pennylane import numpy as np\n\nclass Loader(qml.operation.Operation):\n    num_params = 2\n    num_wires = 2\n    par_domain = \"R\"\n\n    grad_method = \"A\"  # Analytic differentiation with Parameter shift\n    grad_recipe = ([[0.5, 1, np.pi / 2], [-0.5, 1, -np.pi / 2]],[[0.5, 1, np.pi / 2], [-0.5, 1, -np.pi / 2]],)\n\n    @staticmethod\n    def compute_decomposition(theta1,theta2, wires):\n      qml.RY(theta1, wires=wires[0])\n      qml.RY(theta1, wires=wires[1])\n      qml.IsingXX(theta2, wires=wires)\n      qml.RY(theta1, wires=wires[0])\n      qml.RY(theta1, wires=wires[1])\n\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.qnode(dev, diff_method = \"parameter-shift\")\ndef run_circuit(theta1, theta2):\n    \"\"\"\n    Input a numpy array feature (which encodes a single normalized angle encoded spot price)\n    \"\"\"\n    Loader(theta1, theta2, wires=[0, 1])\n    return qml.expval(qml.PauliX(0))\n\ndef cost_func(x, theta1, theta2):\n    output = run_circuit(theta1, theta2)\n    return output + x\n\ntheta1 = np.array(0.1, requires_grad=True)\ntheta2 = np.array(0.2, requires_grad=True)\nx = np.array(0.1, requires_grad = False)\n\nopt = qml.AdamOptimizer(0.1)\n\nfor _ in range(10):\n    grad, _ = opt.compute_grad(cost_func, (x,theta1, theta2), {})\n    updates = opt.apply_grad(grad, (x,theta1, theta2)) \n    theta = updates[0]\n    theta2 = updates[1]\n    print(grad)\n", "link": "https://discuss.pennylane.ai//t/how-to-extend-cvoperation-to-support-parameter-shift-for-given-circuit/2929/5"}, "5": {"author": "isaacdevlugt", "date": "1684245151915", "content": "Nice! There are examples of using one argument for each variable or one argument for multiple variables (an array). For instance,\n\nqml.Rot(phi, theta, omega, wires=0)\n\nqml.AngleEmbedding(features, wires=wires), where features is an array\n\nThere are other examples, but I think for your case, making it so that Loader takes two single arguments, theta1 and theta2, makes sense to me!1", "link": "https://discuss.pennylane.ai//t/how-to-extend-cvoperation-to-support-parameter-shift-for-given-circuit/2929/6"}, "6": {"author": "Nikhil_Narayanan", "date": "1684503247123", "content": "Hi Isaac,\nThank you for the help!\nBest,\nNikhil1", "link": "https://discuss.pennylane.ai//t/how-to-extend-cvoperation-to-support-parameter-shift-for-given-circuit/2929/7"}, "7": {"author": "isaacdevlugt", "date": "1684503365035", "content": "Awesome! Glad I could help!", "link": "https://discuss.pennylane.ai//t/how-to-extend-cvoperation-to-support-parameter-shift-for-given-circuit/2929/8"}, "8": {"author": "Nikhil_Narayanan", "date": "1683730969115", "content": "I am trying to train a parametrized quantum circuit with gradients calculated using parameter shift. I am trying to use the following class  in my run_circuit() function (which has the qnode decorator) but it doesn\u2019t work.\nclass Loader(Operation):\n    num_params = 1\n    num_wires = 2\n    par_domain = \"R\"\n\n    grad_method = \"A\"  # Analytic differentiation with Parameter shift\n    grad_recipe = None\n\n    @staticmethod\n    def compute_decomposition(theta: float, wires: int | list):\n      qml.RY(theta, wires=0)\n      qml.RY(theta, wires=1)\n      qml.IsingXX(theta, wires=[0, 1])\n      qml.RY(theta, wires=0)\n      qml.RY(theta, wires=1)\n\nMoreover, here is the run circuit function:\n@qml.qnode(dev, diff_method = \"parameter-shift\")\ndef run_circuit(phi, weight0, weight1, weight2, weight3, weight4, weight5):\n    \"\"\"\n    Input a numpy array feature (which encodes a single normalized angle encoded spot price)\n    \"\"\"\n    loader.Loader(phi, wires=[0,1])\n    qml.StronglyEntanglingLayers(np.tensor([[[weight0, weight1, weight2] , [weight3, weight4, weight5]]]), wires=[0,1])\n    return qml.expval(qml.PauliZ(0))\n\nIt works as expected when I modify as such:\n@qml.qnode(dev, diff_method = \"parameter-shift\")\ndef run_circuit(phi, weight0, weight1, weight2, weight3, weight4, weight5):\n    \"\"\"\n    Input a numpy array feature (which encodes a single normalized angle encoded spot price)\n    \"\"\"\n    qml.RY(theta, wires=0)\n    qml.RY(theta, wires=1)\n    qml.IsingXX(theta, wires=[0, 1])\n    qml.RY(theta, wires=0)\n    qml.RY(theta, wires=1)\n    qml.StronglyEntanglingLayers(np.tensor([[[weight0, weight1, weight2] , [weight3, weight4, weight5]]]), wires=[0,1])\n    return qml.expval(qml.PauliZ(0))\n", "link": "https://discuss.pennylane.ai//t/how-to-extend-cvoperation-to-support-parameter-shift-for-given-circuit/2929/9"}}