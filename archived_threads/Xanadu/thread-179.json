{"0": {"author": "sassan_moradi", "date": "1649834037865", "content": "i have a quantum circuit and i want to find the parameters (angles) of this quantum circuit in a way that the output of the quantum circuit (which is a quantum state) be as close as possible to a desired vector. What method do you propose? i also tried with classical Netwon-Raphson optimization method but the final result was sufficiently good.\nimport numpy as np\nimport pennylane as qml\nnum_qubits = 3\ndev = qml.device(\u201cdefault.qubit\u201d, wires=num_qubits)\na = np.array([np.sqrt(0.1), np.sqrt(0.2), np.sqrt(0.1), np.sqrt(0.3), 0, 0, np.sqrt(0.2), np.sqrt(0.1)])\n@qml.qnode(dev)\ndef circuit(X0, X1, X2, X3, X4, X5, X6):\nqml.RY(X0, wires=[0])\n\nqml.RY(X1, wires=[1])\n\nqml.RY(X2, wires=[2])\n\nqml.CNOT(wires=[0, 1])\n\nqml.RY(-X1, wires=[1])\n\nqml.CNOT(wires=[0, 2])\n\nqml.RY(X3, wires=[2])\n\nqml.CNOT(wires=[1, 2])\n\nqml.RY(X4, wires=[0])\n\nqml.RY(X5, wires=[1])\n\nqml.RY(X6, wires=[2])\n\n\nreturn qml.state()\n\ndef func(X0, X1, X2, X3, X4, X5, X6):\nreturn np.real(circuit(X0, X1, X2, X3, X4, X5, X6)-a)\nthe output of func must be close to zero.", "link": "https://discuss.pennylane.ai//t/optimization-of-function/1829/1"}, "1": {"author": "CatalinaAlbornoz", "date": "1649885557430", "content": "Hi @sassan_moradi, here\u2019s an example of how you can achieve your goal with the proposed circuit. Notice that I\u2019ve changed the way to access your parameters for simplicity. I would also recommend that you try with other rotations in addition to RY in order to add complexity and maybe get closer to your target state. Generalized rotations Rot 2 are a good option.\nI also recommend that you read this blog post, which may clarify some concepts.\n# Step 0 - Import the necessary libraries\nimport pennylane as qml\nfrom pennylane import numpy as np\n\n# Step 1 - Get your data ready\na = np.array([np.sqrt(0.1), np.sqrt(0.2), np.sqrt(0.1), np.sqrt(0.3), 0, 0, np.sqrt(0.2), np.sqrt(0.1)])\n\n# Tell the optimizer that this is an input datapoint and not a parameter to optimize over.\na.requires_grad = False\n\n# Step 2 - Create the device\nnum_qubits = 3\ndev = qml.device('default.qubit', wires=num_qubits)\n\n# Step 3 - Create the quantum circuit\n@qml.qnode(dev)\ndef circuit(params):\n    qml.RY(params[0], wires=[0])\n    qml.RY(params[1], wires=[1])\n    qml.RY(params[2], wires=[2])\n    qml.CNOT(wires=[0, 1])\n    qml.RY(-params[1], wires=[1])\n    qml.CNOT(wires=[0, 2])\n    qml.RY(params[3], wires=[2])\n    qml.CNOT(wires=[1, 2])\n    qml.RY(params[4], wires=[0])\n    qml.RY(params[5], wires=[1])\n    qml.RY(params[6], wires=[2])\n    return qml.state()\n\n# Step 4 - Classical Pre/Postprocessing\ndef loss(a,prediction):\n    total_loss = np.real(np.sum(np.array((a-prediction)**2)))\n    return total_loss\n\n# Step 5 - Define your cost function, including any classical pre/postprocessing\ndef cost(a,params):\n    prediction = circuit(params)\n    cost = loss(a,prediction)\n    return cost\n\n# Step 6 - Train your circuit\n\n# Steps 6.1 - Choose an optimizer and a step size\nopt = qml.GradientDescentOptimizer(stepsize=0.1)\n\n# Step 6.2 Make an initial guess for the parameters and set them as trainable\nparams = np.array([0.1,0.1,0.1,0.1,0.1,0.1,0.1],requires_grad=True)\n\n# Step 6.2 - Iterate over a number of defined steps\nfor i in range(100):\n    params_and_a,prev_cost = opt.step_and_cost(cost,a,params)\n    params = params_and_a[1]\n    if i%10==0:\n        print(f'Step: {i},Cost: {cost(a,params)}') \n\nPlease let me know if you have trouble running this code or if you have questions about anything that was done here.\nI hope this helps you!", "link": "https://discuss.pennylane.ai//t/optimization-of-function/1829/2"}, "2": {"author": "sassan_moradi", "date": "1649920200739", "content": "Many many thanks. your code is very instructive. It solved my problem.", "link": "https://discuss.pennylane.ai//t/optimization-of-function/1829/3"}, "3": {"author": "CatalinaAlbornoz", "date": "1649942776052", "content": "I\u2019m glad to hear @sassan_moradi!", "link": "https://discuss.pennylane.ai//t/optimization-of-function/1829/4"}, "4": {"author": "sassan_moradi", "date": "1649834037865", "content": "i have a quantum circuit and i want to find the parameters (angles) of this quantum circuit in a way that the output of the quantum circuit (which is a quantum state) be as close as possible to a desired vector. What method do you propose? i also tried with classical Netwon-Raphson optimization method but the final result was sufficiently good.\nimport numpy as np\nimport pennylane as qml\nnum_qubits = 3\ndev = qml.device(\u201cdefault.qubit\u201d, wires=num_qubits)\na = np.array([np.sqrt(0.1), np.sqrt(0.2), np.sqrt(0.1), np.sqrt(0.3), 0, 0, np.sqrt(0.2), np.sqrt(0.1)])\n@qml.qnode(dev)\ndef circuit(X0, X1, X2, X3, X4, X5, X6):\nqml.RY(X0, wires=[0])\n\nqml.RY(X1, wires=[1])\n\nqml.RY(X2, wires=[2])\n\nqml.CNOT(wires=[0, 1])\n\nqml.RY(-X1, wires=[1])\n\nqml.CNOT(wires=[0, 2])\n\nqml.RY(X3, wires=[2])\n\nqml.CNOT(wires=[1, 2])\n\nqml.RY(X4, wires=[0])\n\nqml.RY(X5, wires=[1])\n\nqml.RY(X6, wires=[2])\n\n\nreturn qml.state()\n\ndef func(X0, X1, X2, X3, X4, X5, X6):\nreturn np.real(circuit(X0, X1, X2, X3, X4, X5, X6)-a)\nthe output of func must be close to zero.", "link": "https://discuss.pennylane.ai//t/optimization-of-function/1829/5"}}