{"0": {"author": "nisq", "date": "1614847228646", "content": "Hello!\nI am trying to design the following circuits:\n\nIn this circuit: first two modes corresponds to first qubit 0_a and 1_a and the other 2 modes corresponds to 0_b and 1_b. Blue boxes are my phase shofters. orange boxes are 50:50 beam siplitter\nI started to code but I am stuck:\n    import strawberryfields as sf\nfrom strawberryfields.ops import Ket, BSgate, Interferometer\nimport numpy as np\n\ncutoff_dim = 5  # (1+ total number of photons)\npaths = 2\nmodes = 2 * paths #I created my modes and totally I have 4 modes\n\ninitial_state = np.zeros([cutoff_dim] * modes, dtype=np.complex)\n# The ket below corresponds to a single horizontal photon in each of the modes\ninitial_state[0, 1, 0, 1] = 1\n# Permutation matrix\nX = np.array([[0, 1], [1, 0]])\nprog = sf.Program(modes)\nwith prog.context as q:\n    Ket(initial_state) | q  # Initial state preparation\n    for i in range(paths):\n        BSgate() | (q[2 * i], q[2 * i + 1])  # First layer of beamsplitters\n        \neng = sf.Engine(\"fock\", backend_options={\"cutoff_dim\": cutoff_dim})\nresult = eng.run(prog)\nstate = result.state\n\nHowever after that I stuck: I should produce the state (|0_a 1b>+|1_a 0_b>)/sqrt(2) in correspondence of the green line, upon post-selection of one photon per qubit modesfor given an input state |0_a 0_b>\nThis is the first code with StrawberryField so I will be glas if someone can explain me briefly \nI took cutoff like 5 but I am not so sure that it is ok?\nAnd I also do not know how to write code for after first beam splitters there is a place which s coming cross and there is no beamsplitter there and after that I need to do a produce the state (|0_a 1b>+|1_a 0_b>)/sqrt(2) in correspondence of the green line, upon post-selection of one photon per qubit modesfor given an input state |0_a 0_b>\u2026\n\n\n Solved by Tom_Bromley in post #15 \n\n\n                Hey @nisq, \n\nNow we do not have 50:50 beam splitters right? we filled our parameters randomly. ? And for the phase shifters, angles were choosen randomly right \n\nRight, most of the beamsplitters have controllable parameters which we are hoping to change. These parameters are randomly initialized. \n\nI\u2026\n              \n", "link": "https://discuss.pennylane.ai//t/design-circuit-with-strwaberryfileds/892/1"}, "1": {"author": "Nicolas_Quesada", "date": "1614869810309", "content": "Hi @nisq \u2014 I see you have been reading our tutorial on Quantum information with polarized light 10 . Could you explain what the green box in your diagram is?\nPerhaps more generally, before going into coding could you explain to us what is that you are trying to do.\nThanks,\nNicolas", "link": "https://discuss.pennylane.ai//t/design-circuit-with-strwaberryfileds/892/2"}, "2": {"author": "nisq", "date": "1614872294039", "content": "I apologize for confusion. It is nothing. There was a logo of company there and I wanted to close it  sorry\u2026 But up to this green line, we will suppose to prodcue a Bell state like  (|0_a 1b>+|1_a 0_b>)/sqrt(2).\n(The idea is kind of optimization. Suppose that beam splitter is not perfect, or suppose that we have some noise in this circuit. In ideal case if we give our theoretical values to these phase shifters, we should find some  unitary U, however because of the noise or imperfect beam splitter, we may have different result from U.Let\u2019s say we will U\u2019  and so that I will look for right values for my phase shifters for noisy cases for finding exact U. But before the optimization step, I am trying to simulate this circuit)", "link": "https://discuss.pennylane.ai//t/design-circuit-with-strwaberryfileds/892/3"}, "3": {"author": "Tom_Bromley", "date": "1614885964630", "content": "Hi @nisq!\nIf I understand correctly, you are trying to produce a state (|0_a 1b>+|1_a 0_b>)/sqrt(2). Do you know the beamsplitter values that reproduce this state?\nIf not, you can try to optimize your circuit so that it prepares the correct state. To do this, check out this 3 tutorial (although you may use a different circuit to the one given in the tutorial).", "link": "https://discuss.pennylane.ai//t/design-circuit-with-strwaberryfileds/892/4"}, "4": {"author": "nisq", "date": "1614888048024", "content": "I know this tutorial thanks a lot \nBUt My problem is preparing the circuit. I still could not achieve that.\nFor instance Ieven do not know cutoff value is correct or not.\nI pasted my code in the previous answer and after that I am stuck.\nCould you help me please?\nAnd I the values of beam splitter is 50:50 . I already know the values for producing this state\u2026(I will check this step but first I need to write code for this circuit)1 Reply", "link": "https://discuss.pennylane.ai//t/design-circuit-with-strwaberryfileds/892/5"}, "5": {"author": "nisq", "date": "1614889844990", "content": "Ok just for circuit, I wrote this code:\nimport strawberryfields as sf\nfrom strawberryfields import ops\nprog = sf.Program(4)\n\nwith prog.context as q:\n    ops.BSgate() | (q[0], q[1])\n    ops.BSgate() | (q[2], q[3])\n    ops.Rgate(0.5719) | q[0]\n    ops.BSgate() | (q[0], q[1])\n    ops.Rgate(-1.9782) | q[1]\n    ops.BSgate() | (q[0], q[1])\n    ops.Rgate(-1.9782) | q[2]\n    ops.BSgate() | (q[2], q[3])\n    ops.Rgate(-1.9782) | q[2]\n    ops.BSgate() | (q[2], q[3])\neng = sf.Engine(\"fock\", backend_options={\"cutoff_dim\": 5})\n\nprog.print()\n#prog.draw_circuit(tex_dir='./circuit_tex', write_to_file=True)\n\nHowever I am not so sure that\u2026 Can you please check it? (For now I used random values for gates and beamsplitters)I am a bit confused. For instance in this tutorial https://strawberryfields.readthedocs.io/en/stable/code/api/strawberryfields.ops.Interferometer.html  and in the tutorial I have an option for rectangular interferometers\u2026\nWhat should I do ?..\nthis is confusing\u2026 even if my code is correct what can I do with this code\u2026how can I simulate noises\u20261 Reply", "link": "https://discuss.pennylane.ai//t/design-circuit-with-strwaberryfileds/892/6"}, "6": {"author": "Tom_Bromley", "date": "1614892159841", "content": "Hi @nisq!\n\n\n\n nisq:\n\nIeven do not know cutoff value is correct or not.\n\n\nGood question. When using backends like the \"fock\" backend, the state is a tensor that records the amplitudes of photon number states. There is a countably infinite number of such states, so we must introduce a cutoff and only record amplitudes up to that amount. Ideally, we want to set this number to be high to reduce inaccuracy in the simulation, but this comes at a cost of increased simulation time. So the choice of cutoff is a compromise and there is no single correct answer. As a rule of thumb, try to get an idea of the typical number of photons in your system, and you will want to set the cutoff to be suitably larger than that. For example, if we expect say 1 or 2 photons typically, a cutoff of 3 or 4 should be good. For your circuit, it looks like you plan to have 4 (?) photons coming in and being passed through passive gates that do not generate or destroy photons. Hence, a cutoff of 5 should be great for this simulation.\nThe circuit that you shared looks along the right lines! Are you experiencing an error when you try to run? The next step would be to run the program using eng.run() and access the output state of the circuit. You could train that state using the tutorial 3.\n\n\n\n nisq:\n\nI am a bit confused. For instance in this tutorial sf.ops.Interferometer \u2014 Strawberry Fields 0.23.0 documentation and in the tutorial I have an option for rectangular interferometers\u2026\n\n\nYou have manually coded up a circuit based on elementary gates like beamsplitters. The Interferometer gate can be used instead to create a fixed array of beamsplitters that realizes a general interferometer. Whether you use the pre-made interferometer or construct your own circuit depends on the problem you\u2019re considering.\n\n\n\n nisq:\n\nhow can I simulate noises\u2026\n\n\nIf you want to add noise, you can add noise channels such as the loss channel.1", "link": "https://discuss.pennylane.ai//t/design-circuit-with-strwaberryfileds/892/7"}, "7": {"author": "nisq", "date": "1614892768454", "content": "Many thanks \nHere is my result. I have 2 disconnected component but I could not understand \u2026\n\noutput1295\u00d7200 36.8 KB\n\nI will try to use your suggestion for training and in the code I will the circuit component with  my circuit component\nAnd let\u2019s make one point clear: In my curcuit I have 2 qubit and each qubit includes 2 modes. This leans that my modes are 4 right. I mean I al using modes in its right meaning\nAh the warning is coming from q[1] and q[2].\nI mean the warning coming from the part which is just before the green line\n\nBut how can I code in this are. There is no beam splitter and nothing in this point on my chip\u20261 Reply", "link": "https://discuss.pennylane.ai//t/design-circuit-with-strwaberryfileds/892/8"}, "8": {"author": "Tom_Bromley", "date": "1614899335344", "content": "Hi @nisq,\n\n\n\n nisq:\n\nI have 2 disconnected component but I could not understand\n\n\nYes, it looks like there is no connection between the [0, 1] and [2, 3] modes. This is not necessarily a problem, it just means that your four modes could be simulated separately as two systems of two modes.\nLooking at your diagram, the [0, 1] and [2, 3] pairs are correlated due to the beamsplitter to the left of the green box.\n\n\n\n nisq:\n\nAnd let\u2019s make one point clear: In my curcuit I have 2 qubit and each qubit includes 2 modes. This leans that my modes are 4 right. I mean I al using modes in its right meaning\n\n\nYes, I believe you are using a dual-rail type encoding where a qubit state is given by a photon being in one of two modes.\n\n\n\n nisq:\n\nBut how can I code in this are. There is no beam splitter and nothing in this point on my chip\u2026\n\n\nI\u2019m not quite sure what you mean, but from the diagram it looks to me that there is a 50:50 beamsplitter just to the left of the green box, between modes 1 and 2.", "link": "https://discuss.pennylane.ai//t/design-circuit-with-strwaberryfileds/892/9"}, "9": {"author": "nisq", "date": "1614900184731", "content": "But there should be a connection for producing a Bell state I guess\u2026\nAnd according to my code, do I really realize my circuit? Because for now I do not think so we will see cross line. This seems to me like a normal(logical gate)circuit\u2026\nAnd in my optimization scenario, we assume that: we care in the sense that each beam-splitter is a component that might not work as ideally as we expect. But it\u2019s not something that we can control directly. So the parameters we\u2019re interested in tuning are just the phi\u2019s in this instance.\nSO at the end of the circuit, our aim get a maximally violated Bell state.\nAnd in the tutorial https://strawberryfields.ai/photonics/demos/run_state_learner.html 2 I do not think so our aim is the same.\nOr maybe I al wrong and these are the same purposes??\nMy aim is that:\nIn case of beam splitter is not perfect or because of other noises, I will need to chance the angle of my phase shifters for finding right unitary function. For instance in the ideal case I will have U(a1,a2,a3,a4) but because of the noises I may find different U for the same angles like U\u2019(a1,a2,a3,a4) so for finding exact U, I need the change my angle like U(a1\u2019,a2\u2019,a3,a4) or U(a1,a2\u2019,a3\u2019,a4)\u2026) so do you think the paper(which you gave me link) will work for me if I update the circuit and parameter parts? For instance in the link they have 7 different parameters, and in my case I have 6 beam splitter and 4 phase shifters so in total I will have 16 parameters??  I think  I should think my whole circle as 1 layer\nyeah maybe it is work actually\u2026\nBut at which point I will be able to choose my right angles and at which point I will be able to deal with noises\u2026\nI am really sorry for my questions\u2026 This is really new for me\u2026", "link": "https://discuss.pennylane.ai//t/design-circuit-with-strwaberryfileds/892/10"}, "10": {"author": "Tom_Bromley", "date": "1614954319323", "content": "Hi @nisq\n\n\n\n nisq:\n\nBut there should be a connection for producing a Bell state I guess\u2026\nAnd according to my code, do I really realize my circuit? Because for now I do not think so we will see cross line. This seems to me like a normal(logical gate)circuit\u2026\n\n\nI spent some time to recreate your circuit and to train it to produce a target_state. Check out the following code:\nimport strawberryfields as sf\nimport tensorflow as tf\nfrom strawberryfields.ops import Ket, BSgate, Rgate\nimport numpy as np\n\ncutoff_dim = 5\npaths = 2\nmodes = 2 * paths\n\ninitial_state = np.zeros([cutoff_dim] * modes, dtype=np.complex)\ninitial_state[0, 1, 0, 1] = 1\n\nprog = sf.Program(modes)\n\nbs_theta_names = [f\"bs_theta_{str(i) + str(j)}\" for i in range(2) for j in range(3)]\nbs_phi_names = [f\"bs_phi_{str(i) + str(j)}\" for i in range(2) for j in range(3)]\nr_names = [f\"r_{i}\" for i in range(4)]\n\nprog_params = prog.params(*bs_theta_names, *bs_phi_names, *r_names)\n\nwith prog.context as q:\n    Ket(initial_state) | q  # Initial state preparation\n    \n    BSgate(prog_params[0], prog_params[6]) | (q[0], q[1])\n    BSgate(prog_params[3], prog_params[9]) | (q[2], q[3])\n    \n    BSgate() | (q[1], q[2])\n    \n    Rgate(prog_params[12]) | q[0]\n    Rgate(prog_params[13]) | q[2]\n    \n    BSgate(prog_params[1], prog_params[7]) | (q[0], q[1])\n    BSgate(prog_params[4], prog_params[10]) | (q[2], q[3])\n    \n    Rgate(prog_params[14]) | q[0]\n    Rgate(prog_params[15]) | q[2]\n    \n    BSgate(prog_params[2], prog_params[8]) | (q[0], q[1])\n    BSgate(prog_params[5], prog_params[11]) | (q[2], q[3])\n\nparams_bs = tf.Variable(np.random.random((2, 2, 3)))\nparams_r = tf.Variable(np.random.random(4))\n\nparams = [params_bs, params_r]\n    \ntarget_state = np.zeros([cutoff_dim] * modes, dtype=np.complex)\ntarget_state[1, 0, 1, 0] = 1\ntarget_state = tf.constant(target_state, dtype=tf.complex64)\n\ndef overlap(params):\n    mapping_theta = {f\"bs_theta_{str(i) + str(j)}\": params_bs[0, i, j] for i in range(2) for j in range(3)}\n    mapping_phi = {f\"bs_phi_{str(i) + str(j)}\": params_bs[1, i, j] for i in range(2) for j in range(3)}\n    mapping_r = {f\"r_{str(i)}\": params_r[i] for i in range(4)}\n    mapping = {**mapping_theta, **mapping_phi, **mapping_r}\n\n    eng = sf.Engine(backend=\"tf\", backend_options={\"cutoff_dim\": cutoff_dim})\n    result = eng.run(prog, args=mapping)\n\n    ket = result.state.ket()\n    return tf.abs(tf.reduce_sum(tf.math.conj(ket) * target_state) - 1)\n\nreps = 1000\nopt = tf.keras.optimizers.Adam()\n\nprint(\"Optimizing:\")\n\nfor i in range(reps):\n    opt.minimize(lambda: overlap(params), params)\n    \n    if i % 100 == 0:\n        print(f\"Reached step {i} with cost function {overlap(params)}\")\n\nmapping_theta = {f\"bs_theta_{str(i) + str(j)}\": params_bs[0, i, j] for i in range(2) for j in range(3)}\nmapping_phi = {f\"bs_phi_{str(i) + str(j)}\": params_bs[1, i, j] for i in range(2) for j in range(3)}\nmapping_r = {f\"r_{str(i)}\": params_r[i] for i in range(4)}\nmapping = {**mapping_theta, **mapping_phi, **mapping_r}\n\neng = sf.Engine(backend=\"tf\", backend_options={\"cutoff_dim\": cutoff_dim})\nresult = eng.run(prog, args=mapping)\n\nket = result.state.ket()\nprint(f\"Amplitude of target state: {ket[1, 0, 1, 0]}\")\n\nHopefully this will help with your goal. As far as I understand, your next step would be to update the target_state and introduce noise into your circuit using the LossChannel. You would then find the beamsplitter parameters that get you close to the target state. However, note that introducing noise will make your state mixed, so you will need to tweak the code to support the calculations for density matrices.\nGood luck!1", "link": "https://discuss.pennylane.ai//t/design-circuit-with-strwaberryfileds/892/11"}, "11": {"author": "nisq", "date": "1614964708663", "content": "oh thanks !\nI will check the code and if I have question I will ask you.\nMany thanks! you spent your times for me\nso sorry\nOne quick question tf is coming tensorflow I guess right? because we have sf but sf has not keras so it should be tensorflow tf I guess?", "link": "https://discuss.pennylane.ai//t/design-circuit-with-strwaberryfileds/892/12"}, "12": {"author": "Tom_Bromley", "date": "1614967512636", "content": "Thanks @nisq! Good point, yes tf is TensorFlow. I added the following line to the above code:\nimport tensorflow as tf\n", "link": "https://discuss.pennylane.ai//t/design-circuit-with-strwaberryfileds/892/13"}, "13": {"author": "nisq", "date": "1614985341952", "content": "First, I really thank you for your helps:\nHere I have a few questions\n1)Now we do not have 50:50 beam splitters right? we filled our parameters randomly. ? And for the phase shifters,  angles were choosen randomly right\n\nI could not understand what target_state means. It means which state we want to have at the end of the code right?? For instance I want to have maximally violated bell test at the end so should I change this line?\n\ntarget_state[1, 0, 1, 0] = 1\nAnd why this is [1,0,1,0]?\n\n\nMy circuit part is actually just this part\n prog_params = prog.params(*bs_theta_names, *bs_phi_names, *r_names)\n\nprint(\u201cprog_params\u201d,prog_params)\nwith prog.context as q:\nKet(initial_state) | q  # Initial state preparation\n BSgate(prog_params[0], prog_params[6]) | (q[0], q[1])\n BSgate(prog_params[3], prog_params[9]) | (q[2], q[3])\n \n BSgate() | (q[1], q[2])\n \n Rgate(prog_params[12]) | q[0]\n Rgate(prog_params[13]) | q[2]\n \n BSgate(prog_params[1], prog_params[7]) | (q[0], q[1])\n BSgate(prog_params[4], prog_params[10]) | (q[2], q[3])\n \n Rgate(prog_params[14]) | q[0]\n Rgate(prog_params[15]) | q[2]\n \n BSgate(prog_params[2], prog_params[8]) | (q[0], q[1])\n BSgate(prog_params[5], prog_params[11]) | (q[2], q[3])\n\n\n\nand the rest of the code is tranining/optimization right?\nIn this case beam splitters are 50:50 or we just created the circuit and we will fill the parameters randomly?\n4)Why are we using complex type like np.complex or tf.complex64\n5)in this code scripts:\nparams_bs = tf.Variable(np.random.random((2, 2, 3)))\nparams_r = tf.Variable(np.random.random(4))\n\nparams_r for pahse shifters and since we have 4 pahse shifters we gave 4 as a parameter. Right?\nBut I could not understand for beam splitter why do we write (2,2,3) what is the meaning of  3\n6)and according to this code, once we created circuit, then we are filling all the parameters  randomly in the circuit and then we tried to achieve our target state right??? so is it possible to right bell states as a target state or at the end of the code can I have bell test measurements?\n7) when i print initial state all matrices are zero. And when I print target state still all matrices are zero. I know in the code we wrote np.zeros but then we also wrote [1,01,0]=1 and is it normal to see zero matrix\nAnd finally I could not manage to install cudo so at the beginning I get some errors/warning but code is working. Do you think that it will be a problem even if code works or it is not so important\u2026\nThanks for the patience and your times ", "link": "https://discuss.pennylane.ai//t/design-circuit-with-strwaberryfileds/892/14"}, "14": {"author": "Tom_Bromley", "date": "1615211047776", "content": "Hey @nisq,\n\nNow we do not have 50:50 beam splitters right? we filled our parameters randomly. ? And for the phase shifters, angles were choosen randomly right\n\nRight, most of the beamsplitters have controllable parameters which we are hoping to change. These parameters are randomly initialized.\n\nI could not understand what target_state means. It means which state we want to have at the end of the code right?? For instance I want to have maximally violated bell test at the end so should I change this line?\n\nYes, the target state is a tensor of shape (5, 5, 5, 5) which corresponds to the state we want the circuit to prepare. This tensor is a complex vector holding the state amplitudes. You will need to update it to train on your target state, I just set target_state[1, 0, 1, 0] = 1 as a simple example of a case where we\u2019re just swapping the mode of the two photons (remember, initial_state[0, 1, 0, 1] = 1).\n\nMy circuit part is actually just this part\n\nThe circuit is everything contained within with prog.context as q:. The code before that is setup, and after that is optimization. Most of the beamsplitters aren\u2019t 50:50 and are controllable, with the exception of BSgate() | (q[1], q[2]) (which I made 50:50 based on your diagram, but feel free to update).\n\nWhy are we using complex type like np.complex or tf.complex64\n\nAh, there it is because we are loading a numpy array. For example, np.zeros(..., dtype=np.complex). When we make TF tensors or convert NumPy arrays to TF tensors, we can specify a TF dtype, e.g.,\ntf.constant(..., dtype=tf.complex64).\n\nparams_r for pahse shifters and since we have 4 pahse shifters we gave 4 as a parameter. Right?\nBut I could not understand for beam splitter why do we write (2,2,3) what is the meaning of 3\n\nYes there are 4 phase shifters based on the diagram. The (2,2,3) of params_bs could be made a bit tidier, but the first 2 is for selecting thetas vs phis. For example, mapping_theta = {f\"bs_theta_{str(i) + str(j)}\": params_bs[0, i, j] for i in range(2) for j in range(3)}. The second 2 is for selecting whether it is a beamsplitter on the top 2 rows or bottom 2. The final 3 is because there are overall 3 beamsplitters on each pair of rows.\n\nand according to this code, once we created circuit, then we are filling all the parameters randomly in the circuit and then we tried to achieve our target state right??? so is it possible to right bell states as a target state or at the end of the code can I have bell test measurements?\n\nYes the circuit is just training to create a specified target state, so your next step can be to work out how to fill in target_state according to your objective. Note that the circuit doesn\u2019t create or destroy photons, so your target state should have as many photons as the input state (currently 2).\n\nwhen i print initial state all matrices are zero. And when I print target state still all matrices are zero. I know in the code we wrote np.zeros but then we also wrote [1,01,0]=1 and is it normal to see zero matrix\n\ninitial_state has shape (5, 5, 5, 5). There will be quite a few matrices that look all zero and only one of them with a single nonzero element. You could try using np.unique() to convince yourself that the 1 is there.\n\nAnd finally I could not manage to install cudo so at the beginning I get some errors/warning but code is working. Do you think that it will be a problem even if code works or it is not so important\u2026\n\nIt should be ok, if the model is training successfully with the code above.\nThanks!Solution1", "link": "https://discuss.pennylane.ai//t/design-circuit-with-strwaberryfileds/892/15"}, "15": {"author": "nisq", "date": "1615224924835", "content": "Thank you very much !", "link": "https://discuss.pennylane.ai//t/design-circuit-with-strwaberryfileds/892/16"}, "16": {"author": "Tom_Bromley", "date": "1615226325775", "content": "No problem!  1", "link": "https://discuss.pennylane.ai//t/design-circuit-with-strwaberryfileds/892/17"}}