{"0": {"author": "Arun", "date": "1623439457443", "content": "Hi all, I am trying to perform Hamiltonian simulation in pennylane and I am facing some issues although the concept is very simple. The actual code is quite large so here is a part of what I am trying to do: during gate synthesis when I am reducing the L_{2} norm between the actual gate output(e.g. Hadamard) and parameterized gate (here it would be SU(2)(\\alpha, \\beta, \\gamma) for single wire==qubit) via GradientDescentOptimizer the final output i.e. the SU(2) with optimized \\alpha_{optimzed}, \\beta_{optimzed},  \\gamma_{optimzed} is not providing the exact Hadamard. I know that if we break the Hadamard it will simply give R_y(-\\pi/2).\\sigma_x but still, I am getting\n[[ 0.68851887-0.22800782j, -0.68840703+0.00706844j],\n[ 0.68840703+0.00706844j,  0.68851887+0.22800782j]]\ninstead of\n[[ 0.70710678,  0.70710678],\n[ 0.70710678, -0.70710678]]\nso there is always an issue with the -ve sign.\nThe code :\ndev=qml.device(\"default.qubit\",wires=1)\n@qml.qnode(dev)\ndef gate(l):\n    #qml.BasisState(np.array([0], requires_grad=False), wires=0)\n    qml.Rot(l[0],l[1],l[2],wires=0)\n    #qml.Hadamard(wires=0)\n\n    return qml.state()\n\n@qml.qnode(dev)\ndef had_op():\n    qml.Hadamard(wires=0)\n\n    return qml.state()\n\ndef f(l):  #f=cost\n    \n    return np.linalg.norm(np.real(gate(l))-had_op())**2\n\nnp.random.seed(0)\ninit_param=np.random.rand(3)\nparams=init_param\nprint(params)\n\ncost_history = [  ]\nsteps=2000\nfor it in range(steps):\n    params, cost = qml.GradientDescentOptimizer(stepsize=0.01).step_and_cost(f, params)\n    if (it+1)%200==0:\n        \n        print(\"the value of cost at step {:} is {:15f}\".format(it+1,f(params)))\n\n        cost_history.append(cost)\nprint(cost,params)\n\n\nqml.Rot(params[0],params[1],params[2],wires=0).matrix >>\n\n[[ 0.68851887-0.22800782j, -0.68840703+0.00706844j],\n       [ 0.68840703+0.00706844j,  0.68851887+0.22800782j]]\n\nKindly have a look if you can help me in this regard! Thanks in advance", "link": "https://discuss.pennylane.ai//t/gate-synthesis-decomposition-in-pennylane/1112/1"}, "1": {"author": "Tom_Bromley", "date": "1623448547808", "content": "Hey @Arun!\nI had a go at running your code with stepsize=0.1 and 4000 steps, and the resulting matrix looked much closer:\narray([[ 0.70538886-0.06962842j, -0.70538878+0.0022627j ],\n       [ 0.70538878+0.0022627j ,  0.70538886+0.06962842j]])\n\nNote that this is not quite the Hadamard matrix, and its decomposition can be achieved using\nqml.PhaseShift(np.pi / 2, wires=0)\nqml.RX(np.pi / 2, wires=0)\nqml.PhaseShift(np.pi / 2, wires=0)\n\nPerhaps introducing trainable parameters into those gates could help you optimize.", "link": "https://discuss.pennylane.ai//t/gate-synthesis-decomposition-in-pennylane/1112/2"}, "2": {"author": "Arun", "date": "1623449528762", "content": "Hey @Tom_Bromley,\nThanks for your response. Can you just clarify that whether it is possible to decompose Hadamard in terms of only rotation gates? As we know H=R_y(-\\pi/2).(e^{i\\pi/2} R_x(\\pi)) but I wish to obtain this decomposition via stochastic optimization!", "link": "https://discuss.pennylane.ai//t/gate-synthesis-decomposition-in-pennylane/1112/3"}, "3": {"author": "Tom_Bromley", "date": "1623676797572", "content": "Hey @Arun!\n\nCan you just clarify that whether it is possible to decompose Hadamard in terms of only rotation gates?\n\nDo you mean specifically in terms of qml.Rot? The decomposition above into phase shifts and X rotations is a standard decomposition into single-qubit rotations. The code below shows how you can optimize the variational parameters for this decomposition:\nimport pennylane as qml\nfrom pennylane import numpy as np\n\ndev = qml.device(\"default.qubit.autograd\", wires=1)\n\ndef decomposition(params):\n    qml.PhaseShift(params[0], wires=0)\n    qml.RX(params[1], wires=0)\n    qml.PhaseShift(params[2], wires=0)\n\n@qml.qnode(dev, diff_method=\"backprop\")\ndef f(params, state, apply_inv=True):\n    qml.BasisState(np.array([state]), wires=0)\n    decomposition(params)\n    if apply_inv:\n        qml.Hadamard(wires=0).inv()\n    return qml.state()\n\nparams = np.random.random(3)\nId = np.eye(2, requires_grad=False)\n\ndef cost_state(params, state):\n    return np.sum(np.abs(f(params, state) - Id[state]))\n\ndef cost(params):\n    return sum(cost_state(params, i) for i in range(2))\n\nopt = qml.GradientDescentOptimizer(stepsize=0.01)\n\nfor i in range(300):\n    params = opt.step(cost, params)\n\n    if i % 20 == 0:\n        print(f\"Cost at step {i}:\", cost(params))\n        \ndef get_unitary(params):\n    return np.array([f(params, i, apply_inv=False) for i in range(2)]).T\n\nprint(\"\\nOptimized unitary:\\n\", get_unitary(params))\nprint(\"Ideal unitary:\\n\", qml.Hadamard.matrix)\n\nprint(\"\\nOptimized params:\", params.numpy())\nprint(\"Expected params: \", np.array([np.pi / 2] * 3))\n\nNote that this optimization ensures that both input states |0> and |1> are mapped to their expected outputs.\nI believe using Rot alone can only approximate the Hadamard gate up to a global phase, so won\u2019t work in the above example. You could consider changing the cost function from the norm to the fidelity (which is insensitive to global phase) and using just Rot will then probably work.\nThanks!1", "link": "https://discuss.pennylane.ai//t/gate-synthesis-decomposition-in-pennylane/1112/4"}, "4": {"author": "Arun", "date": "1623677992230", "content": "Hi @Tom_Bromley,\nThank you very much for your beautiful response and the above solution is perfect. And as a response to your query, I thought we can decompose any unitary in terms of rotations and a global phase because that\u2019s what we need to produce any general unitary \\in SU(2)  i.e.  U=e^{i\\phi} R_{n1}(\\theta_1)R_{n2}(\\theta_2)R_{n1}(\\theta_3). But still the above solution worth it.\nThanks again  ,", "link": "https://discuss.pennylane.ai//t/gate-synthesis-decomposition-in-pennylane/1112/5"}, "5": {"author": "Tom_Bromley", "date": "1623678842677", "content": "No problem!\n\nU=e^{i\\phi} R_{n1}(\\theta_1)R_{n2}(\\theta_2)R_{n1}(\\theta_3)\n\nRight! You will probably have some luck with combining a Rot gate with a PhaseShift gate, using 4 parameters overall. Good luck!1", "link": "https://discuss.pennylane.ai//t/gate-synthesis-decomposition-in-pennylane/1112/6"}, "6": {"author": "Arun", "date": "1623679234092", "content": "Thanks,  @Tom_Bromley again ,\nyour suggestion(Phase + Rotation) works properly with a total of 1000 steps.1", "link": "https://discuss.pennylane.ai//t/gate-synthesis-decomposition-in-pennylane/1112/7"}, "7": {"author": "Arun", "date": "1623439457443", "content": "Hi all, I am trying to perform Hamiltonian simulation in pennylane and I am facing some issues although the concept is very simple. The actual code is quite large so here is a part of what I am trying to do: during gate synthesis when I am reducing the L_{2}L2 norm between the actual gate output(e.g. Hadamard) and parameterized gate (here it would be SU(2)(\\alpha, \\beta, \\gamma\u03b1,\u03b2,\u03b3) for single wire==qubit) via GradientDescentOptimizer the final output i.e. the SU(2) with optimized \\alpha_{optimzed}, \\beta_{optimzed},  \\gamma_{optimzed}\u03b1optimzed,\u03b2optimzed,\u03b3optimzed is not providing the exact Hadamard. I know that if we break the Hadamard it will simply give R_y(-\\pi/2).\\sigma_xRy(\u2212\u03c0/2).\u03c3x but still, I am getting\n[[ 0.68851887-0.22800782j, -0.68840703+0.00706844j],\n[ 0.68840703+0.00706844j,  0.68851887+0.22800782j]]\ninstead of\n[[ 0.70710678,  0.70710678],\n[ 0.70710678, -0.70710678]]\nso there is always an issue with the -ve sign.\nThe code :\ndev=qml.device(\"default.qubit\",wires=1)\n@qml.qnode(dev)\ndef gate(l):\n    #qml.BasisState(np.array([0], requires_grad=False), wires=0)\n    qml.Rot(l[0],l[1],l[2],wires=0)\n    #qml.Hadamard(wires=0)\n\n    return qml.state()\n\n@qml.qnode(dev)\ndef had_op():\n    qml.Hadamard(wires=0)\n\n    return qml.state()\n\ndef f(l):  #f=cost\n    \n    return np.linalg.norm(np.real(gate(l))-had_op())**2\n\nnp.random.seed(0)\ninit_param=np.random.rand(3)\nparams=init_param\nprint(params)\n\ncost_history = [  ]\nsteps=2000\nfor it in range(steps):\n    params, cost = qml.GradientDescentOptimizer(stepsize=0.01).step_and_cost(f, params)\n    if (it+1)%200==0:\n        \n        print(\"the value of cost at step {:} is {:15f}\".format(it+1,f(params)))\n\n        cost_history.append(cost)\nprint(cost,params)\n\n\nqml.Rot(params[0],params[1],params[2],wires=0).matrix >>\n\n[[ 0.68851887-0.22800782j, -0.68840703+0.00706844j],\n       [ 0.68840703+0.00706844j,  0.68851887+0.22800782j]]\n\nKindly have a look if you can help me in this regard! Thanks in advance", "link": "https://discuss.pennylane.ai//t/gate-synthesis-decomposition-in-pennylane/1112/8"}, "8": {"author": "Arun", "date": "1623449528762", "content": "Hey @Tom_Bromley,\nThanks for your response. Can you just clarify that whether it is possible to decompose Hadamard in terms of only rotation gates? As we know H=R_y(-\\pi/2).(e^{i\\pi/2} R_x(\\pi))H=Ry(\u2212\u03c0/2).(ei\u03c0/2Rx(\u03c0)) but I wish to obtain this decomposition via stochastic optimization!", "link": "https://discuss.pennylane.ai//t/gate-synthesis-decomposition-in-pennylane/1112/9"}, "9": {"author": "Arun", "date": "1623677992230", "content": "Hi @Tom_Bromley,\nThank you very much for your beautiful response and the above solution is perfect. And as a response to your query, I thought we can decompose any unitary in terms of rotations and a global phase because that\u2019s what we need to produce any general unitary \\in SU(2)\u2208SU(2)  i.e.  U=e^{i\\phi} R_{n1}(\\theta_1)R_{n2}(\\theta_2)R_{n1}(\\theta_3)U=ei\u03d5Rn1(\u03b81)Rn2(\u03b82)Rn1(\u03b83). But still the above solution worth it.\nThanks again  ,", "link": "https://discuss.pennylane.ai//t/gate-synthesis-decomposition-in-pennylane/1112/10"}, "10": {"author": "Tom_Bromley", "date": "1623678842677", "content": "No problem!\n\nU=e^{i\\phi} R_{n1}(\\theta_1)R_{n2}(\\theta_2)R_{n1}(\\theta_3)U=ei\u03d5Rn1(\u03b81)Rn2(\u03b82)Rn1(\u03b83)\n\nRight! You will probably have some luck with combining a Rot gate with a PhaseShift gate, using 4 parameters overall. Good luck!1", "link": "https://discuss.pennylane.ai//t/gate-synthesis-decomposition-in-pennylane/1112/11"}}