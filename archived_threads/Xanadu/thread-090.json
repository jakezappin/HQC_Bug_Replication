{"0": {"author": "paulin_ds", "date": "1673965382612", "content": "Hi, I am currently trying to add a weighted sampling to my VQE using JAX. Indeed, I want to sample accoring to coefficients stored in a jax device array. However, it seems that it\u2019s not possible to specify the number of shots with a jax device array since when I try\n@jax.jit\ndef Circuits_Sample_Ub(key, params, inputs, nbr_shot):\n    dev = qml.device('default.qubit.jax', wires=n_qubits//2, shots=nbr_shot, prng_key=key)  \n    @jax.jit\n    @qml.qnode(dev, interface='jax', diff_method=None)\n    def qnode(params, inputs):\n        for i in range(n_qubits//2):\n          qml.RX(jnp.pi*inputs[i], wires=i)\n        brick_wall_entangling(params)\n        return qml.sample()\n    return qnode(params, inputs)\n\nCircuits_Sample_Ub(key, params_A, bitstringA[0], (coef[0]**2*1000).astype(int))\n\nI get\nDeviceError: Shots must be a single non-negative integer or a sequence of non-negative integers.\nand this even if I try without jititng. Is there a solution? Thanks a lot.\nPaulin", "link": "https://discuss.pennylane.ai//t/default-qubit-jax-and-weighted-sampling/2442/1"}, "1": {"author": "CatalinaAlbornoz", "date": "1674590419403", "content": "Hi @paulin_ds,\nYou can in fact specify the number of shots, in fact in our Using JAX with PennyLane demo 1 we have a section on using shots.\nHowever if you want to pass it as a parameter of Circuits_Sample_Ub you need to specify that it\u2019s a static argument. Otherwise Jax will introduce an abstract tracer for it. You can learn more about this in the Jax documentation here.\nHere\u2019s an example using this. As you can see in the jax.jit docs I used the @partial decorator in order to specify the index of the static argument. I\u2019m not sure if this will break something in other parts of your code but you can give it a try.\nfrom functools import partial\n\n@partial(jax.jit,static_argnums=3)\ndef Circuits_Sample_Ub(key, params, inputs, nbr_shot):\n    dev = qml.device('default.qubit.jax', wires=n_qubits//2, shots=nbr_shot, prng_key=key)  \n    @jax.jit\n    @qml.qnode(dev, interface='jax', diff_method=None)\n    def qnode(params, inputs):\n        for i in range(n_qubits//2):\n            qml.RX(jnp.pi*inputs[i], wires=i)\n        #brick_wall_entangling(params)\n        qml.BasicEntanglerLayers(weights=params, wires=range(n_qubits//2)) # Added this\n        return qml.sample()\n    return qnode(params, inputs)\n\n## -- Added this ---\nkey = jax.random.PRNGKey(0)\nshape = qml.BasicEntanglerLayers.shape(n_layers=2, n_wires=n_qubits//2)\nparams_A = np.random.random(size=shape)\ninputs = np.ones(n_qubits//2)\nnbr_shot = 10\n## ---\n\nCircuits_Sample_Ub(key, params_A, inputs, nbr_shot)\n\nYou will see that this example is similar to your code but I had to add some things since I didn\u2019t have access to all of your functions.\nI hope this helps you!", "link": "https://discuss.pennylane.ai//t/default-qubit-jax-and-weighted-sampling/2442/2"}, "2": {"author": "paulin_ds", "date": "1674658759792", "content": "Yes of course. But I think that if we make this argument static, if we change the number of shot, the function recompile. This make an adaptative sampling very unefficient. My question was more: would it be possible to have this argument non-static (thus it could be traced by jax and it wouldnt have to be recompiled everytime)?\nThanks a lot", "link": "https://discuss.pennylane.ai//t/default-qubit-jax-and-weighted-sampling/2442/3"}, "3": {"author": "Romain_Moyard", "date": "1674668468733", "content": "Hi @paulin_ds, it is a known issues that jitting the device create problems with shots/wires. That\u2019s something we want to make better in the future. I would suggest you to create the device outside the jitted function as below. It will recompile if you change the number of shots but at the moment we do not have a better solution unfortunately.\n@jax.jit\ndef Circuits_Sample_Ub(params, inputs):\n\n    @qml.qnode(dev, interface='jax', diff_method=None)\n    def qnode(params, inputs):\n        for i in range(n_qubits//2):\n            qml.RX(jnp.pi*inputs[i], wires=i)\n        #brick_wall_entangling(params)\n        qml.BasicEntanglerLayers(weights=params, wires=range(n_qubits//2)) # Added this\n        return qml.sample()\n    return qnode(params, inputs)\n\n\n## -- Added this ---\nn_qubits=2\nkey = jax.random.PRNGKey(0)\nshape = qml.BasicEntanglerLayers.shape(n_layers=2, n_wires=n_qubits//2)\nparams_A = np.random.random(size=shape)\ninputs = np.ones(n_qubits//2)\nnbr_shot = 10\n## ---\ndev = qml.device('default.qubit.jax', wires=n_qubits // 2, shots=nbr_shot, prng_key=key)\nCircuits_Sample_Ub(params_A, inputs)\n1", "link": "https://discuss.pennylane.ai//t/default-qubit-jax-and-weighted-sampling/2442/4"}, "4": {"author": "paulin_ds", "date": "1674669316638", "content": "Ok I understand. Thanks anyway for these nice explanations.\ngood continuation,\nPaulin", "link": "https://discuss.pennylane.ai//t/default-qubit-jax-and-weighted-sampling/2442/5"}, "5": {"author": "CatalinaAlbornoz", "date": "1674681614492", "content": "Thank you very much for your question @paulin_ds. This helps us to make PennyLane better  . Please let us know if you find other use cases that are not supported.", "link": "https://discuss.pennylane.ai//t/default-qubit-jax-and-weighted-sampling/2442/6"}, "6": {"author": "paulin_ds", "date": "1673965382612", "content": "Hi, I am currently trying to add a weighted sampling to my VQE using JAX. Indeed, I want to sample accoring to coefficients stored in a jax device array. However, it seems that it\u2019s not possible to specify the number of shots with a jax device array since when I try\n@jax.jit\ndef Circuits_Sample_Ub(key, params, inputs, nbr_shot):\n    dev = qml.device('default.qubit.jax', wires=n_qubits//2, shots=nbr_shot, prng_key=key)  \n    @jax.jit\n    @qml.qnode(dev, interface='jax', diff_method=None)\n    def qnode(params, inputs):\n        for i in range(n_qubits//2):\n          qml.RX(jnp.pi*inputs[i], wires=i)\n        brick_wall_entangling(params)\n        return qml.sample()\n    return qnode(params, inputs)\n\nCircuits_Sample_Ub(key, params_A, bitstringA[0], (coef[0]**2*1000).astype(int))\n\nI get\nDeviceError: Shots must be a single non-negative integer or a sequence of non-negative integers.\nand this even if I try without jititng. Is there a solution? Thanks a lot.\nPaulin", "link": "https://discuss.pennylane.ai//t/default-qubit-jax-and-weighted-sampling/2442/7"}}