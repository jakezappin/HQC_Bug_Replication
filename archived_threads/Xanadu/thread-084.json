{"0": {"author": "Shawn", "date": "1596710406759", "content": "Hey everyone,\nI am using the CVNN at the moment and I would like to simplify it and just use a one layer neural network:\nout_dim = 4\nwires = 1\nn_quantum_layers = 2\n\ndev = qml.device(\"strawberryfields.fock\", wires=wires, cutoff_dim=30)\n\n@qml.qnode(dev)\ndef layer(inputs, w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10):\n    qml.templates.DisplacementEmbedding(inputs, wires=range(wires))\n    qml.templates.CVNeuralNetLayers(w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, wires=range(wires))\n    return [qml.expval(qml.X(wires=i)) for i in range(wires)]\n\nweights = qml.init.cvqnn_layers_all(n_quantum_layers, wires)#, seed=0)\nweight_shapes = {\"w{}\".format(i): w.shape for i, w in enumerate(weights)}\nqlayer = qml.qnn.KerasLayer(layer, weight_shapes, output_dim=wires)\nclayer_in = tf.keras.layers.Dense(wires)\nclayer_out = tf.keras.layers.Dense(out_dim)\nmodel = tf.keras.models.Sequential([clayer_in, qlayer, clayer_out])\nmodel.compile(optimizer=tf.keras.optimizers.Adam(learning_rate = 0.00012), loss = 'mse')\n\nAnd I would like to for example just use a simple displacement layer:\ndev = qml.device(\"strawberryfields.fock\", wires=wires, cutoff_dim=30)\n\n@qml.qnode(dev)\ndef layer(inputs, x):\n    qml.templates.DisplacementEmbedding(inputs, wires=range(wires))\n    qml.Displacement(x, 0, wires=range(wires)\n    return [qml.expval(qml.X(wires=i)) for i in range(wires)]\n\nbut am unsure what to put for the weights and the weight_shapes for\nqlayer = qml.qnn.KerasLayer(layer, weight_shapes, output_dim=wires)\n\nAny insight is appreciated!\n\n\n Solved by Tom_Bromley in post #9 \n\n\n                Yes, the MemoryError for increasing wire number should be due to representing the cutoff ** wires dimensional state in the Fock basis. \nFor wires=2, try replacing this line: \nqml.templates.Interferometer([theta], [phi], varphi, wires=range(wires)) \nThis is needed because the theta and phi are one-di\u2026\n              \n", "link": "https://discuss.pennylane.ai//t/making-a-one-layer-neural-network/504/1"}, "1": {"author": "jmarrazola", "date": "1596752720798", "content": "Hi Shawn,\nAs far as I understand, the variational parameters of your quantum circuit are the displacements, which you call x in the code. These are 1-dimensional parameters. Then you are applying a displacement for each wire. So if you have n wires, these parameters are just an array of dimension n.\nI haven\u2019t used the KerasLayer before, but reading the documentation, I believe in your case you should simply set weight_shapes = {\"x\": wires}.\nLet me know if that works!", "link": "https://discuss.pennylane.ai//t/making-a-one-layer-neural-network/504/2"}, "2": {"author": "Shawn", "date": "1596825357646", "content": "Thanks @jmarrazola it worked!1", "link": "https://discuss.pennylane.ai//t/making-a-one-layer-neural-network/504/3"}, "3": {"author": "Shawn", "date": "1596870412036", "content": "Hi @jmarrazola one more question \nI\u2019m trying to get this to work:\ndef layer(inputs, w, x, y, z):\n    qml.templates.DisplacementEmbedding(inputs, wires=range(wires))\n    qml.Interferometer(np.array([w]), wires=range(wires))\n    qml.Displacement(x, 0, wires=range(wires))\n    qml.Rotation(y, wires=range(wires))\n    qml.Kerr(z, wires=range(wires))\n    return [qml.expval(qml.X(wires=i)) for i in range(wires)]\na = [\"x\",\"y\",\"z\",\"w\"]\nweight_shapes = {a[i]: wires for i in range(len(a))}\n\nBut I keep getting errors. Can anyone tell me what\u2019s wrong with the layer or the weight_shapes?", "link": "https://discuss.pennylane.ai//t/making-a-one-layer-neural-network/504/4"}, "4": {"author": "Tom_Bromley", "date": "1597060286811", "content": "Hey @Shawn,\nThere are three things causing a problem here:\n\n\nInside the circuit, you are using single mode gates on multiple wires (e.g., Displacement, Rotation, Kerr).\n\n\nYou should use qml.templates.Interferometer, which applies the interferometer according to some trainable angles. The qml.Interferometer you were using requires an input unitary.\n\n\nThe interferometer should be fed three variables and the shape of each should be declared in weight_shapes. Their shapes are not simply wires, you can find them here 2.\n\n\nYour code should look something more like this:\ndef layer(inputs, theta, phi, varphi, x, y, z):\n    qml.templates.DisplacementEmbedding(inputs, wires=range(wires))\n    qml.templates.Interferometer(theta, phi, varphi, wires=range(wires))\n    for i in range(wires):\n        qml.Displacement(x[i], 0, wires=i)\n        qml.Rotation(y[i], wires=i)\n        qml.Kerr(z[i], wires=i)\n    return [qml.expval(qml.X(wires=i)) for i in range(wires)]\n\ninterferometer_shape = int(wires * (wires - 1) / 2)\n\nweight_shapes = {\n    \"theta\": interferometer_shape,\n    \"phi\": interferometer_shape,\n    \"varphi\": wires,\n    \"x\": wires,\n    \"y\": wires,\n    \"z\": wires,\n}\n\nAs a quick test, this makes a usable Keras layer:\ndev = qml.device(\"strawberryfields.fock\", wires=wires, cutoff_dim=4)\nqnode = qml.QNode(layer, dev)\nqlayer = qml.qnn.KerasLayer(qnode, weight_shapes, wires)\n\nimport numpy as np\nx = np.random.random((10, wires))\nqlayer(x)\n", "link": "https://discuss.pennylane.ai//t/making-a-one-layer-neural-network/504/5"}, "5": {"author": "Shawn", "date": "1597063156460", "content": "Hi @Tom_Bromley thanks a lot for the help. When running the code I am getting the following error:\nWARNING:tensorflow:Layer keras_layer is casting an input tensor from dtype float64 to the layer's dtype of float32, which is new behavior in TensorFlow 2.  The layer has dtype float32 because it's dtype defaults to floatx.\n\nIf you intended to run this layer in float32, you can safely ignore this warning. If in doubt, this warning is likely only an issue if you are porting a TensorFlow 1.X model to TensorFlow 2.\n\nTo change all layers to have dtype float64 by default, call `tf.keras.backend.set_floatx('float64')`. To change just this layer, pass dtype='float64' to the layer constructor. If you are the author of this layer, you can disable autocasting by passing autocast=False to the base Layer constructor.\n\nTraceback (most recent call last):\n  File \"froz_versuch.py\", line 40, in <module>\n    qlayer(x)\nValueError: wrong shape of weight input(s) detected", "link": "https://discuss.pennylane.ai//t/making-a-one-layer-neural-network/504/6"}, "6": {"author": "Tom_Bromley", "date": "1597063890656", "content": "Hey @Shawn, that\u2019s odd.\nHere is the full code that I managed to get working:\nimport pennylane as qml\n\nwires = 4\n\ndef layer(inputs, theta, phi, varphi, x, y, z):\n    qml.templates.DisplacementEmbedding(inputs, wires=range(wires))\n    qml.templates.Interferometer(theta, phi, varphi, wires=range(wires))\n    for i in range(wires):\n        qml.Displacement(x[i], 0, wires=i)\n        qml.Rotation(y[i], wires=i)\n        qml.Kerr(z[i], wires=i)\n    return [qml.expval(qml.X(wires=i)) for i in range(wires)]\n\ninterferometer_shape = int(wires * (wires - 1) / 2)\n\nweight_shapes = {\n    \"theta\": interferometer_shape,\n    \"phi\": interferometer_shape,\n    \"varphi\": 4,\n    \"x\": wires,\n    \"y\": wires,\n    \"z\": wires,\n}\n\ndev = qml.device(\"strawberryfields.fock\", wires=wires, cutoff_dim=4)\nqnode = qml.QNode(layer, dev)\nqlayer = qml.qnn.KerasLayer(qnode, weight_shapes, wires)\n\nimport numpy as np\nx = np.random.random((10, wires))\nqlayer(x)\n\nIf you copy/paste that, are you still getting an error?", "link": "https://discuss.pennylane.ai//t/making-a-one-layer-neural-network/504/7"}, "7": {"author": "Shawn", "date": "1597064504718", "content": "Hi @Tom_Bromley, it seems to only work when wires = 3,4,5,6,7 (8 and beyond I get a space error so I would assume it works also for 8 and onward). For wires = 1,2 the error occurs.  Could it be that interferometer_shape needs to be  bigger than 1?", "link": "https://discuss.pennylane.ai//t/making-a-one-layer-neural-network/504/8"}, "8": {"author": "Tom_Bromley", "date": "1597149070161", "content": "Yes, the MemoryError for increasing wire number should be due to representing the cutoff ** wires dimensional state in the Fock basis.\nFor wires=2, try replacing this line:\nqml.templates.Interferometer([theta], [phi], varphi, wires=range(wires))\nThis is needed because the theta and phi are one-dimensional for wires=2 and end up getting internally flattened from an array to a float.\nFor wires=1, you could just swap out the interferometer with a qml.Rotation() gate.Solution", "link": "https://discuss.pennylane.ai//t/making-a-one-layer-neural-network/504/9"}, "9": {"author": "Shawn", "date": "1597151213210", "content": "Thank you @Tom_Bromley! Both of them are working.1", "link": "https://discuss.pennylane.ai//t/making-a-one-layer-neural-network/504/10"}}