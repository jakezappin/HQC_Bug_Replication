{"0": {"author": "eisenmsi", "date": "1689784169741", "content": "Hi!\nI want to use qml.AmplitudeEmbedding. However, I need to calculate gradients for gradient descent. According to qml.AmplitudeEmbedding \u2014 PennyLane 0.31.0 documentation 3, this is not possible. Is this correct? Is there a way to do it anyway? When will it be possible?", "link": "https://discuss.pennylane.ai//t/calculate-gradients-using-qml-amplitudeembedding/3197/1"}, "1": {"author": "Ivana_at_Xanadu", "date": "1689801650788", "content": "Hi @eisenmsi, thanks for your question! \nWhat is the exact problem you\u2019re trying to solve?\nIf you\u2019re trying to calculate a gradient with respect to the feature vector used within a qml.AmplitudeEmbedding call, unfortunately that won\u2019t be possible. The processing that happens to get you the state you\u2019re creating there is very much non-trivial and, in general, not differentiable.\nHowever, depending on what exactly you\u2019re trying to do, maybe you can find a workaround. For example, maybe there\u2019s some other approach you can use to prepare your desired state?\nBut if you\u2019re trying to calculate a gradient with respect to some other parameter in the circuit (not the feature vector here), that should not be a problem. 1 Reply2", "link": "https://discuss.pennylane.ai//t/calculate-gradients-using-qml-amplitudeembedding/3197/2"}, "2": {"author": "CatalinaAlbornoz", "date": "1689866382437", "content": "Hi @eisenmsi ,\nGreat question! Notice that Amplitude Embedding is designed to embed non-trainable features into your circuit. From what I understand you want to create an optimization routine where you train over a set of parameters. Below you will see an example of how you can do this. You will notice that I use AmplitudeEmbedding for embedding my features and I use BasicEntanglerLayers to add my parameters.\n# Import your favourite libraries\nimport pennylane as qml\nfrom pennylane import numpy as np\n\n# Define the number of wires and the device\nn_wires = 2\ndev = qml.device('lightning.qubit',wires=n_wires)\n\n# Create a qnode\n@qml.qnode(dev)\ndef circuit(features,parameters):\n  # Embed your features\n  qml.AmplitudeEmbedding(features,range(n_wires), normalize=True)\n  # Create an ansatz where you will add your trainable parameters\n  qml.BasicEntanglerLayers(weights=parameters, wires=range(n_wires))\n  # Return a measurement\n  return qml.expval(qml.PauliZ(0))\n\n# Define your features\nfeatures = np.array([1.,2.,3.,4.],requires_grad=False)\n# Define your initial parameters and set them as trainable\nparameters = np.array([[1.,np.pi],[0.,1.]],requires_grad=True)\n\n# Draw your circuit\nqml.draw_mpl(circuit)(features,parameters);\n\n# Create a cost function\ndef cost(features,parameters):\n    return (circuit(features,parameters))**2\n\n# Define an optimizer\nopt = qml.GradientDescentOptimizer(stepsize=0.1)\n\n# Iterate, updating your parameters after every iteration\nfor it in range(15):\n  features_and_parameters = opt.step(cost,features,parameters)\n  parameters = features_and_parameters[1]\n  print('Cost: ', cost(features,parameters))\n\n# Notice how the cost converges\n\nPlease let me know if this is helpful or if you were looking for something different!1 Reply1", "link": "https://discuss.pennylane.ai//t/calculate-gradients-using-qml-amplitudeembedding/3197/3"}, "3": {"author": "eisenmsi", "date": "1689941238103", "content": "Thanks for the answer! Yes, I would like to calculate the gradient with respect to the features. Is there another way to efficiently encode the features into a quantum circuit that remains differentiable?", "link": "https://discuss.pennylane.ai//t/calculate-gradients-using-qml-amplitudeembedding/3197/4"}, "4": {"author": "eisenmsi", "date": "1689941626805", "content": "Thank you! This is very helpful! So I can use qml.AmplitudeEmbedding in the context of gradient descent as long as I don\u2019t have the features as trainable parameters!?", "link": "https://discuss.pennylane.ai//t/calculate-gradients-using-qml-amplitudeembedding/3197/5"}, "5": {"author": "Guillermo_Alonso", "date": "1689944556652", "content": "That\u2019s right!  There is a trick that allows you to do this but it could be a bit more complicated.  qml.MottotenStatePreparation will give you an equivalent circuit that generates the state you want with rotations and CNOTs. You would have to build that circuit and use the parameters of the rotations you have obtained with the template.\nOn the other hand, if you are using a quantum computer, note that the gradient is not a unique property of an initial state. You can find several circuits that generate the same state but have a different gradient or even different number of parameters.1", "link": "https://discuss.pennylane.ai//t/calculate-gradients-using-qml-amplitudeembedding/3197/6"}, "6": {"author": "eisenmsi", "date": "1689784169741", "content": "Hi!\nI want to use qml.AmplitudeEmbedding. However, I need to calculate gradients for gradient descent. According to qml.AmplitudeEmbedding \u2014 PennyLane 0.31.0 documentation 3, this is not possible. Is this correct? Is there a way to do it anyway? When will it be possible?", "link": "https://discuss.pennylane.ai//t/calculate-gradients-using-qml-amplitudeembedding/3197/7"}}