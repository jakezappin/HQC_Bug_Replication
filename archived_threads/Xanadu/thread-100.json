{"0": {"author": "mxn.wls", "date": "1557953142318", "content": "Hey!\nI would like to construct a cost function to minimise that looks like this\nC = < z1 > + < z2 >  + < z1z2 >\nWhere   is the expectation over the Hermitian observable\nzz_observable = (1/2)*np.array([[1,0,0,0],[0,-1,0,0],[0,0,-1,0],[0,0,0,1]])\n\n\nThe Hermitian observable is not supported by the qiskit.basicaer backend. Do you know what might be a good replacement? I was hoping to use the noise functionality of the qiskit simulator.\n\n\nIf inside the qnode you perform the < z1 > and < z1z2 > computations the error returned is\nQuantumFunctionError: Each wire in the quantum circuit can only be measured once.\nDoes this mean that we can\u2019t compute both < z1 > and < z1z2 >?\n\n\nFull code + errors reproduced below.\nCODE\nConversion between problem idxs (with signs) to qubits idxs (without signs)\nsign = lambda x: np.sign(x)\n\ndef sign_qubit(term): # s denotes the sign and a and b refer to the idx. Minus 1 from idx to return to standard indexing\n  a = abs(term[0]) - 1\n  b = abs(term[1]) - 1\n  sa = sign(term[0])\n  sb = sign(term[1])\n  return sa, a, sb, b\n\nN = 2\ndev = qml.device('default.qubit', wires=N)\n\nzz_observable = (1/2)*np.array([[1,0,0,0],[0,-1,0,0],[0,0,-1,0],[0,0,0,1]])\n\nproblem  = [[2, 1]]\nqubits  = ['zz1', 'zz2']\n\nQAOA phases\ndef mixer(beta):\n  for q in range(N): qml.RX(beta, wires=q)\n  return None\n\ndef separator(gamma, problem):\n  for term in problem:\n    sa, a, sb, b = sign_qubit(term)\n    qml.RZ(sa * gamma, wires=a)\n    qml.RZ(sb * gamma, wires=b)\n    ## ZZ operation\n    qml.CNOT(wires=[a, b])\n    qml.RZ(sb * gamma * 2., wires=b)\n    qml.CNOT(wires=[a, b])\nreturn None\n\n@qml.qnode(dev)\ndef qaoa(params):\n  for i in range(N): qml.Hadamard(wires=i) \n\n  gamma = params[0]\n  beta = params[1]\n  separator(gamma, problem)\n  mixer(beta)\n\n# Cost\n  single_qubit_expectations = [qml.expval.PauliZ(i) for i in range(N)]\n  two_qubit_expectations = [qml.expval.Hermitian(zz_observable, \nwires=[abs(a)-1,abs(b)-1]) for a,b in problem]\n  single_qubit_expectations.extend(two_qubit_expectations)\n  return single_qubit_expectations\n\ninitialise the optimizer\nopt = qml.GradientDescentOptimizer(stepsize=0.4)\n\ndef cost(params):\n  return np.sum(qaoa(params))\n\nset the number of steps\nsteps = 100\n\nset the initial parameter values\nparams = np.array([0.01, 0.01])\n\nfor i in range(steps):\n  print('here')\n  # update the circuit parameters\n  params = opt.step(cost, params)\n  print('here')\n\n\nif (i+1) % 5 == 0:\n    print('Cost after step {:5d}: {: .7f}'.format(i+1, cost(params)))\n\nprint('Optimized rotation angles: {}'.format(params))\n\nERROR\nhere\nQuantumFunctionError                      Traceback (most recent call last)\n in \n64     print(\u2018here\u2019)\n65     # update the circuit parameters\n\u2014> 66     params = opt.step(cost, params)\n67     print(\u2018here\u2019)\n68\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/optimize/gradient_descent.py in step(self, objective_fn, x, grad_fn)\n61         \u201c\u201d\"\n62\n\u2014> 63         g = self.compute_grad(objective_fn, x, grad_fn=grad_fn)\n64\n65         x_out = self.apply_grad(g, x)\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/optimize/gradient_descent.py in compute_grad(objective_fn, x, grad_fn)\n85         else:\n86             # default is autograd\n\u2014> 87             g = autograd.grad(objective_fn)(x)  # pylint: disable=no-value-for-parameter\n88         return g\n89\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/wrap_util.py in nary_f(*args, **kwargs)\n18             else:\n19                 x = tuple(args[i] for i in argnum)\n\u2014> 20             return unary_operator(unary_f, x, *nary_op_args, **nary_op_kwargs)\n21         return nary_f\n22     return nary_operator\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/differential_operators.py in grad(fun, x)\n22     arguments as fun, but returns the gradient instead. The function fun\n23     should be scalar-valued. The gradient has the same type as the argument.\"\"\"\n\u2014> 24     vjp, ans = _make_vjp(fun, x)\n25     if not vspace(ans).size == 1:\n26         raise TypeError(\"Grad only applies to real scalar-output functions. \"\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/core.py in make_vjp(fun, x)\n8 def make_vjp(fun, x):\n9     start_node = VJPNode.new_root(x)\n\u2014> 10     end_value, end_node =  trace(start_node, fun, x)\n11     if end_node is None:\n12         def vjp(g): return vspace(x).zeros()\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/tracer.py in trace(start_node, fun, x)\n8     with trace_stack.new_trace() as t:\n9         start_box = new_box(x, t, start_node)\n\u2014> 10         end_box = fun(start_box)\n11         if isbox(end_box) and end_box._trace == start_box._trace:\n12             return end_box._value, end_box._node\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/wrap_util.py in unary_f(x)\n13                 else:\n14                     subargs = subvals(args, zip(argnum, x))\n\u2014> 15                 return fun(*subargs, **kwargs)\n16             if isinstance(argnum, int):\n17                 x = args[argnum]\n in cost(params)\n54\n55 def cost(params):\n\u2014> 56     return np.sum(qaoa(params))\n57\n58 # set the number of steps\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/decorator.py in wrapper(*args, **kwargs)\n151         def wrapper(*args, **kwargs):\n152             \u201c\u201d\u201cWrapper function\u201d\"\"\n\u2013> 153             return qnode(*args, **kwargs)\n154\n155         # bind the jacobian method to the wrapped function\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/qnode.py in call(self, *args, **kwargs)\n455         # pylint: disable=no-member\n456         args = autograd.builtins.tuple(args)  # prevents autograd boxed arguments from going through to evaluate\n\u2013> 457         return self.evaluate(args, **kwargs)  # args as one tuple\n458\n459     @ae.primitive\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/tracer.py in f_wrapped(*args, **kwargs)\n42             parents = tuple(box._node for _     , box in boxed_args)\n43             argnums = tuple(argnum    for argnum, _   in boxed_args)\n\u2014> 44             ans = f_wrapped(*argvals, **kwargs)\n45             node = node_constructor(ans, f_wrapped, argvals, kwargs, argnums, parents)\n46             return new_box(ans, trace, node)\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/tracer.py in f_wrapped(*args, **kwargs)\n46             return new_box(ans, trace, node)\n47         else:\n\u2014> 48             return f_raw(*args, **kwargs)\n49     f_wrapped.fun = f_raw\n50     f_wrapped._is_autograd_primitive = True\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/qnode.py in evaluate(self, args, **kwargs)\n497         m_wires = list(w for ex in self.ev for w in ex.wires)\n498         if len(m_wires) != len(set(m_wires)):\n\u2013> 499             raise QuantumFunctionError(\u2018Each wire in the quantum circuit can only be measured once.\u2019)\n500\n501         def check_op(op):\nQuantumFunctionError: Each wire in the quantum circuit can only be measured once.", "link": "https://discuss.pennylane.ai//t/cost-functions-multiple-wire-measurements-backends-for-hermitians/132/1"}, "1": {"author": "josh", "date": "1557984198217", "content": "\nThe Hermitian observable is not supported by the qiskit.basicaer backend. Do you know what might be a good replacement? I was hoping to use the noise functionality of the qiskit simulator.\n\nWe are currently in the process of refactoring the Qiskit plugin, due to the recent release of Qiskit v0.9 and 0.10 this week, so this is definitely on the list of features we will be adding!\nIn the meantime, you could check out the PennyLane-Forest 2 plugin, which also allows qubit simulations with noise, and supports all core PennyLane expectation values.\nNote that the Forest plugin currently must be installed by cloning from the GitHub repository directly:\ngit clone https://github.com/rigetti/pennylane-forest.git\ncd pennylane-forest\npip install -e .\n\n\n\nIf inside the qnode you perform the \\langle z_1\\rangle and  \\langle z_1z_2\\rangle computations the error returned is\nQuantumFunctionError: Each wire in the quantum circuit can only be measured once.\n\nDoes this mean that we can\u2019t compute both \\langle z_1\\rangle and  \\langle z_1z_2\\rangle?\n\nYes - you cannot compute both \\langle z_1\\rangle and  \\langle z_1z_2\\rangle from within the same QNode. The reason for this is that hardware is a first-class citizen in PennyLane \u2014 and since measurement affects the state of a qubit in hardware, it cannot be measured twice at the end of a computation.\nOne way around this is to define two QNodes, that both use the same ansatz, but with different measurements:\ndef ansatz(params):\n  for i in range(N):\n    qml.Hadamard(wires=i) \n  \n  gamma = params[0]\n  beta = params[1]\n  separator(gamma, problem)\n  mixer(beta)\n\n@qml.qnode(dev)\ndef qaoa_one_qubit(params):\n  ansatz(params)\n  return [qml.expval.PauliZ(i) for i in range(N)]\n\n@qml.qnode(dev)\ndef qaoa_two_qubit(params):\n  ansatz(params)\n  wires =[[abs(a)-1, abs(b)-1] for a, b in problem]\n  return [qml.expval.Hermitian(zz_observable, wires=w) for w in wires]\n\nYou can then sum the results from the two QNodes using a classical cost function:\ndef cost(params):\n  one_qubit_sum = np.sum(qaoa_one_qubit(params))\n  two_qubit_sum = np.sum(qaoa_two_qubit(params))\n  return one_qubit_sum + two_qubit_sum \n\n\nHope that helps! Let me know if you have any other questions.1", "link": "https://discuss.pennylane.ai//t/cost-functions-multiple-wire-measurements-backends-for-hermitians/132/2"}, "2": {"author": "mxn.wls", "date": "1558035448461", "content": "Hey Josh, thanks for the good info & the ansatz tip.\nDoes the pennylane-forest plugin support >1 qubit Hermitian observables?\nIf no, is there a plugin that supports >1 qubit Hermitian observables and noisy simulation?\nThe pennylane-forest plugin is now complaining about a \u20182x2 matrix required\u2019. Code + Error below. I think this is the limitation on zz observables, but I have installed the master branch of pennylane which accepts >2d Hermitians. This is still related to \u2018backends for Hermitians\u2019 but I can open a new topic if you prefer.\nPENNYLANE VERSION\nimport pennylane\npennylane.version\n\u20180.3.1\u2019\nCODE\ndev = qml.device(\u2018forest.numpy_wavefunction\u2019, wires=N)\nzz_observable = (1/2)*np.array([[1,0,0,0],[0,-1,0,0],[0,0,-1,0],[0,0,0,1]])\nQAOA phases\ndef mixer(beta):\nfor q in range(N): qml.RX(beta, wires=q)\nreturn None\ndef separator(gamma, problem):\nfor term in problem:\nsa, a, sb, b = sign_qubit(term)\nqml.RZ(sa * gamma, wires=a)\nqml.RZ(sb * gamma, wires=b)\n## ZZ operation\nqml.CNOT(wires=[a, b])\nqml.RZ(sb * gamma * 2., wires=b)\nqml.CNOT(wires=[a, b])\nreturn None\ndef ansatz(params):\nfor i in range(N):\nqml.Hadamard(wires=i)\ngamma = params[0]\nbeta = params[1]\nseparator(gamma, problem)\nmixer(beta)\n\n@qml.qnode(dev)\ndef qaoa_one_qubit(params):\nansatz(params)\nreturn [qml.expval.PauliZ(i) for i in range(N)]\n@qml.qnode(dev)\ndef qaoa_two_qubit(params):\nansatz(params)\nwires =[[abs(a)-1, abs(b)-1] for a, b in problem]\nreturn [qml.expval.Hermitian(zz_observable, wires=w) for w in wires]\ninitialise the optimizer\nopt = qml.GradientDescentOptimizer(stepsize=0.01)\ndef cost(params):\nreturn np.sum(qaoa_two_qubit(params)) #+ np.sum(qaoa_two_qubit(params))\nset the number of steps\nsteps = 10000\nset the initial parameter values\nparams = np.array([0.01, 0.01])\nfor i in range(steps):\n# update the circuit parameters\nparams = opt.step(cost, params)\nif (i+1) % 5 == 0:\n    print('Cost after step {:5d}: {: .7f}'.format(i+1, cost(params)))\n\nprint(\u2018Optimized rotation angles: {}\u2019.format(params))\nERROR\nValueError                                Traceback (most recent call last)\n in \n56 for i in range(steps):\n57     # update the circuit parameters\n\u2014> 58     params = opt.step(cost, params)\n59\n60     if (i+1) % 5 == 0:\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/optimize/gradient_descent.py in step(self, objective_fn, x, grad_fn)\n61         \u201c\u201d\"\n62\n\u2014> 63         g = self.compute_grad(objective_fn, x, grad_fn=grad_fn)\n64\n65         x_out = self.apply_grad(g, x)\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/optimize/gradient_descent.py in compute_grad(objective_fn, x, grad_fn)\n85         else:\n86             # default is autograd\n\u2014> 87             g = autograd.grad(objective_fn)(x)  # pylint: disable=no-value-for-parameter\n88         return g\n89\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/wrap_util.py in nary_f(*args, **kwargs)\n18             else:\n19                 x = tuple(args[i] for i in argnum)\n\u2014> 20             return unary_operator(unary_f, x, *nary_op_args, **nary_op_kwargs)\n21         return nary_f\n22     return nary_operator\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/differential_operators.py in grad(fun, x)\n22     arguments as fun, but returns the gradient instead. The function fun\n23     should be scalar-valued. The gradient has the same type as the argument.\"\"\"\n\u2014> 24     vjp, ans = _make_vjp(fun, x)\n25     if not vspace(ans).size == 1:\n26         raise TypeError(\"Grad only applies to real scalar-output functions. \"\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/core.py in make_vjp(fun, x)\n8 def make_vjp(fun, x):\n9     start_node = VJPNode.new_root(x)\n\u2014> 10     end_value, end_node =  trace(start_node, fun, x)\n11     if end_node is None:\n12         def vjp(g): return vspace(x).zeros()\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/tracer.py in trace(start_node, fun, x)\n8     with trace_stack.new_trace() as t:\n9         start_box = new_box(x, t, start_node)\n\u2014> 10         end_box = fun(start_box)\n11         if isbox(end_box) and end_box._trace == start_box._trace:\n12             return end_box._value, end_box._node\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/wrap_util.py in unary_f(x)\n13                 else:\n14                     subargs = subvals(args, zip(argnum, x))\n\u2014> 15                 return fun(*subargs, **kwargs)\n16             if isinstance(argnum, int):\n17                 x = args[argnum]\n in cost(params)\n47\n48 def cost(params):\n\u2014> 49     return np.sum(qaoa_two_qubit(params)) #+ np.sum(qaoa_two_qubit(params))\n50\n51 # set the number of steps\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/decorator.py in wrapper(*args, **kwargs)\n151         def wrapper(*args, **kwargs):\n152             \u201c\u201d\u201cWrapper function\u201d\"\"\n\u2013> 153             return qnode(*args, **kwargs)\n154\n155         # bind the jacobian method to the wrapped function\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/qnode.py in call(self, *args, **kwargs)\n455         # pylint: disable=no-member\n456         args = autograd.builtins.tuple(args)  # prevents autograd boxed arguments from going through to evaluate\n\u2013> 457         return self.evaluate(args, **kwargs)  # args as one tuple\n458\n459     @ae.primitive\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/tracer.py in f_wrapped(*args, **kwargs)\n42             parents = tuple(box._node for _     , box in boxed_args)\n43             argnums = tuple(argnum    for argnum, _   in boxed_args)\n\u2014> 44             ans = f_wrapped(*argvals, **kwargs)\n45             node = node_constructor(ans, f_wrapped, argvals, kwargs, argnums, parents)\n46             return new_box(ans, trace, node)\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/tracer.py in f_wrapped(*args, **kwargs)\n46             return new_box(ans, trace, node)\n47         else:\n\u2014> 48             return f_raw(*args, **kwargs)\n49     f_wrapped.fun = f_raw\n50     f_wrapped._is_autograd_primitive = True\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/qnode.py in evaluate(self, args, **kwargs)\n510             check_op(op)\n511\n\u2013> 512         ret = self.device.execute(self.queue, self.ev)\n513         return self.output_type(ret)\n514\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/_device.py in execute(self, queue, expectation)\n210\n211             self.pre_expval()\n\u2013> 212             expectations = [self.expval(e.name, e.wires, e.parameters) for e in expectation]\n213             self.post_expval()\n214\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/_device.py in (.0)\n210\n211             self.pre_expval()\n\u2013> 212             expectations = [self.expval(e.name, e.wires, e.parameters) for e in expectation]\n213             self.post_expval()\n214\n~/projects/vqa_optimisation/qiskit_pennylane/packages/pennylane-forest/pennylane-forest/pennylane_forest/numpy_wavefunction.py in expval(self, expectation, wires, par)\n69         if self.shots == 0:\n70             # exact expectation value\n\u2014> 71             ev = self.ev(A, wires)\n72         else:\n73             # estimate the ev\n~/projects/vqa_optimisation/qiskit_pennylane/packages/pennylane-forest/pennylane-forest/pennylane_forest/numpy_wavefunction.py in ev(self, A, wires)\n91         \u201c\u201d\"\n92         # Expand the Hermitian observable over the entire subsystem\n\u2014> 93         A = self.expand_one(A, wires)\n94         return np.vdot(self.state, A @ self.state).real\n95\n~/projects/vqa_optimisation/qiskit_pennylane/packages/pennylane-forest/pennylane-forest/pennylane_forest/numpy_wavefunction.py in expand_one(self, U, wires)\n105         \u201c\u201d\"\n106         if U.shape != (2, 2):\n\u2013> 107             raise ValueError(\u20182x2 matrix required.\u2019)\n108         if len(wires) != 1:\n109             raise ValueError(\u2018One target subsystem required.\u2019)\nValueError: 2x2 matrix required.1", "link": "https://discuss.pennylane.ai//t/cost-functions-multiple-wire-measurements-backends-for-hermitians/132/3"}, "3": {"author": "josh", "date": "1558208251537", "content": "Hi @mxn.wls, thanks for pointing this out.\nSince the multi-wire qml.expval.Hermitian support was only added to the main PennyLane library last week, we still need to add support to the plugins.\nI have just submitted a PR which adds this to the PennyLane-Forest plugin, see here: https://github.com/rigetti/pennylane-forest/pull/13 1\nUntil it is merged, you can clone and install this branch directly to get it working:\ngit clone https://github.com/rigetti/pennylane-forest.git\ncd pennylane-forest\ngit checkout multi_qubit_observables\npip install -e .\n1", "link": "https://discuss.pennylane.ai//t/cost-functions-multiple-wire-measurements-backends-for-hermitians/132/4"}, "4": {"author": "mxn.wls", "date": "1558632535792", "content": "Back to this problem though with a slightly different tack:\n\nHow does the runtime scale with multiple calls to the circuit in order to find multiple wire measurements of the same qubit? Is is linear i.e. every circuit call is x time so if I run two circuits to measure the same qubit twice the runtime is 2x? Example below.\n\nCode\nimport pennylane as qml\nfrom pennylane import numpy as np\nN = 4\nn_clauses = 3\ndev = qml.device(\u2018forest.numpy_wavefunction\u2019, wires=N)\nzz_observable = np.array([[1,0,0,0],[0,-1,0,0],[0,0,-1,0],[0,0,0,1]])\n@qml.qnode(dev)\ndef qaoa_two_qubit(params, problem_arg=None):\nreturn [qml.expval.Hermitian(zz_observable, wires=w) for w in problem_arg]\nproblem = [[1,2],[2,3]]\ndef cost(params):\ntwo_qubit_exp = qaoa_two_qubit(params, problem_arg=problem)\nreturn np.sum(two_qubit_exp)\nopt = qml.GradientDescentOptimizer(stepsize=0.01)\nsteps = 1000\nparams = np.random.uniform(0, np.pi*2., 2)\nfor i in range(steps):\nparams = opt.step(cost, params)\nError\nQuantumFunctionError: Each wire in the quantum circuit can only be measured once.\n(As expected, can\u2019t measure qubit 2 in 2 different measurements)\nSolution multiple calls to the circuit\nimport pennylane as qml\nfrom pennylane import numpy as np\nN = 4\nn_clauses = 3\ndev = qml.device(\u2018forest.numpy_wavefunction\u2019, wires=N)\nzz_observable = np.array([[1,0,0,0],[0,-1,0,0],[0,0,-1,0],[0,0,0,1]])\n@qml.qnode(dev)\ndef qaoa_two_qubit(params, term=None):\nqml.RX(params[0], wires=term[0])\nreturn qml.expval.Hermitian(zz_observable, wires=term)\nproblem = [[1,2],[2,3]]\ndef cost(params):\ntwo_qubit_exp = [   ]\nfor term in problem:\ntwo_qubit_exp.append(qaoa_two_qubit(params, term=term))\nreturn np.sum(two_qubit_exp)\nopt = qml.GradientDescentOptimizer(stepsize=0.01)\nsteps = 1000\nparams = np.random.uniform(0, np.pi*2., 2)\nfor i in range(steps):\nparams = opt.step(cost, params)\nprint(\u2018cost: %.4f\u2019 % cost(params))\nReturns\ncost: -1.7844\ncost: -1.7925\ncost: -1.8003\ncost: -1.8078\u2026 qed\n\n\nIs there a way to get around this: If I could sample the quantum circuit irl I can make all my gradient + expectation value calculations (I think?) based on N samples. So the runtime doesn\u2019t scale with the number of same wire measurements, if I wanted to calculate  and  I don\u2019t have to run the circuit twice.\n\n\nGiven this, I\u2019d like to understand the limitation of pennylane & where that comes from, it seems to me given a bunch of samples (from one circuit run) it might be possible to calculate all the the expectation values and gradients.\n\n\nThanks!", "link": "https://discuss.pennylane.ai//t/cost-functions-multiple-wire-measurements-backends-for-hermitians/132/5"}, "5": {"author": "nathan", "date": "1558645922976", "content": "Hi mxn.wls,\n\n\nYes, the runtime scales linearly. If you want to evaluate the same circuit, but with a different final measurement setting, the entire circuit is reevaluated. This is because PennyLane is hardware-based, and this is a constraint you have on real hardware. Saying this, we do realize that there are efficiency gains that could be had using simulators, e.g., caching the state right before measurement and re-using that.\n\n\nNot sure I follow here, unfortunately, but I\u2019ll give a shot to answering. Say we want to estimate quantities (expectation values, gradients, etc.) with 1000 samples. How many circuit evaluations are needed for different goals?\n\n\n\nEstimating an expectation value: 1000 circuit evaluations.\nEstimating a different expectation value on the same wire whose measurement operator is linearly independent from other ones you have already measured: also 1000 evaluations.\nEstimating a different expectation value on the same wire whose measurement operator is linearly dependent from other ones you have already measured: 0 evaluations\nEstimating gradients with respect to a single parameter: 2000 evaluations\nThere are tricks and shortcuts you can leverage when working with simulator, but these are not directly built into PennyLane\n\n\nThe limitations are physical: Estimating one expectation value does not tell me anything about another expectation value which is linearly independent from it; also, using the \u201cparameter-shift\u201d gradient rule, which is compatible/scalable with hardware, requires evaluation of two expectation values (at shifted parameters)\n\nEven with all the above, we are thinking about other ways we can make things more efficient if the user is not using physical hardware, and may implement these in the future.2", "link": "https://discuss.pennylane.ai//t/cost-functions-multiple-wire-measurements-backends-for-hermitians/132/6"}, "6": {"author": "mxn.wls", "date": "1560208955446", "content": "Hey,\nThere is an issue with calling the same qnode multiple times with different wire measurements.\nWhat we need\n\nMeasure expectation values <z1 z2> <z3 z4> and <z2 z3>\n\nDue to constraint of only measuring a qubit once, must use the same circuit twice.\nIf we try to do this, it throws up errors. I believe this is to do with the circuit initialization. So the question is: How do I measure multiple expectations without hardcoding a second circuit? (Needs to be able to be done iteratively dependent on the number of \u2018collisions\u2019 between variables in the cost function.)\nHere\u2019s some examples.\ncall_1() seems to be that the circuit only measures the first expectation value of the second problem\ncall_2() doesn\u2019't seem to have a second index to call (because it was initialized with 2 expectation value calls in this case) so crashed\u2026\n import pennylane as qml\n from pennylane import numpy as np\n\nN = 4\ndev = qml.device('forest.numpy_wavefunction', wires=N)\nzz_observable = np.array([[1., 0., 0., 0.], [0., -1., 0., 0.], [0., 0., -1., 0.], [0., 0., 0., 1.]])\n\n@qml.qnode(dev)\ndef c1(wires_arg=None):\n    return [qml.expval.Hermitian(zz_observable, wires=w) for w in wires_arg]\n\ndef call_1():\n    problem = {}\n    problem[0] = [[0,1]]\n    problem[1] = [[0,1],[2,3]]\n\n    for group, measurements in problem.items():\n        tmp = c1(wires_arg=measurements)\n        print('Problem: ', measurements, 'Expectations: ', tmp)\n    return\n\ncall_1()\n\n@qml.qnode(dev) # new circuit\ndef c2(wires_arg=None):\n    return [qml.expval.Hermitian(zz_observable, wires=w) for w in wires_arg]\n\ndef call_2():\n    problem = {}\n    problem[0] = [[0, 1], [2, 3]]\n    problem[1] = [[0,1]]\n\n    for group, measurements in problem.items():\n        tmp = c2(wires_arg=measurements)\n        print('Problem: ', measurements, 'Expectations: ', tmp)\n    return\n\ncall_2()\n\nOutput\nProblem:  [[0, 1]] Expectations:  [1.]\nProblem:  [[0, 1], [2, 3]] Expectations:  [1.]\nProblem:  [[0, 1], [2, 3]] Expectations:  [1. 1.]\nTraceback (most recent call last):\nFile \u201c/home/maxiwelian/projects/vqa_optimisation/comparison/faulty_hermitian_demo.py\u201d, line 38, in \ncall_2()\nFile \u201c/home/maxiwelian/projects/vqa_optimisation/comparison/faulty_hermitian_demo.py\u201d, line 34, in call_2\ntmp = c2(wires_arg=measurements)\nFile \u201c/home/maxiwelian/anaconda3/envs/aqua/lib/python3.7/site-packages/PennyLane-0.3.1-py3.7.egg/pennylane/decorator.py\u201d, line 153, in wrapper\ntry:\nFile \u201c/home/maxiwelian/anaconda3/envs/aqua/lib/python3.7/site-packages/PennyLane-0.3.1-py3.7.egg/pennylane/qnode.py\u201d, line 461, in call\nFile \u201c/home/maxiwelian/anaconda3/envs/aqua/lib/python3.7/site-packages/autograd-1.2-py3.7.egg/autograd/tracer.py\u201d, line 48, in f_wrapped\nreturn f_raw(*args, **kwargs)\nFile \u201c/home/maxiwelian/anaconda3/envs/aqua/lib/python3.7/site-packages/PennyLane-0.3.1-py3.7.egg/pennylane/qnode.py\u201d, line 501, in evaluate\nFile \u201c/home/maxiwelian/anaconda3/envs/aqua/lib/python3.7/site-packages/PennyLane-0.3.1-py3.7.egg/pennylane/qnode.py\u201d, line 501, in \nFile \u201c/home/maxiwelian/anaconda3/envs/aqua/lib/python3.7/site-packages/PennyLane-0.3.1-py3.7.egg/pennylane/operation.py\u201d, line 374, in wires\nFile \u201c/home/maxiwelian/anaconda3/envs/aqua/lib/python3.7/site-packages/PennyLane-0.3.1-py3.7.egg/pennylane/operation.py\u201d, line 374, in \nFile \u201c/home/maxiwelian/anaconda3/envs/aqua/lib/python3.7/site-packages/PennyLane-0.3.1-py3.7.egg/pennylane/variable.py\u201d, line 147, in val\nIndexError: index 2 is out of bounds for axis 0 with size 2", "link": "https://discuss.pennylane.ai//t/cost-functions-multiple-wire-measurements-backends-for-hermitians/132/7"}, "7": {"author": "josh", "date": "1560222437557", "content": "Hi @mxn.wls, this is something I\u2019ve been working on fixing \nYou\u2019re assessment is spot on \u2014 currently, the QNode caches the quantum circuit on the first evaluation, and uses this cached circuit from then on (to save time/memory).\nI\u2019ve created a new PR here 2 on the PennyLane GitHub that alters this behaviour, and allows you to specify that the QNode should re-evaluate the function and re-construct the circuit on every execution.\nTo install this PR, follow these steps:\ngit clone https://github.com/XanaduAI/pennylane.git\ncd pennylane && git checkout variables_during_construction\npip install -e .\n\nOnce it\u2019s installed, all you need to do is call the function qml.eager_mode() after importing PennyLane:\nimport pennylane as qml\nfrom pennylane import numpy as np\n\nqml.eager_mode()\n\nand then continue with your existing script as is. I just verified that it works, giving the output\nProblem:  [[0, 1]] Expectations:  [1.]\nProblem:  [[0, 1], [2, 3]] Expectations:  [1. 1.]\nProblem:  [[0, 1], [2, 3]] Expectations:  [1. 1.]\nProblem:  [[0, 1]] Expectations:  [1.]\n\n\nNote: This PR is still going through review, and the name of the function is subject to change once it is merged in to the latest release!\nHope that helps, let me know if you have any questions.1", "link": "https://discuss.pennylane.ai//t/cost-functions-multiple-wire-measurements-backends-for-hermitians/132/8"}, "8": {"author": "mxn.wls", "date": "1560285349543", "content": "Thanks @nathan  and @josh. Both helpful / worked.\nMax", "link": "https://discuss.pennylane.ai//t/cost-functions-multiple-wire-measurements-backends-for-hermitians/132/9"}, "9": {"author": "josh", "date": "1557984198217", "content": "\nThe Hermitian observable is not supported by the qiskit.basicaer backend. Do you know what might be a good replacement? I was hoping to use the noise functionality of the qiskit simulator.\n\nWe are currently in the process of refactoring the Qiskit plugin, due to the recent release of Qiskit v0.9 and 0.10 this week, so this is definitely on the list of features we will be adding!\nIn the meantime, you could check out the PennyLane-Forest 2 plugin, which also allows qubit simulations with noise, and supports all core PennyLane expectation values.\nNote that the Forest plugin currently must be installed by cloning from the GitHub repository directly:\ngit clone https://github.com/rigetti/pennylane-forest.git\ncd pennylane-forest\npip install -e .\n\n\n\nIf inside the qnode you perform the \\langle z_1\\rangle\u27e8z1\u27e9 and  \\langle z_1z_2\\rangle\u27e8z1z2\u27e9 computations the error returned is\nQuantumFunctionError: Each wire in the quantum circuit can only be measured once.\n\nDoes this mean that we can\u2019t compute both \\langle z_1\\rangle\u27e8z1\u27e9 and  \\langle z_1z_2\\rangle\u27e8z1z2\u27e9?\n\nYes - you cannot compute both \\langle z_1\\rangle\u27e8z1\u27e9 and  \\langle z_1z_2\\rangle\u27e8z1z2\u27e9 from within the same QNode. The reason for this is that hardware is a first-class citizen in PennyLane \u2014 and since measurement affects the state of a qubit in hardware, it cannot be measured twice at the end of a computation.\nOne way around this is to define two QNodes, that both use the same ansatz, but with different measurements:\ndef ansatz(params):\n  for i in range(N):\n    qml.Hadamard(wires=i) \n  \n  gamma = params[0]\n  beta = params[1]\n  separator(gamma, problem)\n  mixer(beta)\n\n@qml.qnode(dev)\ndef qaoa_one_qubit(params):\n  ansatz(params)\n  return [qml.expval.PauliZ(i) for i in range(N)]\n\n@qml.qnode(dev)\ndef qaoa_two_qubit(params):\n  ansatz(params)\n  wires =[[abs(a)-1, abs(b)-1] for a, b in problem]\n  return [qml.expval.Hermitian(zz_observable, wires=w) for w in wires]\n\nYou can then sum the results from the two QNodes using a classical cost function:\ndef cost(params):\n  one_qubit_sum = np.sum(qaoa_one_qubit(params))\n  two_qubit_sum = np.sum(qaoa_two_qubit(params))\n  return one_qubit_sum + two_qubit_sum \n\n\nHope that helps! Let me know if you have any other questions.1", "link": "https://discuss.pennylane.ai//t/cost-functions-multiple-wire-measurements-backends-for-hermitians/132/10"}}