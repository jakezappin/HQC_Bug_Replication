{"0": {"author": "Pranav_Chandarana", "date": "1685112543946", "content": "Hello. I wanted to try to implement the following circuit in the X8 chip. Can anyone please help me decompose the following circuit so I can implement it? Thanks in advance.\nimport numpy as np\nimport strawberryfields as sf\nfrom strawberryfields.ops import *\n\n\nfrom numpy import pi, sqrt\nimport math\nimport random\n\n\ndef U_D(l,qp,params):\n    Xgate(params[0]) | qp[0]\n    Xgate(params[1]) | qp[1]\n    Xgate(params[2]) | qp[2]\n    Xgate(params[3]) | qp[3]\n\n    \n    CZgate(params[4]) | (qp[0], qp[1])\n    CZgate(params[5]) | (qp[1], qp[2])\n    CZgate(params[6]) | (qp[2], qp[3])\n    \n    \n    return qp\n\nparamsf = [  0.67298385,   0.37791076,   0.20837424,   0.59441259,\n         0.55759042,   0.43001499,   0.52092983,   4.80069928,\n        24.24655461,   0.84556549, -6.36143337]\n\nN=4\nn_layers=1\nprog = sf.Program(N) # defining photonic quantum circuit with N subsystems (wires)\neng = sf.Engine(backend=\"fock\", backend_options={\"cutoff_dim\": 10})\nwith prog.context as q:\n     \n        for l in range(n_layers):\n            \n            U_D(l,q,paramsf)\n\n            results = eng.run(prog)\n\n\n\n Solved by isaacdevlugt in post #9 \n\n\n                Hey @Pranav_Chandarana! I just spoke with someone who is more familiar with the X series chips. \nI think the confusion comes from the documentation for X8. If you look at the allowable operations, it says that an arbitrary 4x4 unitary is allowed, but it must be built using BSgate, MZgate, Rgate and I\u2026\n              \n", "link": "https://discuss.pennylane.ai//t/decomposing-a-circuit-for-x8-chip-implementation/2976/1"}, "1": {"author": "isaacdevlugt", "date": "1685116652015", "content": "Hey @Pranav_Chandarana!\nMost gates should have a decompose method (see here 3 in the documentation). The functionality states that it will \u201cdecompose the operation into elementary operations supported by the backend API.\u201d So, when using X8 via, say, eng = RemoteEngine(\"X8\"), the decompose method should decompose any operations to the supported ones on X8. That said, some operations don\u2019t have a decomposition implemented.\nLet me know if this helps!", "link": "https://discuss.pennylane.ai//t/decomposing-a-circuit-for-x8-chip-implementation/2976/2"}, "2": {"author": "Pranav_Chandarana", "date": "1685174225061", "content": "So now I have tried this:\ndef U_D(l,qp,params):\n    \n    Xgate(params[0]).decompose(qp[0])\n    Xgate(params[1]).decompose(qp[1])\n    Xgate(params[2]).decompose(qp[2]) \n    Xgate(params[3]).decompose(qp[3])\n    \n    Xgate(params[0]).decompose(qp[4]) \n    Xgate(params[1]).decompose(qp[5])\n    Xgate(params[2]).decompose(qp[6]) \n    Xgate(params[3]).decompose(qp[7])\n\n    \n    CZgate(params[4]).decompose((qp[0], qp[1]))  \n    CZgate(params[5]).decompose((qp[1], qp[2]))  \n    CZgate(params[6]).decompose((qp[2], qp[3]))\n    \n    CZgate(params[4]).decompose((qp[4], qp[5]))  \n    CZgate(params[5]).decompose((qp[5], qp[6]))  \n    CZgate(params[6]).decompose((qp[6], qp[7]))\n    \n    \n    return qp\n\nparamsf = [  0.67298385,   0.37791076,   0.20837424,   0.59441259,\n         0.55759042,   0.43001499,   0.52092983,   4.80069928,\n        24.24655461,   0.84556549, -6.36143337]\n\nN=8\nn_layers=1\nprog = sf.Program(N) # defining photonic quantum circuit with N subsystems (wires)\neng = sf.RemoteEngine(\"X8\")\nwith prog.context as q:\n     \n        for l in range(n_layers):\n            \n            U_D(l,q,paramsf)\n            MeasureFock() | q\n\nprog_compiled = prog.compile(device=eng.device)\nprog_compiled.print()\n\nbut this gives the output\nS2gate(0, 0) | (q[0], q[4])\nS2gate(0, 0) | (q[1], q[5])\nS2gate(0, 0) | (q[2], q[6])\nS2gate(0, 0) | (q[3], q[7])\nMZgate(3.142, 0) | (q[0], q[1])\nMZgate(3.142, 0) | (q[2], q[3])\nMZgate(3.142, 0) | (q[1], q[2])\nMZgate(3.142, 0) | (q[0], q[1])\nMZgate(3.142, 0) | (q[2], q[3])\nMZgate(3.142, 0) | (q[1], q[2])\nRgate(0) | (q[0])\nRgate(0) | (q[1])\nRgate(0) | (q[2])\nRgate(0) | (q[3])\nMZgate(3.142, 0) | (q[4], q[5])\nMZgate(3.142, 0) | (q[6], q[7])\nMZgate(3.142, 0) | (q[5], q[6])\nMZgate(3.142, 0) | (q[4], q[5])\nMZgate(3.142, 0) | (q[6], q[7])\nMZgate(3.142, 0) | (q[5], q[6])\nRgate(0) | (q[4])\nRgate(0) | (q[5])\nRgate(0) | (q[6])\nRgate(0) | (q[7])\nMeasureFock | (q[0], q[1], q[2], q[3], q[4], q[5], q[6], q[7])\n\n\nAnd when I perform the same circuit with the local fock backend, it doesn\u2019t give any circuit. I don\u2019t know if that\u2019s the problem with my code or anything else. Coul you please send me a snippet of the code that works? That would be a huge help.", "link": "https://discuss.pennylane.ai//t/decomposing-a-circuit-for-x8-chip-implementation/2976/3"}, "3": {"author": "isaacdevlugt", "date": "1685369769122", "content": "Ah, nice! compile is probably a better option compared to decompose in this case.\n\nAnd when I perform the same circuit with the local fock backend, it doesn\u2019t give any circuit.\n\nIf I use your code and simply add this at the end, it works for me.\neng = sf.Engine('fock', backend_options={\"cutoff_dim\": 2})\nresults = eng.run(prog_compiled)\nprint(results.samples)\n", "link": "https://discuss.pennylane.ai//t/decomposing-a-circuit-for-x8-chip-implementation/2976/4"}, "4": {"author": "Pranav_Chandarana", "date": "1685371104685", "content": "This would work I think but the decompositions are not correct. just try\nprog.print()\n\nIt would return just\nMeasureFock | (q[0], q[1], q[2], q[3], q[4], q[5], q[6], q[7])\n\nSo, any of the gates are not applying to the X8 device. It is just Measurements to the initial vacuum state. Please correct me if I am wrong at any point. This is what is happening in my code.", "link": "https://discuss.pennylane.ai//t/decomposing-a-circuit-for-x8-chip-implementation/2976/5"}, "5": {"author": "isaacdevlugt", "date": "1685373144175", "content": "So prog isn\u2019t the thing you actually care about here. prog_compiled is the object that you want to run on X8, so if you look at prog_compiled.print() it shows the proper gates . Then you want to run that program via results = eng.run(prog_compiled).", "link": "https://discuss.pennylane.ai//t/decomposing-a-circuit-for-x8-chip-implementation/2976/6"}, "6": {"author": "Pranav_Chandarana", "date": "1685380468032", "content": "Thanks for the clarification. I tried that and found out the quad_exp value by\n[results.state.quad_expectation(i)[0] for i in range(N)]\n\nand its showing\n[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n\nwhich is not the expected solution. Also,  even if we change the \u201cparamsf\u201d values, the circuit output is the same independent of the value of the parameters. Could you please check if that is the case for your code as well? If yes then, there is some error in the code somehow right? Thanks for the time!", "link": "https://discuss.pennylane.ai//t/decomposing-a-circuit-for-x8-chip-implementation/2976/7"}, "7": {"author": "isaacdevlugt", "date": "1685463104623", "content": "Hey @Pranav_Chandarana, I just need to consult one of my colleagues and I\u2019ll get back to you shortly!", "link": "https://discuss.pennylane.ai//t/decomposing-a-circuit-for-x8-chip-implementation/2976/8"}, "8": {"author": "isaacdevlugt", "date": "1685633974056", "content": "Hey @Pranav_Chandarana! I just spoke with someone who is more familiar with the X series chips.\nI think the confusion comes from the documentation for X8. If you look at the allowable operations, it says that an arbitrary 4x4 unitary is allowed, but it must be built using BSgate, MZgate, Rgate and Interferometer. That might make it seem like any unitary (including CZgate) is allowable, but the qualifier \u201c4x4\u201d means the unitary is at the level of the mode transformations (i.e. how they transform the raising and lowering operators) \u2014 not the Hilbert space. Indeed, CZgates are unitary at the level of the Hilbert space, but if you look at their transformation on the raising and lowering operators, it is not a unitary. Only linear optical transformations (i.e. BSgate, MZgate, Rgate and Interferometer) are unitary at the level of the mode transformations.\nSince you have no gates that are acceptable, it just ended compiling a default circuit that seems to consist of all the squeezers being off and the interferometer not interacting any of the modes. So your circuit can\u2019t be programmed on X8.Solution1", "link": "https://discuss.pennylane.ai//t/decomposing-a-circuit-for-x8-chip-implementation/2976/9"}}