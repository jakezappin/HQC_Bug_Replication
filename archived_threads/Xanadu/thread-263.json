{"0": {"author": "RX1", "date": "1696667499049", "content": "https://docs.pennylane.ai/en/stable/code/api/pennylane.DiagonalQubitUnitary.html 1\nWhile checking the documentation, I found that DiagonalQubitUnitary doesn\u2019t even have a gradient recipe? How can I make a custom Unitary matrix with variable parameters for training?\ndef my_func(feat, para):\n    qml.MottonenStatePreparation(state_vector=feat, wires=wires)\n    diag = []\n    for i in range(dim1):\n        diag.append(np.sign(para[i]))\n    #print(len(diag))\n    diag = np.array(diag, requires_grad=True)\n    print(diag)\n    qml.DiagonalQubitUnitary(diag, wires=wires)\n    return qml.eval...\n\n\nThe above image is part of my code. I set dim1 a classical parameter (in the hope that it will be trained). By determining the positives and negatives of the parameters, thus forming the diagonal unitary matrix I want. But in training, I found that the dim1 parameter is not iteratively updated. I don\u2019t know if it\u2019s because qml.DiagonalQubitUnitary is not differentiable or my parameters are not updated by the optimizer. This one phenomenon induced me to think how for a quantum-classical hybrid algorithm, where some of the parameters are not embedded in quantum gates, is it also possible to train it?\n\nA key question, on hardware, how to decompose a custom diagonal unitary containing parameters into basic gatesets and participate in machine learning training.\nIn fact, I really need a trainable custom diag unitary matrix like this:\n\nwhich is trainable into another diag unitary matrix.\nTotally, how to let qml.DiagonalQubitUnitary and qml.QubitUnitary be trainable?\n@isaacdevlugt @Maria_Schuld @CatalinaAlbornoz @Guillermo_Alonso @Diego @kevinkawchak\n\n\n Solved by Guillermo_Alonso in post #7 \n\n\n                Unfortunately there is no continuous way to do what you propose. You are going to have to go through the complex numbers. Maybe you can add another error function that encourages the parameters to converge to 0 or \\pi (-1 and 1).\n              \n", "link": "https://discuss.pennylane.ai//t/qml-diagonalqubitunitary-and-qml-qubitunitary-cannot-be-trained/3521/1"}, "1": {"author": "Guillermo_Alonso", "date": "1696940956373", "content": "Hi @RX1 !\nIndeed, DiagonalQubitUnitary has differentiability problems since it is working with complex numbers on the diagonal. What you want from what I understand is that it is both trainable and differentiable. Therefore your function has to be continuous and you need to encode a diagonal matrix with elements of the form e^{i \\theta}. This can be achieved by putting anstazs where the gates are RZs, CRZs, CCRZs and so on. (You can test using qml.matrix to see that it is indeed diagonal.)\nI hope that helps!", "link": "https://discuss.pennylane.ai//t/qml-diagonalqubitunitary-and-qml-qubitunitary-cannot-be-trained/3521/2"}, "2": {"author": "RX1", "date": "1696950179885", "content": "This additionally increases the complexity of the algorithm I designed if it follows the diagonal matrix decomposition into the form of a quantum gate. Since the diagonal elements in the diagonal matrix will change with training, the decomposition will also change, and it is impossible for me to list thousands of categorization scenarios, so please ask if there is an automatic decomposition. I think the issue I raised is an important one that Pennylane needs to be updated in a timely manner.", "link": "https://discuss.pennylane.ai//t/qml-diagonalqubitunitary-and-qml-qubitunitary-cannot-be-trained/3521/3"}, "3": {"author": "Guillermo_Alonso", "date": "1696954637196", "content": "If you use RZs and CRZs, the decomposition will not change. It is a way to create continuity between the different oracles ", "link": "https://discuss.pennylane.ai//t/qml-diagonalqubitunitary-and-qml-qubitunitary-cannot-be-trained/3521/4"}, "4": {"author": "Guillermo_Alonso", "date": "1696977514674", "content": "Hi @RX1 !  I\u2019ve been talking with my colleague Tom and what you propose is differentiable if you use jax, here is an example:\nimport pennylane as qml\nfrom jax import numpy as np\nimport jax\n\ndev = qml.device(\"default.qubit\", wires=1)\n\n@qml.qnode(dev)\ndef f(x):\n    qml.Hadamard(0)\n    qml.DiagonalQubitUnitary(qml.math.exp(1j * x), wires=range(1))\n    return qml.expval(qml.PauliX(0))\n\nx = np.array([3., 9.])\n\njax.grad(f)(x)\n\nDoes this solve your problem?", "link": "https://discuss.pennylane.ai//t/qml-diagonalqubitunitary-and-qml-qubitunitary-cannot-be-trained/3521/5"}, "5": {"author": "RX1", "date": "1697002472280", "content": "My algorithm can only make the elements of this unitary diagonal matrix to be 1 or -1, no other complex numbers can occur, it is discrete in terms of the result and continuous in terms of the training parameters. Is this achievable?", "link": "https://discuss.pennylane.ai//t/qml-diagonalqubitunitary-and-qml-qubitunitary-cannot-be-trained/3521/6"}, "6": {"author": "Guillermo_Alonso", "date": "1697026628961", "content": "Unfortunately there is no continuous way to do what you propose. You are going to have to go through the complex numbers. Maybe you can add another error function that encourages the parameters to converge to 0 or \\pi (-1 and 1).Solution", "link": "https://discuss.pennylane.ai//t/qml-diagonalqubitunitary-and-qml-qubitunitary-cannot-be-trained/3521/7"}, "7": {"author": "RX1", "date": "1696667499049", "content": "https://docs.pennylane.ai/en/stable/code/api/pennylane.DiagonalQubitUnitary.html 1\nWhile checking the documentation, I found that DiagonalQubitUnitary doesn\u2019t even have a gradient recipe? How can I make a custom Unitary matrix with variable parameters for training?\ndef my_func(feat, para):\n    qml.MottonenStatePreparation(state_vector=feat, wires=wires)\n    diag = []\n    for i in range(dim1):\n        diag.append(np.sign(para[i]))\n    #print(len(diag))\n    diag = np.array(diag, requires_grad=True)\n    print(diag)\n    qml.DiagonalQubitUnitary(diag, wires=wires)\n    return qml.eval...\n\n\nThe above image is part of my code. I set dim1 a classical parameter (in the hope that it will be trained). By determining the positives and negatives of the parameters, thus forming the diagonal unitary matrix I want. But in training, I found that the dim1 parameter is not iteratively updated. I don\u2019t know if it\u2019s because qml.DiagonalQubitUnitary is not differentiable or my parameters are not updated by the optimizer. This one phenomenon induced me to think how for a quantum-classical hybrid algorithm, where some of the parameters are not embedded in quantum gates, is it also possible to train it?\n\nA key question, on hardware, how to decompose a custom diagonal unitary containing parameters into basic gatesets and participate in machine learning training.\nIn fact, I really need a trainable custom diag unitary matrix like this:\n\nwhich is trainable into another diag unitary matrix.\nTotally, how to let qml.DiagonalQubitUnitary and qml.QubitUnitary be trainable?\n@isaacdevlugt @Maria_Schuld @CatalinaAlbornoz @Guillermo_Alonso @Diego @kevinkawchak\n\n\n Solved by Guillermo_Alonso in post #7 \n\n\n                Unfortunately there is no continuous way to do what you propose. You are going to have to go through the complex numbers. Maybe you can add another error function that encourages the parameters to converge to 0 or \\pi (-1 and 1).\n              \n", "link": "https://discuss.pennylane.ai//t/qml-diagonalqubitunitary-and-qml-qubitunitary-cannot-be-trained/3521/8"}, "8": {"author": "Guillermo_Alonso", "date": "1696940956373", "content": "Hi @RX1 !\nIndeed, DiagonalQubitUnitary has differentiability problems since it is working with complex numbers on the diagonal. What you want from what I understand is that it is both trainable and differentiable. Therefore your function has to be continuous and you need to encode a diagonal matrix with elements of the form e^{i \\theta}ei\u03b8. This can be achieved by putting anstazs where the gates are RZs, CRZs, CCRZs and so on. (You can test using qml.matrix to see that it is indeed diagonal.)\nI hope that helps!", "link": "https://discuss.pennylane.ai//t/qml-diagonalqubitunitary-and-qml-qubitunitary-cannot-be-trained/3521/9"}, "9": {"author": "Guillermo_Alonso", "date": "1697026628961", "content": "Unfortunately there is no continuous way to do what you propose. You are going to have to go through the complex numbers. Maybe you can add another error function that encourages the parameters to converge to 0 or \\pi\u03c0 (-1 and 1).Solution", "link": "https://discuss.pennylane.ai//t/qml-diagonalqubitunitary-and-qml-qubitunitary-cannot-be-trained/3521/10"}}