{"0": {"author": "shrug001", "date": "1696286594057", "content": "Hi, I tried running the code from this video 1. When I tried to run it on a IBM device it gave me an error. The error seems to be because of the controlled Z gate that the program uses. It works fine on the pennylane simulator but when I try to use the qiskit one it breaks. Could use some help debugging.\n# Put code here\n\nimport pennylane as qml\nfrom pennylane import numpy as np\n\nproperty_prices = [4, 8, 6, 3, 12, 15] # total 48 \nvariables_wires = [0, 1, 2, 3, 4, 5]\n\naux_oracle_wires = [6, 7, 8 ,9 ,10, 11]\n\ndef oracle(variables_wires, aux_oracle_wires):\n    \n    def add_k_fourier(k, wires):\n        for j in range(len(wires)):\n            qml.RZ(k * np.pi / (2**j), wires=wires[j])\n            \n    def value_second_sibling():\n        \n        qml.QFT(wires = aux_oracle_wires)\n        \n        for wire in variables_wires:\n            qml.ctrl(add_k_fourier, control = wire)(property_prices[wire], wires = aux_oracle_wires)\n            \n        qml.adjoint(qml.QFT)(wires = aux_oracle_wires)\n        \n    value_second_sibling()\n    qml.FlipSign(sum(property_prices) // 2, wires = aux_oracle_wires)\n    qml.adjoint(value_second_sibling)()\n\ndev = qml.device('qiskit.ibmq', wires=12, backend='ibmq_qasm_simulator')\n\n@qml.qnode(dev)\ndef circuit():\n    \n    # step 1\n    for wire in variables_wires:\n        qml.Hadamard(wires = wire)\n       \n    # step 2\n    oracle(variables_wires, aux_oracle_wires)\n    \n    # step 3\n    qml.GroverOperator(wires = variables_wires)\n    \n    return qml.probs(wires = variables_wires)\n\n\nimport matplotlib.pyplot as plt\n\nvalues = circuit()\nplt.bar(range(len(values)), values)\n\nIf you want help with diagnosing an error, please put the full error message below:\n# Put full error message here\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[5], line 3\n      1 import matplotlib.pyplot as plt\n----> 3 values = circuit()\n      4 plt.bar(range(len(values)), values)\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\qnode.py:989, in QNode.__call__(self, *args, **kwargs)\n    986     self.execute_kwargs.pop(\"mode\")\n    988 # pylint: disable=unexpected-keyword-arg\n--> 989 res = qml.execute(\n    990     (self._tape,),\n    991     device=self.device,\n    992     gradient_fn=self.gradient_fn,\n    993     interface=self.interface,\n    994     transform_program=self.transform_program,\n    995     gradient_kwargs=self.gradient_kwargs,\n    996     override_shots=override_shots,\n    997     **self.execute_kwargs,\n    998 )\n   1000 res = res[0]\n   1002 # convert result to the interface in case the qfunc has no parameters\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\interfaces\\execution.py:757, in execute(tapes, device, gradient_fn, interface, transform_program, grad_on_execution, gradient_kwargs, cache, cachesize, max_diff, override_shots, expand_fn, max_expansion, device_batch_transform)\n    754     raise ValueError(\"Gradient transforms cannot be used with grad_on_execution=True\")\n    756 ml_boundary_execute = _get_ml_boundary_execute(interface, _grad_on_execution)\n--> 757 results = ml_boundary_execute(\n    758     tapes, device, execute_fn, gradient_fn, gradient_kwargs, _n=1, max_diff=max_diff\n    759 )\n    761 results = batch_fn(results)\n    762 return program_post_processing(results)\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\interfaces\\autograd.py:317, in execute(tapes, device, execute_fn, gradient_fn, gradient_kwargs, _n, max_diff)\n    312 # pylint misidentifies autograd.builtins as a dict\n    313 # pylint: disable=no-member\n    314 parameters = autograd.builtins.tuple(\n    315     [autograd.builtins.list(t.get_parameters()) for t in tapes]\n    316 )\n--> 317 return _execute(\n    318     parameters,\n    319     tapes=tapes,\n    320     device=device,\n    321     execute_fn=execute_fn,\n    322     gradient_fn=gradient_fn,\n    323     gradient_kwargs=gradient_kwargs,\n    324     _n=_n,\n    325     max_diff=max_diff,\n    326 )[0]\n\nFile ~\\anaconda3\\Lib\\site-packages\\autograd\\tracer.py:48, in primitive.<locals>.f_wrapped(*args, **kwargs)\n     46     return new_box(ans, trace, node)\n     47 else:\n---> 48     return f_raw(*args, **kwargs)\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\interfaces\\autograd.py:378, in _execute(parameters, tapes, device, execute_fn, gradient_fn, gradient_kwargs, _n, max_diff)\n    360 if logger.isEnabledFor(logging.DEBUG):\n    361     logger.debug(\n    362         \"Entry with args=(parameters=%s, tapes=%s, device=%s, execute_fn=%s, gradient_fn=%s, gradient_kwargs=%s, _n=%s, max_diff=%s) called by=%s\",\n    363         parameters,\n   (...)\n    375         \"::L\".join(str(i) for i in inspect.getouterframes(inspect.currentframe(), 2)[1][1:3]),\n    376     )\n--> 378 res, jacs = execute_fn(tapes, **gradient_kwargs)\n    380 return res, jacs\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\interfaces\\execution.py:623, in execute.<locals>.inner_execute_with_empty_jac(tapes, **_)\n    622 def inner_execute_with_empty_jac(tapes, **_):\n--> 623     return (inner_execute(tapes), [])\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\interfaces\\execution.py:255, in _make_inner_execute.<locals>.inner_execute(tapes, **_)\n    253 if numpy_only:\n    254     tapes = tuple(qml.transforms.convert_to_numpy_parameters(t) for t in tapes)\n--> 255 return cached_device_execution(tapes)\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\interfaces\\execution.py:377, in cache_execute.<locals>.wrapper(tapes, **kwargs)\n    372         return (res, []) if return_tuple else res\n    374 else:\n    375     # execute all unique tapes that do not exist in the cache\n    376     # convert to list as new device interface returns a tuple\n--> 377     res = list(fn(tuple(execution_tapes.values()), **kwargs))\n    379 final_res = []\n    381 for i, tape in enumerate(tapes):\n\nFile ~\\anaconda3\\Lib\\contextlib.py:81, in ContextDecorator.__call__.<locals>.inner(*args, **kwds)\n     78 @wraps(func)\n     79 def inner(*args, **kwds):\n     80     with self._recreate_cm():\n---> 81         return func(*args, **kwds)\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane_qiskit\\ibmq.py:91, in IBMQDevice.batch_execute(self, circuits)\n     90 def batch_execute(self, circuits):  # pragma: no cover, pylint:disable=arguments-differ\n---> 91     res = super().batch_execute(circuits, timeout=self.timeout_secs)\n     92     if self.tracker.active:\n     93         self._track_run()\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane_qiskit\\qiskit_device.py:473, in QiskitDevice.batch_execute(self, circuits, timeout)\n    470 def batch_execute(self, circuits, timeout: int = None):\n    471     # pylint: disable=missing-function-docstring\n--> 473     compiled_circuits = self.compile_circuits(circuits)\n    475     # Send the batch of circuit objects using backend.run\n    476     self._current_job = self.backend.run(compiled_circuits, shots=self.shots, **self.run_args)\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane_qiskit\\qiskit_device.py:462, in QiskitDevice.compile_circuits(self, circuits)\n    458 for circuit in circuits:\n    459     # We need to reset the device here, else it will\n    460     # not start the next computation in the zero state\n    461     self.reset()\n--> 462     self.create_circuit_object(circuit.operations, rotations=circuit.diagonalizing_gates)\n    464     compiled_circ = self.compile()\n    465     compiled_circ.name = f\"circ{len(compiled_circuits)}\"\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane_qiskit\\qiskit_device.py:273, in QiskitDevice.create_circuit_object(self, operations, **kwargs)\n    261 \"\"\"Builds the circuit objects based on the operations and measurements\n    262 specified to apply.\n    263 \n   (...)\n    269         pre-measurement into the eigenbasis of the observables.\n    270 \"\"\"\n    271 rotations = kwargs.get(\"rotations\", [])\n--> 273 applied_operations = self.apply_operations(operations)\n    275 # Rotating the state for measurement in the computational basis\n    276 rotation_circuits = self.apply_operations(rotations)\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane_qiskit\\qiskit_device.py:322, in QiskitDevice.apply_operations(self, operations)\n    318         par[idx] = p.tolist()\n    320 operation = operation.name\n--> 322 mapped_operation = self._operation_map[operation]\n    324 self.qubit_state_vector_check(operation)\n    326 qregs = [self._reg[i] for i in device_wires.labels]\n\nKeyError: 'C(RZ)'\n\nAnd, finally, make sure to include the versions of your packages. Specifically, show us the output of qml.about().\nName: PennyLane\nVersion: 0.32.0\nSummary: PennyLane is a Python quantum machine learning library by Xanadu Inc.\nHome-page: GitHub - PennyLaneAI/pennylane: PennyLane is a cross-platform Python library for differentiable programming of quantum computers. Train a quantum computer the same way as a neural network.\nAuthor:\nAuthor-email:\nLicense: Apache License 2.0\nLocation: C:\\Users\\Carter\\anaconda3\\Lib\\site-packages\nRequires: appdirs, autograd, autoray, cachetools, networkx, numpy, pennylane-lightning, requests, rustworkx, scipy, semantic-version, toml, typing-extensions\nRequired-by: PennyLane-Lightning, PennyLane-qiskit\nPlatform info:           Windows-10-10.0.22621-SP0\nPython version:          3.11.5\nNumpy version:           1.23.5\nScipy version:           1.11.1\nInstalled devices:\n\ndefault.gaussian (PennyLane-0.32.0)\ndefault.mixed (PennyLane-0.32.0)\ndefault.qubit (PennyLane-0.32.0)\ndefault.qubit.autograd (PennyLane-0.32.0)\ndefault.qubit.jax (PennyLane-0.32.0)\ndefault.qubit.tf (PennyLane-0.32.0)\ndefault.qubit.torch (PennyLane-0.32.0)\ndefault.qutrit (PennyLane-0.32.0)\nnull.qubit (PennyLane-0.32.0)\nlightning.qubit (PennyLane-Lightning-0.32.0)\nqiskit.aer (PennyLane-qiskit-0.32.0)\nqiskit.basicaer (PennyLane-qiskit-0.32.0)\nqiskit.ibmq (PennyLane-qiskit-0.32.0)\nqiskit.ibmq.circuit_runner (PennyLane-qiskit-0.32.0)\nqiskit.ibmq.sampler (PennyLane-qiskit-0.32.0)\nqiskit.remote (PennyLane-qiskit-0.32.0)\n", "link": "https://discuss.pennylane.ai//t/pennylane-ibmq-conversion-error/3498/1"}, "1": {"author": "isaacdevlugt", "date": "1696430646284", "content": "Hey @shrug001! Welcome to the forum and thanks for watching our video \nGreat question. The way operators get translated from PL to Qiskit is via a dictionary lookup given the operator\u2019s name in PL (see here for the source code). The controlled RX gate has a different name in PennyLane depending on how you define it:\n>>> op = qml.CRX(0.1, wires=[0, 1])\n>>> op.name\n'CRX'\n>>> op = qml.ctrl(qml.RX(0.1, 0), control=[1])\n>>> op.name\n'C(RX)'\n\nThere is a mapping for when the name is CRX, but not for C(RX) .\nSo, looks like you found a bug! Do you mind making a bug report 1 on the PennyLane github?1", "link": "https://discuss.pennylane.ai//t/pennylane-ibmq-conversion-error/3498/2"}, "2": {"author": "shrug001", "date": "1696643614168", "content": "The bug report has been filed. Thank you very much for your help.1", "link": "https://discuss.pennylane.ai//t/pennylane-ibmq-conversion-error/3498/3"}, "3": {"author": "shrug001", "date": "1696647996361", "content": "When I changed the code to this:\naux_oracle_wires = [6, 7, 8 ,9 ,10, 11]\ndef oracle(variables_wires, aux_oracle_wires):\ndef add_k_fourier(k, wires,wires2, num):\n    for j in range(len(wires)):\n        qml.CRZ(k * np.pi / (2**j), wires=[wires2[num],wires[j]])\n        \ndef value_second_sibling():\n    \n    qml.QFT(wires = aux_oracle_wires)\n    \n    for i in range(len(variables_wires)):\n        add_k_fourier(property_prices[i],aux_oracle_wires, variables_wires, i)\n        \n    qml.adjoint(qml.QFT)(wires = aux_oracle_wires)\n    \nvalue_second_sibling()\nqml.FlipSign(sum(property_prices) // 2, wires = aux_oracle_wires)\nqml.adjoint(value_second_sibling)()\n\nIt gives me the same error even though I am not using the qml.ctrl function anymore:\nKeyError                                  Traceback (most recent call last)\nCell In[8], line 3\n1 import matplotlib.pyplot as plt\n----> 3 values = circuit()\n4 plt.bar(range(len(values)), values)\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\qnode.py:989, in QNode.call(self, *args, **kwargs)\n986     self.execute_kwargs.pop(\u201cmode\u201d)\n988 # pylint: disable=unexpected-keyword-arg\n \u2192 989 res = qml.execute(\n990     (self._tape,),\n991     device=self.device,\n992     gradient_fn=self.gradient_fn,\n993     interface=self.interface,\n994     transform_program=self.transform_program,\n995     gradient_kwargs=self.gradient_kwargs,\n996     override_shots=override_shots,\n997     **self.execute_kwargs,\n998 )\n1000 res = res[0]\n1002 # convert result to the interface in case the qfunc has no parameters\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\interfaces\\execution.py:757, in execute(tapes, device, gradient_fn, interface, transform_program, grad_on_execution, gradient_kwargs, cache, cachesize, max_diff, override_shots, expand_fn, max_expansion, device_batch_transform)\n754     raise ValueError(\u201cGradient transforms cannot be used with grad_on_execution=True\u201d)\n756 ml_boundary_execute = _get_ml_boundary_execute(interface, _grad_on_execution)\n \u2192 757 results = ml_boundary_execute(\n758     tapes, device, execute_fn, gradient_fn, gradient_kwargs, _n=1, max_diff=max_diff\n759 )\n761 results = batch_fn(results)\n762 return program_post_processing(results)\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\interfaces\\autograd.py:317, in execute(tapes, device, execute_fn, gradient_fn, gradient_kwargs, _n, max_diff)\n312 # pylint misidentifies autograd.builtins as a dict\n313 # pylint: disable=no-member\n314 parameters = autograd.builtins.tuple(\n315     [autograd.builtins.list(t.get_parameters()) for t in tapes]\n316 )\n \u2192 317 return _execute(\n318     parameters,\n319     tapes=tapes,\n320     device=device,\n321     execute_fn=execute_fn,\n322     gradient_fn=gradient_fn,\n323     gradient_kwargs=gradient_kwargs,\n324     _n=_n,\n325     max_diff=max_diff,\n326 )[0]\nFile ~\\anaconda3\\Lib\\site-packages\\autograd\\tracer.py:48, in primitive..f_wrapped(*args, **kwargs)\n46     return new_box(ans, trace, node)\n47 else:\n\u2014> 48     return f_raw(*args, **kwargs)\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\interfaces\\autograd.py:378, in _execute(parameters, tapes, device, execute_fn, gradient_fn, gradient_kwargs, _n, max_diff)\n360 if logger.isEnabledFor(logging.DEBUG):\n361     logger.debug(\n362         \u201cEntry with args=(parameters=%s, tapes=%s, device=%s, execute_fn=%s, gradient_fn=%s, gradient_kwargs=%s, _n=%s, max_diff=%s) called by=%s\u201d,\n363         parameters,\n(\u2026)\n375         \u201c::L\u201d.join(str(i) for i in inspect.getouterframes(inspect.currentframe(), 2)[1][1:3]),\n376     )\n \u2192 378 res, jacs = execute_fn(tapes, **gradient_kwargs)\n380 return res, jacs\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\interfaces\\execution.py:623, in execute..inner_execute_with_empty_jac(tapes, **)\n622 def inner_execute_with_empty_jac(tapes, **):\n \u2192 623     return (inner_execute(tapes), )\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\interfaces\\execution.py:255, in make_inner_execute..inner_execute(tapes, **)\n253 if numpy_only:\n254     tapes = tuple(qml.transforms.convert_to_numpy_parameters(t) for t in tapes)\n \u2192 255 return cached_device_execution(tapes)\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\interfaces\\execution.py:377, in cache_execute..wrapper(tapes, **kwargs)\n372         return (res, ) if return_tuple else res\n374 else:\n375     # execute all unique tapes that do not exist in the cache\n376     # convert to list as new device interface returns a tuple\n \u2192 377     res = list(fn(tuple(execution_tapes.values()), **kwargs))\n379 final_res = \n381 for i, tape in enumerate(tapes):\nFile ~\\anaconda3\\Lib\\contextlib.py:81, in ContextDecorator.call..inner(*args, **kwds)\n78 @wraps(func)\n79 def inner(*args, **kwds):\n80     with self._recreate_cm():\n\u2014> 81         return func(*args, **kwds)\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane_qiskit\\ibmq.py:91, in IBMQDevice.batch_execute(self, circuits)\n90 def batch_execute(self, circuits):  # pragma: no cover, pylint:disable=arguments-differ\n\u2014> 91     res = super().batch_execute(circuits, timeout=self.timeout_secs)\n92     if self.tracker.active:\n93         self._track_run()\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane_qiskit\\qiskit_device.py:473, in QiskitDevice.batch_execute(self, circuits, timeout)\n470 def batch_execute(self, circuits, timeout: int = None):\n471     # pylint: disable=missing-function-docstring\n \u2192 473     compiled_circuits = self.compile_circuits(circuits)\n475     # Send the batch of circuit objects using backend.run\n476     self._current_job = self.backend.run(compiled_circuits, shots=self.shots, **self.run_args)\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane_qiskit\\qiskit_device.py:462, in QiskitDevice.compile_circuits(self, circuits)\n458 for circuit in circuits:\n459     # We need to reset the device here, else it will\n460     # not start the next computation in the zero state\n461     self.reset()\n \u2192 462     self.create_circuit_object(circuit.operations, rotations=circuit.diagonalizing_gates)\n464     compiled_circ = self.compile()\n465     compiled_circ.name = f\"circ{len(compiled_circuits)}\"\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane_qiskit\\qiskit_device.py:273, in QiskitDevice.create_circuit_object(self, operations, **kwargs)\n261 \u201c\u201d\u201cBuilds the circuit objects based on the operations and measurements\n262 specified to apply.\n263\n(\u2026)\n269         pre-measurement into the eigenbasis of the observables.\n270 \u201c\u201d\u201d\n271 rotations = kwargs.get(\u201crotations\u201d, )\n \u2192 273 applied_operations = self.apply_operations(operations)\n275 # Rotating the state for measurement in the computational basis\n276 rotation_circuits = self.apply_operations(rotations)\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane_qiskit\\qiskit_device.py:322, in QiskitDevice.apply_operations(self, operations)\n318         par[idx] = p.tolist()\n320 operation = operation.name\n \u2192 322 mapped_operation = self._operation_map[operation]\n324 self.qubit_state_vector_check(operation)\n326 qregs = [self._reg[i] for i in device_wires.labels]\nKeyError: \u2018C(RZ)\u2019", "link": "https://discuss.pennylane.ai//t/pennylane-ibmq-conversion-error/3498/4"}, "4": {"author": "isaacdevlugt", "date": "1697033707434", "content": "Hey @shrug001! Thanks for making the bug report \nThe issue still persisting probably means that another operator here is being decomposed into a problematic one (one that uses qml.ctrl somewhere) on the qasm simulator. I can\u2019t see any operator in your updated code that decomposes into a CRZ operator when using default.qubit (i.e., not the qasm device).\nLet me see what I can find out though. In the meantime, do you need to run this on the qasm simulator, or can you use a native PL simulator?", "link": "https://discuss.pennylane.ai//t/pennylane-ibmq-conversion-error/3498/5"}, "5": {"author": "shrug001", "date": "1697036526349", "content": "I can run this on a pennylane simulator. I just want this to be able to run on an actual quantum computer so I am testing with qiskit before I actually send a real job. It\u2019s not urgent or anything though.", "link": "https://discuss.pennylane.ai//t/pennylane-ibmq-conversion-error/3498/6"}, "6": {"author": "isaacdevlugt", "date": "1697122816615", "content": "@shrug001 can you try doing this to avoid anything being decomposed into a controlled rotation gate?\n@qml.qnode(dev)\n@qml.compile(basis_set=[\"CNOT\", \"RZ\", \"RX\", \"RY\"])\ndef circuit():\n    \n    # step 1\n    for wire in variables_wires:\n        qml.Hadamard(wires = wire)\n       \n    # step 2\n    oracle(variables_wires, aux_oracle_wires)\n    \n    # step 3\n    qml.GroverOperator(wires = variables_wires)\n    \n    return qml.probs(wires = variables_wires)\n\nLet me know if this helps!", "link": "https://discuss.pennylane.ai//t/pennylane-ibmq-conversion-error/3498/7"}, "7": {"author": "shrug001", "date": "1697124924276", "content": "\n\n\n isaacdevlugt:\n\n@qml.compile(basis_set=[\"CNOT\", \"RZ\", \"RX\", \"RY\"])\n\n\nI get this error\n\nIndexError                                Traceback (most recent call last)\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\operation.py:1032, in Operator.init(self, wires, id, *params)\n1031 try:\n \u2192 1032     wires = params[-1]\n1033     params = params[:-1]\nIndexError: tuple index out of range\nThe above exception was the direct cause of the following exception:\nValueError                                Traceback (most recent call last)\nCell In[4], line 3\n1 import matplotlib.pyplot as plt\n----> 3 values = circuit()\n4 plt.bar(range(len(values)), values)\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\qnode.py:974, in QNode.call(self, *args, **kwargs)\n971         kwargs[\u201cshots\u201d] = _get_device_shots(self._original_device)\n973 # construct the tape\n \u2192 974 self.construct(args, kwargs)\n976 cache = self.execute_kwargs.get(\u201ccache\u201d, False)\n977 using_custom_cache = (\n978     hasattr(cache, \u201cgetitem\u201d)\n979     and hasattr(cache, \u201csetitem\u201d)\n980     and hasattr(cache, \u201cdelitem\u201d)\n981 )\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\qnode.py:872, in QNode.construct(self, args, kwargs)\n869 if old_interface == \u201cauto\u201d:\n870     self.interface = qml.math.get_interface(*args, *list(kwargs.values()))\n \u2192 872 self._tape = make_qscript(self.func, shots)(*args, **kwargs)\n873 self._qfunc_output = self.tape._qfunc_output\n875 params = self.tape.get_parameters(trainable_only=False)\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\tape\\qscript.py:1531, in make_qscript..wrapper(*args, **kwargs)\n1529 def wrapper(*args, **kwargs):\n1530     with AnnotatedQueue() as q:\n \u2192 1531         result = fn(*args, **kwargs)\n1533     qscript = QuantumScript.from_queue(q, shots)\n1534     qscript._qfunc_output = result\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\transforms\\qfunc_transforms.py:181, in _create_qfunc_internal_wrapper..internal_wrapper(*args, **kwargs)\n178 @functools.wraps(fn)\n179 def internal_wrapper(*args, **kwargs):\n180     tape = make_qscript(fn)(*args, **kwargs)\n \u2192 181     tape = tape_transform(tape, *transform_args, **transform_kwargs)\n183     num_measurements = len(tape.measurements)\n184     if num_measurements == 0:\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\transforms\\qfunc_transforms.py:147, in single_tape_transform.call(self, tape, *args, **kwargs)\n145 def call(self, tape, *args, **kwargs):\n146     with qml.queuing.AnnotatedQueue() as q:\n \u2192 147         self.transform_fn(tape, *args, **kwargs)\n148     qs = qml.tape.QuantumScript.from_queue(q, shots=tape.shots)\n149     for obj, info in q.items():\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\transforms\\compile.py:158, in compile(tape, pipeline, basis_set, num_passes, expand_depth)\n156 with QueuingManager.stop_recording():\n157     if basis_set is not None:\n \u2192 158         expanded_tape = tape.expand(\n159             depth=expand_depth, stop_at=lambda obj: obj.name in basis_set\n160         )\n161     else:\n162         # Expands out anything that is not a single operation (i.e., the templates)\n163         # expand barriers when only_visual=True\n164         def stop_at(obj):\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\tape\\qscript.py:1234, in QuantumScript.expand(self, depth, stop_at, expand_measurements)\n1189 def expand(self, depth=1, stop_at=None, expand_measurements=False):\n1190     \u201c\u201d\u201cExpand all operations to a specific depth.\n1191\n1192     Args:\n(\u2026)\n1232     RY(0.2, wires=[\u2018a\u2019])]\n1233     \u201c\u201d\u201d\n \u2192 1234     new_script = qml.tape.tape.expand_tape(\n1235         self, depth=depth, stop_at=stop_at, expand_measurements=expand_measurements\n1236     )\n1237     new_script._update()\n1238     return new_script\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\tape\\tape.py:217, in expand_tape(tape, depth, stop_at, expand_measurements)\n214         continue\n216 # recursively expand out the newly created tape\n \u2192 217 expanded_tape = expand_tape(obj, stop_at=stop_at, depth=depth - 1)\n219 new_ops.extend(expanded_tape.operations)\n220 new_measurements.extend(expanded_tape.measurements)\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\tape\\tape.py:217, in expand_tape(tape, depth, stop_at, expand_measurements)\n214         continue\n216 # recursively expand out the newly created tape\n \u2192 217 expanded_tape = expand_tape(obj, stop_at=stop_at, depth=depth - 1)\n219 new_ops.extend(expanded_tape.operations)\n220 new_measurements.extend(expanded_tape.measurements)\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\tape\\tape.py:217, in expand_tape(tape, depth, stop_at, expand_measurements)\n214         continue\n216 # recursively expand out the newly created tape\n \u2192 217 expanded_tape = expand_tape(obj, stop_at=stop_at, depth=depth - 1)\n219 new_ops.extend(expanded_tape.operations)\n220 new_measurements.extend(expanded_tape.measurements)\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\tape\\tape.py:202, in expand_tape(tape, depth, stop_at, expand_measurements)\n200 if obj.has_decomposition:\n201     with QueuingManager.stop_recording():\n \u2192 202         obj = QuantumScript(obj.decomposition(), _update=False)\n203 else:\n204     new_queue.append(obj)\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\operation.py:1257, in Operator.decomposition(self)\n1245 def decomposition(self):\n1246     r\"\"\u201cRepresentation of the operator as a product of other operators.\n1247\n1248     \u2026 math:: O = O_1 O_2 \\dots O_n\n(\u2026)\n1255         list[Operator]: decomposition of the operator\n1256     \u201c\u201d\u201d\n \u2192 1257     return self.compute_decomposition(\n1258         *self.parameters, wires=self.wires, **self.hyperparameters\n1259     )\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\ops\\qubit\\non_parametric_ops.py:1982, in Toffoli.compute_decomposition(wires)\n1946 @staticmethod\n1947 def compute_decomposition(wires):\n1948     r\"\"\u201cRepresentation of the operator as a product of other operators (static method).\n1949\n1950     \u2026 math:: O = O_1 O_2 \\dots O_n.\n(\u2026)\n1979\n1980     \u201c\u201d\u201d\n1981     return [\n \u2192 1982         Hadamard(wires=wires[2]),\n1983         CNOT(wires=[wires[1], wires[2]]),\n1984         qml.adjoint(T(wires=wires[2])),\n1985         CNOT(wires=[wires[0], wires[2]]),\n1986         T(wires=wires[2]),\n1987         CNOT(wires=[wires[1], wires[2]]),\n1988         qml.adjoint(T(wires=wires[2])),\n1989         CNOT(wires=[wires[0], wires[2]]),\n1990         T(wires=wires[2]),\n1991         T(wires=wires[1]),\n1992         CNOT(wires=[wires[0], wires[1]]),\n1993         Hadamard(wires=wires[2]),\n1994         T(wires=wires[0]),\n1995         qml.adjoint(T(wires=wires[1])),\n1996         CNOT(wires=[wires[0], wires[1]]),\n1997     ]\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\operation.py:1764, in Operation.init(self, wires, id, *params)\n1763 def init(self, *params, wires=None, id=None):\n \u2192 1764     super().init(*params, wires=wires, id=id)\n1766     # check the grad_recipe validity\n1767     if self.grad_recipe is None:\n1768         # Make sure grad_recipe is an iterable of correct length instead of None\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\operation.py:1036, in Operator.init(self, wires, id, *params)\n1034         wires_from_args = True\n1035     except IndexError as err:\n \u2192 1036         raise ValueError(\n1037             f\"Must specify the wires that {type(self).name} acts on\"\n1038         ) from err\n1040 self._num_params = len(params)\n1042 # Check if the expected number of parameters coincides with the one received.\n1043 # This is always true for the default Operator.num_params property, but\n1044 # subclasses may overwrite it to define a fixed expected value.\nValueError: Must specify the wires that Hadamard acts on", "link": "https://discuss.pennylane.ai//t/pennylane-ibmq-conversion-error/3498/8"}, "8": {"author": "shrug001", "date": "1697124978616", "content": "Which is weird because I do specify the wires", "link": "https://discuss.pennylane.ai//t/pennylane-ibmq-conversion-error/3498/9"}, "9": {"author": "isaacdevlugt", "date": "1697141113143", "content": "@shrug001 can you attach the full code example that you\u2019re currently working with that produces that error?", "link": "https://discuss.pennylane.ai//t/pennylane-ibmq-conversion-error/3498/10"}, "10": {"author": "shrug001", "date": "1697201368361", "content": "import pennylane as qml\nfrom pennylane import numpy as np\n\nproperty_prices = [4, 8, 6, 3, 12, 15] # total 48 \nvariables_wires = [0, 1, 2, 3, 4, 5]\n\naux_oracle_wires = [6, 7, 8 ,9 ,10, 11]\n\ndef oracle(variables_wires, aux_oracle_wires):\n    \n    def add_k_fourier(k, wires,wires2, num):\n        for j in range(len(wires)):\n            qml.CRZ(k * np.pi / (2**j), wires=[wires2[num],wires[j]])\n            \n    def value_second_sibling():\n        \n        qml.QFT(wires = aux_oracle_wires)\n        \n        for i in range(len(variables_wires)):\n            add_k_fourier(property_prices[i],aux_oracle_wires, variables_wires, i)\n            \n        qml.adjoint(qml.QFT)(wires = aux_oracle_wires)\n        \n    value_second_sibling()\n    qml.FlipSign(sum(property_prices) // 2, wires = aux_oracle_wires)\n    qml.adjoint(value_second_sibling)()\n\ndev = qml.device('qiskit.ibmq', wires=12, backend='ibmq_qasm_simulator')\n\n@qml.qnode(dev)\n@qml.compile(basis_set=[\"CNOT\", \"RZ\", \"RX\", \"RY\"])\ndef circuit():\n    \n    # step 1\n    for wire in variables_wires:\n        qml.Hadamard(wires = wire)\n       \n    # step 2\n    oracle(variables_wires, aux_oracle_wires)\n    \n    # step 3\n    qml.GroverOperator(wires = variables_wires)\n    \n    return qml.probs(wires = variables_wires)\n\n\nimport matplotlib.pyplot as plt\n\nvalues = circuit()\nplt.bar(range(len(values)), values)import matplotlib.pyplot as plt\n\nvalues = circuit()\nplt.bar(range(len(values)), values)\n", "link": "https://discuss.pennylane.ai//t/pennylane-ibmq-conversion-error/3498/11"}, "11": {"author": "shrug001", "date": "1697201432923", "content": "ignore the second repeat of the code near the end", "link": "https://discuss.pennylane.ai//t/pennylane-ibmq-conversion-error/3498/12"}, "12": {"author": "isaacdevlugt", "date": "1697465912751", "content": "Hey @shrug001! Thanks. There seems to be some sort of issue here that\u2019s caused with the choice of gate basis set and how GroverOperator gets decomposed as a result. Am looking into it!", "link": "https://discuss.pennylane.ai//t/pennylane-ibmq-conversion-error/3498/13"}, "13": {"author": "isaacdevlugt", "date": "1697476269795", "content": "Okay \u2014 looks like this issue has been solved here: Fix grover operator work wires by albi3ro \u00b7 Pull Request #4668 \u00b7 PennyLaneAI/pennylane \u00b7 GitHub 1\nTo access the fix, you\u2019ll need to install PennyLane from source:\n>>> git clone https://github.com/PennyLaneAI/pennylane.git\n>>> cd pennylane\n>>> pip install -e .\n\nLet me know if this helps!", "link": "https://discuss.pennylane.ai//t/pennylane-ibmq-conversion-error/3498/14"}, "14": {"author": "shrug001", "date": "1697548219110", "content": "Running the same code as before I now get:\nC:\\Users\\Carter\\anaconda3\\Lib\\site-packages\\pennylane\\transforms\\core\\transform_dispatcher.py:101: UserWarning: Decorating a QNode with @transform_fn(**transform_kwargs) has been deprecated and will be removed in a future version. Please decorate with @functools.partial(transform_fn, **transform_kwargs) instead, or call the transform directly using qnode = transform_fn(qnode, **transform_kwargs)\nwarnings.warn(\nAnd the Error message:\nValueError                                Traceback (most recent call last)\nCell In[4], line 3\n      1 import matplotlib.pyplot as plt\n----> 3 values = circuit()\n      4 plt.bar(range(len(values)), values)\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\qnode.py:957, in QNode.__call__(self, *args, **kwargs)\n    954         kwargs[\"shots\"] = _get_device_shots(self._original_device)\n    956 # construct the tape\n--> 957 self.construct(args, kwargs)\n    959 cache = self.execute_kwargs.get(\"cache\", False)\n    960 using_custom_cache = (\n    961     hasattr(cache, \"__getitem__\")\n    962     and hasattr(cache, \"__setitem__\")\n    963     and hasattr(cache, \"__delitem__\")\n    964 )\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\qnode.py:847, in QNode.construct(self, args, kwargs)\n    844     self.interface = qml.math.get_interface(*args, *list(kwargs.values()))\n    846 with qml.queuing.AnnotatedQueue() as q:\n--> 847     self._qfunc_output = self.func(*args, **kwargs)\n    849 self._tape = QuantumScript.from_queue(q, shots)\n    851 params = self.tape.get_parameters(trainable_only=False)\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\transforms\\core\\transform_dispatcher.py:223, in TransformDispatcher._qfunc_transform.<locals>.qfunc_transformed(*args, **kwargs)\n    220     qfunc_output = qfunc(*args, **kwargs)\n    222 tape = qml.tape.QuantumScript.from_queue(q)\n--> 223 transformed_tapes, processing_fn = self._transform(tape, *targs, **tkwargs)\n    225 if len(transformed_tapes) != 1:\n    226     raise TransformError(\n    227         \"Impossible to dispatch your transform on quantum function, because more than \"\n    228         \"one tape is returned\"\n    229     )\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\transforms\\compile.py:164, in compile(tape, pipeline, basis_set, num_passes, expand_depth)\n    162 with QueuingManager.stop_recording():\n    163     if basis_set is not None:\n--> 164         expanded_tape = tape.expand(\n    165             depth=expand_depth, stop_at=lambda obj: obj.name in basis_set\n    166         )\n    167     else:\n    168         # Expands out anything that is not a single operation (i.e., the templates)\n    169         # expand barriers when `only_visual=True`\n    170         def stop_at(obj):\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\tape\\qscript.py:948, in QuantumScript.expand(self, depth, stop_at, expand_measurements)\n    903 def expand(self, depth=1, stop_at=None, expand_measurements=False):\n    904     \"\"\"Expand all operations to a specific depth.\n    905 \n    906     Args:\n   (...)\n    946     RY(0.2, wires=['a'])]\n    947     \"\"\"\n--> 948     new_script = qml.tape.tape.expand_tape(\n    949         self, depth=depth, stop_at=stop_at, expand_measurements=expand_measurements\n    950     )\n    951     new_script._update()\n    952     return new_script\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\tape\\tape.py:218, in expand_tape(tape, depth, stop_at, expand_measurements)\n    215         continue\n    217 # recursively expand out the newly created tape\n--> 218 expanded_tape = expand_tape(obj, stop_at=stop_at, depth=depth - 1)\n    220 new_ops.extend(expanded_tape.operations)\n    221 new_measurements.extend(expanded_tape.measurements)\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\tape\\tape.py:203, in expand_tape(tape, depth, stop_at, expand_measurements)\n    201 if obj.has_decomposition:\n    202     with QueuingManager.stop_recording():\n--> 203         obj = QuantumScript(obj.decomposition(), _update=False)\n    204 else:\n    205     new_queue.append(obj)\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\operation.py:1238, in Operator.decomposition(self)\n   1226 def decomposition(self):\n   1227     r\"\"\"Representation of the operator as a product of other operators.\n   1228 \n   1229     .. math:: O = O_1 O_2 \\dots O_n\n   (...)\n   1236         list[Operator]: decomposition of the operator\n   1237     \"\"\"\n-> 1238     return self.compute_decomposition(\n   1239         *self.parameters, wires=self.wires, **self.hyperparameters\n   1240     )\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\ops\\qubit\\non_parametric_ops.py:2229, in MultiControlledX.compute_decomposition(wires, work_wires, control_values, **kwargs)\n   2226     control_values = \"1\" * len(control_wires)\n   2228 if len(control_wires) > 2 and len(work_wires) == 0:\n-> 2229     raise ValueError(\n   2230         \"At least one work wire is required to decompose operation: MultiControlledX\"\n   2231     )\n   2233 flips1 = [\n   2234     qml.PauliX(control_wires[i]) for i, val in enumerate(control_values) if val == \"0\"\n   2235 ]\n   2237 if len(control_wires) == 1:\n\nValueError: At least one work wire is required to decompose operation: MultiControlledX\n\n\nFor qml.about I get\nName: PennyLane\nVersion: 0.33.0.dev0\nSummary: PennyLane is a Python quantum machine learning library by Xanadu Inc.\nHome-page: https://github.com/PennyLaneAI/pennylane\nAuthor: \nAuthor-email: \nLicense: Apache License 2.0\nLocation: C:\\Users\\Carter\\anaconda3\\Lib\\site-packages\nRequires: appdirs, autograd, autoray, cachetools, networkx, numpy, pennylane-lightning, requests, rustworkx, scipy, semantic-version, toml, typing-extensions\nRequired-by: PennyLane-Lightning, PennyLane-qiskit\n\nPlatform info:           Windows-10-10.0.22621-SP0\nPython version:          3.11.5\nNumpy version:           1.23.5\nScipy version:           1.11.1\nInstalled devices:\n- default.gaussian (PennyLane-0.33.0.dev0)\n- default.mixed (PennyLane-0.33.0.dev0)\n- default.qubit (PennyLane-0.33.0.dev0)\n- default.qubit.autograd (PennyLane-0.33.0.dev0)\n- default.qubit.jax (PennyLane-0.33.0.dev0)\n- default.qubit.legacy (PennyLane-0.33.0.dev0)\n- default.qubit.tf (PennyLane-0.33.0.dev0)\n- default.qubit.torch (PennyLane-0.33.0.dev0)\n- default.qutrit (PennyLane-0.33.0.dev0)\n- null.qubit (PennyLane-0.33.0.dev0)\n- lightning.qubit (PennyLane-Lightning-0.32.0)\n- qiskit.aer (PennyLane-qiskit-0.32.0)\n- qiskit.basicaer (PennyLane-qiskit-0.32.0)\n- qiskit.ibmq (PennyLane-qiskit-0.32.0)\n- qiskit.ibmq.circuit_runner (PennyLane-qiskit-0.32.0)\n- qiskit.ibmq.sampler (PennyLane-qiskit-0.32.0)\n- qiskit.remote (PennyLane-qiskit-0.32.0)\n\n", "link": "https://discuss.pennylane.ai//t/pennylane-ibmq-conversion-error/3498/15"}, "15": {"author": "shrug001", "date": "1697548417689", "content": "I installed the preview version because for some reason the pip install -e wasn\u2019t working", "link": "https://discuss.pennylane.ai//t/pennylane-ibmq-conversion-error/3498/16"}, "16": {"author": "isaacdevlugt", "date": "1697552586502", "content": "Hey @shrug001! I forgot to mention the work_wires thing . Apologies! work_wires are auxiliary wires that assist with decomposing MultiControlledX. This should work:\nimport pennylane as qml\nfrom pennylane import numpy as np\n\n\nproperty_prices = [4, 8, 6, 3, 12, 15] # total 48 \nvariables_wires = [0, 1, 2, 3, 4, 5]\n\naux_oracle_wires = [6, 7, 8 ,9 ,10, 11]\n\ndef oracle(variables_wires, aux_oracle_wires):\n    \n    def add_k_fourier(k, wires,wires2, num):\n        for j in range(len(wires)):\n            qml.CRZ(k * np.pi / (2**j), wires=[wires2[num],wires[j]])\n            \n    def value_second_sibling():\n        \n        qml.QFT(wires = aux_oracle_wires)\n        \n        for i in range(len(variables_wires)):\n            add_k_fourier(property_prices[i],aux_oracle_wires, variables_wires, i)\n            \n        qml.adjoint(qml.QFT)(wires = aux_oracle_wires)\n        \n    value_second_sibling()\n    qml.FlipSign(sum(property_prices) // 2, wires = aux_oracle_wires)\n    qml.adjoint(value_second_sibling)()\n\n#dev = qml.device('qiskit.ibmq', wires=12, backend='ibmq_qasm_simulator')\ndev = qml.device('default.qubit', wires=12)\n\n@qml.qnode(dev)\n@qml.compile(basis_set=[\"CNOT\", \"RZ\", \"RX\", \"RY\"])\ndef circuit():\n    \n    # step 1\n    for wire in variables_wires:\n        qml.Hadamard(wire)\n       \n    # step 2\n    oracle(variables_wires, aux_oracle_wires)\n    \n    # step 3\n    qml.GroverOperator(wires = variables_wires, work_wires=aux_oracle_wires)\n    \n    return qml.probs(wires = variables_wires)\n\nvalues = circuit()\n\nLet me know if that helps!", "link": "https://discuss.pennylane.ai//t/pennylane-ibmq-conversion-error/3498/17"}, "17": {"author": "shrug001", "date": "1697554811013", "content": "The code works for the pennylane simulator but when I try to run it with the IBMQ simulator I get this error:\nKeyError                                  Traceback (most recent call last)\nCell In[4], line 3\n      1 import matplotlib.pyplot as plt\n----> 3 values = circuit()\n      4 plt.bar(range(len(values)), values)\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\qnode.py:1008, in QNode.__call__(self, *args, **kwargs)\n   1003     full_transform_program._set_all_argnums(\n   1004         self, args, kwargs, argnums\n   1005     )  # pylint: disable=protected-access\n   1007 # pylint: disable=unexpected-keyword-arg\n-> 1008 res = qml.execute(\n   1009     (self._tape,),\n   1010     device=self.device,\n   1011     gradient_fn=self.gradient_fn,\n   1012     interface=self.interface,\n   1013     transform_program=full_transform_program,\n   1014     config=config,\n   1015     gradient_kwargs=self.gradient_kwargs,\n   1016     override_shots=override_shots,\n   1017     **self.execute_kwargs,\n   1018 )\n   1020 res = res[0]\n   1022 # convert result to the interface in case the qfunc has no parameters\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\interfaces\\execution.py:736, in execute(tapes, device, gradient_fn, interface, transform_program, config, grad_on_execution, gradient_kwargs, cache, cachesize, max_diff, override_shots, expand_fn, max_expansion, device_batch_transform)\n    733     raise ValueError(\"Gradient transforms cannot be used with grad_on_execution=True\")\n    735 ml_boundary_execute = _get_ml_boundary_execute(interface, _grad_on_execution)\n--> 736 results = ml_boundary_execute(\n    737     tapes, device, execute_fn, gradient_fn, gradient_kwargs, _n=1, max_diff=max_diff\n    738 )\n    740 return post_processing(results)\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\interfaces\\autograd.py:69, in execute(tapes, device, execute_fn, gradient_fn, gradient_kwargs, _n, max_diff)\n     64 # pylint misidentifies autograd.builtins as a dict\n     65 # pylint: disable=no-member\n     66 parameters = autograd.builtins.tuple(\n     67     [autograd.builtins.list(t.get_parameters()) for t in tapes]\n     68 )\n---> 69 return _execute(\n     70     parameters,\n     71     tapes=tapes,\n     72     device=device,\n     73     execute_fn=execute_fn,\n     74     gradient_fn=gradient_fn,\n     75     gradient_kwargs=gradient_kwargs,\n     76     _n=_n,\n     77     max_diff=max_diff,\n     78 )[0]\n\nFile ~\\anaconda3\\Lib\\site-packages\\autograd\\tracer.py:48, in primitive.<locals>.f_wrapped(*args, **kwargs)\n     46     return new_box(ans, trace, node)\n     47 else:\n---> 48     return f_raw(*args, **kwargs)\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\interfaces\\autograd.py:130, in _execute(parameters, tapes, device, execute_fn, gradient_fn, gradient_kwargs, _n, max_diff)\n    112 if logger.isEnabledFor(logging.DEBUG):\n    113     logger.debug(\n    114         \"Entry with args=(parameters=%s, tapes=%s, device=%s, execute_fn=%s, gradient_fn=%s, gradient_kwargs=%s, _n=%s, max_diff=%s) called by=%s\",\n    115         parameters,\n   (...)\n    127         \"::L\".join(str(i) for i in inspect.getouterframes(inspect.currentframe(), 2)[1][1:3]),\n    128     )\n--> 130 res, jacs = execute_fn(tapes, **gradient_kwargs)\n    132 return res, jacs\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\interfaces\\execution.py:588, in execute.<locals>.inner_execute_with_empty_jac(tapes, **_)\n    587 def inner_execute_with_empty_jac(tapes, **_):\n--> 588     return (inner_execute(tapes), [])\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\interfaces\\execution.py:249, in _make_inner_execute.<locals>.inner_execute(tapes, **_)\n    247 if numpy_only:\n    248     tapes = tuple(qml.transforms.convert_to_numpy_parameters(t) for t in tapes)\n--> 249 return cached_device_execution(tapes)\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane\\interfaces\\execution.py:371, in cache_execute.<locals>.wrapper(tapes, **kwargs)\n    366         return (res, []) if return_tuple else res\n    368 else:\n    369     # execute all unique tapes that do not exist in the cache\n    370     # convert to list as new device interface returns a tuple\n--> 371     res = list(fn(tuple(execution_tapes.values()), **kwargs))\n    373 final_res = []\n    375 for i, tape in enumerate(tapes):\n\nFile ~\\anaconda3\\Lib\\contextlib.py:81, in ContextDecorator.__call__.<locals>.inner(*args, **kwds)\n     78 @wraps(func)\n     79 def inner(*args, **kwds):\n     80     with self._recreate_cm():\n---> 81         return func(*args, **kwds)\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane_qiskit\\ibmq.py:91, in IBMQDevice.batch_execute(self, circuits)\n     90 def batch_execute(self, circuits):  # pragma: no cover, pylint:disable=arguments-differ\n---> 91     res = super().batch_execute(circuits, timeout=self.timeout_secs)\n     92     if self.tracker.active:\n     93         self._track_run()\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane_qiskit\\qiskit_device.py:473, in QiskitDevice.batch_execute(self, circuits, timeout)\n    470 def batch_execute(self, circuits, timeout: int = None):\n    471     # pylint: disable=missing-function-docstring\n--> 473     compiled_circuits = self.compile_circuits(circuits)\n    475     # Send the batch of circuit objects using backend.run\n    476     self._current_job = self.backend.run(compiled_circuits, shots=self.shots, **self.run_args)\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane_qiskit\\qiskit_device.py:462, in QiskitDevice.compile_circuits(self, circuits)\n    458 for circuit in circuits:\n    459     # We need to reset the device here, else it will\n    460     # not start the next computation in the zero state\n    461     self.reset()\n--> 462     self.create_circuit_object(circuit.operations, rotations=circuit.diagonalizing_gates)\n    464     compiled_circ = self.compile()\n    465     compiled_circ.name = f\"circ{len(compiled_circuits)}\"\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane_qiskit\\qiskit_device.py:273, in QiskitDevice.create_circuit_object(self, operations, **kwargs)\n    261 \"\"\"Builds the circuit objects based on the operations and measurements\n    262 specified to apply.\n    263 \n   (...)\n    269         pre-measurement into the eigenbasis of the observables.\n    270 \"\"\"\n    271 rotations = kwargs.get(\"rotations\", [])\n--> 273 applied_operations = self.apply_operations(operations)\n    275 # Rotating the state for measurement in the computational basis\n    276 rotation_circuits = self.apply_operations(rotations)\n\nFile ~\\anaconda3\\Lib\\site-packages\\pennylane_qiskit\\qiskit_device.py:322, in QiskitDevice.apply_operations(self, operations)\n    318         par[idx] = p.tolist()\n    320 operation = operation.name\n--> 322 mapped_operation = self._operation_map[operation]\n    324 self.qubit_state_vector_check(operation)\n    326 qregs = [self._reg[i] for i in device_wires.labels]\n\nKeyError: 'C(RZ)'\n\n", "link": "https://discuss.pennylane.ai//t/pennylane-ibmq-conversion-error/3498/18"}, "18": {"author": "isaacdevlugt", "date": "1697564918447", "content": "Now we\u2019re back to the original issue. That\u2019s strange \u2026 are you using this to ensure that things get decomposed in an ibmq-friendly way?\n@qml.compile(basis_set=[\"CNOT\", \"RZ\", \"RX\", \"RY\"])\n", "link": "https://discuss.pennylane.ai//t/pennylane-ibmq-conversion-error/3498/19"}, "19": {"author": "shrug001", "date": "1697566097098", "content": "yes:\nimport pennylane as qml\nfrom pennylane import numpy as np\n\nproperty_prices = [4, 8, 6, 3, 12, 15] # total 48 \nvariables_wires = [0, 1, 2, 3, 4, 5]\n\naux_oracle_wires = [6, 7, 8 ,9 ,10, 11]\n\ndef oracle(variables_wires, aux_oracle_wires):\n    \n    def add_k_fourier(k, wires,wires2, num):\n        for j in range(len(wires)):\n            qml.CRZ(k * np.pi / (2**j), wires=[wires2[num],wires[j]])\n            \n    def value_second_sibling():\n        \n        qml.QFT(wires = aux_oracle_wires)\n        \n        for i in range(len(variables_wires)):\n            add_k_fourier(property_prices[i],aux_oracle_wires, variables_wires, i)\n            \n        qml.adjoint(qml.QFT)(wires = aux_oracle_wires)\n        \n    value_second_sibling()\n    qml.FlipSign(sum(property_prices) // 2, wires = aux_oracle_wires)\n    qml.adjoint(value_second_sibling)()\n\ndev = qml.device('qiskit.ibmq', wires=12, backend='ibmq_qasm_simulator')\n#dev = qml.device('default.qubit', wires=12)\n\n@qml.qnode(dev)\n@qml.compile(basis_set=[\"CNOT\", \"RZ\", \"RX\", \"RY\"])\ndef circuit():\n    \n    # step 1\n    for wire in variables_wires:\n        qml.Hadamard(wires = wire)\n       \n    # step 2\n    oracle(variables_wires, aux_oracle_wires)\n    \n    # step 3\n    qml.GroverOperator(wires = variables_wires, work_wires=aux_oracle_wires)\n    \n    return qml.probs(wires = variables_wires)\nimport matplotlib.pyplot as plt\n\nvalues = circuit()\nplt.bar(range(len(values)), values)\n1 Reply", "link": "https://discuss.pennylane.ai//t/pennylane-ibmq-conversion-error/3498/20"}, "20": {"author": "isaacdevlugt", "date": "1697636771545", "content": "Ah \u2014 sorry about this. Looks like another bug but for the same reason as the original post; both bugs are due to us currently not decomposing rotation gates with more than one control wire.\nThere\u2019s a bug report already made and I\u2019ve made our dev team aware of the issue . They\u2019ll work on it and post any updates there!1", "link": "https://discuss.pennylane.ai//t/pennylane-ibmq-conversion-error/3498/21"}}