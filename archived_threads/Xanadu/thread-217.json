{"0": {"author": "mxn.wls", "date": "1558389595278", "content": "Hey,\nIs there a way to pass iterable arguments to the qnode, where the cost and/or ansatz is redefined for each instance of the problem?\nEx 1:\nimport pennylane as qml\nfrom pennylane import numpy as np\nN = 2\ndev = qml.device(\u2018forest.numpy_wavefunction\u2019, wires=N)\n@qml.qnode(dev)\ndef qaoa_one_qubit(param, problem=None):\nprint(problem)\nfor i in problem:\nqml.RX(param[0], wires=i)\nreturn qml.expval.PauliZ(i)\nproblem = [0]\ndcircuit = qml.grad(qaoa_one_qubit, argnum=0)\ndcircuit([0.5], problem=problem)\nThe returned error here is that the qubit should be an int or qubit instance. The problem argument is converted to a pennylane variable.\nQ: is any argument passed to a qnode classified as a Variable?\nThere is a semi-related problem in the docs https://pennylane.readthedocs.io/en/latest/tutorials/qubit_rotation.html 7 where it states\n\u201cKeyword arguments may also be used in your custom quantum function. PennyLane does differentiate QNodes with respect to keyword arguments, so they are useful for passing external data to your QNode.\u201d\nQ: What if the keyword argument is not something you want to differentiate but is some external data like a list?\nI have been working with global variables so far and they have some side effects I can\u2019t get my head around. It would be super useful to be able to pass non-differentiable params to the qnode.\n\nExtending this I attempted to put cost in as a class function which calls class variables (and here when using the GradientDescentOptimiser)\nimport pennylane as qml\nfrom pennylane import numpy as np\nN = 2\ndev = qml.device(\u2018forest.numpy_wavefunction\u2019, wires=N)\n@qml.qnode(dev)\ndef qaoa_one_qubit(param, problem=None):\nprint(int(problem[0]))\nfor i in problem:\nqml.RX(param[0], wires=i)\nreturn qml.expval.PauliZ(i)\nclass cost():\ndef init(self):\nself.problem = [0]\ndef evaluate(param):\n    exp = qaoa_one_qubit(param, problem=self.problem)\n    return exp\n\nopt = qml.GradientDescentOptimizer(stepsize=0.01)\nsteps = 10000\nparam = [0.01]\nfor i in range(steps):\nparam = opt.step(cost.evaluate, param)\n\nwhich returns\nNameError: name \u2018self\u2019 is not defined\nQ: Will the gradientdescentoptimiser and the grad functions have the same usage (if this will work at all)\n\nOverall just looking for a way to make the ansatz instance dependent for a problem.\nThanks for any help!\nMax", "link": "https://discuss.pennylane.ai//t/passing-non-differentiable-arguments-to-qnode/135/1"}, "1": {"author": "kareem_essafty", "date": "1558398747196", "content": "if you allow me\nthis example 30 demonstrates how to use pytorch and also defines which variable needs to be differentiated\nI think if i got your question right this answers your problem", "link": "https://discuss.pennylane.ai//t/passing-non-differentiable-arguments-to-qnode/135/2"}, "2": {"author": "mxn.wls", "date": "1558401406936", "content": "Hi Kareem! Thanks for the response.\nUnfortunately I don\u2019t think so. In the example you posted only differentiable parameters are passed to the qnode. There is a non-differentiable parameter passed to the cost function (step), but this isn\u2019t used in / passed to the qnode.\nWhat I would like to do is change the function inside the qnode dependent on some external data, but this external data be non-differentiable / not converted to a PennyLane Variable.\nThanks again though, and apologies if I misunderstood!\nMax", "link": "https://discuss.pennylane.ai//t/passing-non-differentiable-arguments-to-qnode/135/3"}, "3": {"author": "kareem_essafty", "date": "1558402718046", "content": "you\u2019re most welcome\nbut I think if you actually set:\n\nrequired_grad=False\n\nthen the torch backend won\u2019t calculate its gradients it would be like a constant inside your quantum circuit2 Replies", "link": "https://discuss.pennylane.ai//t/passing-non-differentiable-arguments-to-qnode/135/4"}, "4": {"author": "josh", "date": "1558446045271", "content": "\nThere is a semi-related problem in the docs https://pennylane.readthedocs.io/en/latest/tutorials/qubit_rotation.html 6 where it states\n\u201cKeyword arguments may also be used in your custom quantum function. PennyLane does differentiate QNodes with respect to keyword arguments, so they are useful for passing external data to your QNode.\u201d\n\nThanks for pointing this out, this is actually a very unfortunate typo!\nThis should instead say: \u201cPennyLane does not differentiate QNodes with respect to keyword arguments, so they are useful for passing external data to your QNode.\u201d\nWith respect to the error you are getting, it looks like you have uncovered a very obscure bug in the PennyLane code base. This can be fixed by applying the following patch to your PennyLane installation:\ndiff --git a/pennylane/operation.py b/pennylane/operation.py\nindex 43db731..355c36c 100644\n--- a/pennylane/operation.py\n+++ b/pennylane/operation.py\n@@ -373,7 +373,7 @@ class Operation(abc.ABC):\n         \"\"\"\n         w = [i.val if isinstance(i, Variable) else i for i in self._wires]\n         self.check_wires(w)\n-        return w\n+        return [int(i) for i in w]\n \n     @property\n     def parameters(self):\n\nOnce this is done, your example works as expected:\nimport pennylane as qml\nfrom pennylane import numpy as np\n\nN = 2\ndev = qml.device('forest.numpy_wavefunction', wires=N)\n\n@qml.qnode(dev)\ndef qaoa_one_qubit(param, problem=None):\n    print(problem)\n    print('problem = ', [i.val for i in problem])\n    for i in problem:\n        qml.RX(param[0], wires=i)\n    return qml.expval.PauliZ(i)\n\nproblem = [0]\ndcircuit = qml.grad(qaoa_one_qubit, argnum=0)\ndcircuit([0.5], problem=problem)\n\nThis gives the following output:\n[<pennylane.variable.Variable object at 0x7f55333c2940>]\nproblem = [0]\n[-0.479425538604203]\n\nNote: In order to print out QNode parameters from inside a QNode, you will need to use the .val property.\n\nThanks for letting us know about this issue @mxn.wls, I will make a PR in the official PennyLane github repo ASAP!\nUpdate: The PR is now available here: Keyword argument bug fixes by josh146 \u00b7 Pull Request #206 \u00b7 PennyLaneAI/pennylane \u00b7 GitHub 31", "link": "https://discuss.pennylane.ai//t/passing-non-differentiable-arguments-to-qnode/135/5"}, "5": {"author": "josh", "date": "1558447389386", "content": "With the above bugfix, your optimization example now works:\n@qml.qnode(dev)\ndef qaoa_one_qubit(param, problem=None):\n    for i in problem:\n        qml.RX(param[0], wires=i)\n    return qml.expval.PauliZ(i)\n\nproblem = [0]\n\ndef cost(param):\n    exp = qaoa_one_qubit(param, problem=problem)\n    return exp\n\nopt = qml.GradientDescentOptimizer(stepsize=0.01)\nsteps = 10000\nparam = [0.01]\n\nfor i in range(steps):\n    param = opt.step(cost, param)\n", "link": "https://discuss.pennylane.ai//t/passing-non-differentiable-arguments-to-qnode/135/6"}, "6": {"author": "mxn.wls", "date": "1558472144846", "content": "Ah thanks! Sorry, didn\u2019t understand first time. I\u2019ll try this out  as well.", "link": "https://discuss.pennylane.ai//t/passing-non-differentiable-arguments-to-qnode/135/7"}, "7": {"author": "mxn.wls", "date": "1558480611744", "content": "Unfortunately, I\u2019m still getting an error @josh.\nCode\n%reset -f\nimport pennylane as qml\nfrom pennylane import numpy as np\nimport os\nx = os.path.dirname(qml.file)\nprint(x)\nN = 2\ndev = qml.device(\u2018forest.numpy_wavefunction\u2019, wires=N)\n@qml.qnode(dev)\ndef qaoa_one_qubit(param, problem=None):\nprint(problem)\nprint('problem = ', [i.val for i in problem])\nfor i in problem:\nqml.RX(param[0], wires=i)\nreturn qml.expval.PauliZ(i)\nproblem = [0]\ndcircuit = qml.grad(qaoa_one_qubit, argnum=0)\ndcircuit([0.5], problem=problem)\nOut\n/home/maxiwelian/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane\n[<pennylane.variable.Variable object at 0x7fc90c519f60>]\nTypeError                                 Traceback (most recent call last)\n in \n21 problem = [0]\n22 dcircuit = qml.grad(qaoa_one_qubit, argnum=0)\n\u2014> 23 dcircuit([0.5], problem=problem)\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/wrap_util.py in nary_f(*args, **kwargs)\n18             else:\n19                 x = tuple(args[i] for i in argnum)\n\u2014> 20             return unary_operator(unary_f, x, *nary_op_args, **nary_op_kwargs)\n21         return nary_f\n22     return nary_operator\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/differential_operators.py in grad(fun, x)\n22     arguments as fun, but returns the gradient instead. The function fun\n23     should be scalar-valued. The gradient has the same type as the argument.\"\"\"\n\u2014> 24     vjp, ans = _make_vjp(fun, x)\n25     if not vspace(ans).size == 1:\n26         raise TypeError(\"Grad only applies to real scalar-output functions. \"\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/core.py in make_vjp(fun, x)\n8 def make_vjp(fun, x):\n9     start_node = VJPNode.new_root(x)\n\u2014> 10     end_value, end_node =  trace(start_node, fun, x)\n11     if end_node is None:\n12         def vjp(g): return vspace(x).zeros()\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/tracer.py in trace(start_node, fun, x)\n8     with trace_stack.new_trace() as t:\n9         start_box = new_box(x, t, start_node)\n\u2014> 10         end_box = fun(start_box)\n11         if isbox(end_box) and end_box._trace == start_box._trace:\n12             return end_box._value, end_box._node\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/wrap_util.py in unary_f(x)\n13                 else:\n14                     subargs = subvals(args, zip(argnum, x))\n\u2014> 15                 return fun(*subargs, **kwargs)\n16             if isinstance(argnum, int):\n17                 x = args[argnum]\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/decorator.py in wrapper(*args, **kwargs)\n151         def wrapper(*args, **kwargs):\n152             \u201c\u201d\u201cWrapper function\u201d\"\"\n\u2013> 153             return qnode(*args, **kwargs)\n154\n155         # bind the jacobian method to the wrapped function\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/qnode.py in call(self, *args, **kwargs)\n455         # pylint: disable=no-member\n456         args = autograd.builtins.tuple(args)  # prevents autograd boxed arguments from going through to evaluate\n\u2013> 457         return self.evaluate(args, **kwargs)  # args as one tuple\n458\n459     @ae.primitive\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/tracer.py in f_wrapped(*args, **kwargs)\n42             parents = tuple(box._node for _     , box in boxed_args)\n43             argnums = tuple(argnum    for argnum, _   in boxed_args)\n\u2014> 44             ans = f_wrapped(*argvals, **kwargs)\n45             node = node_constructor(ans, f_wrapped, argvals, kwargs, argnums, parents)\n46             return new_box(ans, trace, node)\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/tracer.py in f_wrapped(*args, **kwargs)\n46             return new_box(ans, trace, node)\n47         else:\n\u2014> 48             return f_raw(*args, **kwargs)\n49     f_wrapped.fun = f_raw\n50     f_wrapped._is_autograd_primitive = True\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/qnode.py in evaluate(self, args, **kwargs)\n469         if not self.ops:\n470             # construct the circuit\n\u2013> 471             self.construct(args, **kwargs)\n472\n473         # temporarily store keyword arguments\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/qnode.py in construct(self, args, **kwargs)\n296         # generate the program queue by executing the quantum circuit function\n297         try:\n\u2013> 298             res = self.func(*variables, **kwarg_variables)\n299         finally:\n300             # remove the context\n in qaoa_one_qubit(param, problem)\n14 def qaoa_one_qubit(param, problem=None):\n15     print(problem)\n\u2014> 16     print('problem = ', [i.val for i in problem])\n17     for i in problem:\n18         qml.RX(param[0], wires=i)\n in (.0)\n14 def qaoa_one_qubit(param, problem=None):\n15     print(problem)\n\u2014> 16     print('problem = ', [i.val for i in problem])\n17     for i in problem:\n18         qml.RX(param[0], wires=i)\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/variable.py in val(self)\n144\n145         # The variable is a placeholder for a keyword argument\n\u2013> 146         if isinstance(self.kwarg_values[self.name], (Sequence, np.ndarray)):\n147             return self.kwarg_values[self.name][self.idx] * self.mult\n148\nTypeError: \u2018NoneType\u2019 object is not subscriptable\nfunc @ line 373\n@property\ndef wires(self):\n    \"\"\"Current wire values.\n\n    Fixed wires are returned as is, free wires represented by\n    :class:`~.variable.Variable` instances are replaced by their\n    current numerical value.\n\n    Returns:\n        list[int]: wire values\n    \"\"\"\n    w = [i.val if isinstance(i, Variable) else i for i in self._wires]\n    self.check_wires(w)\n    return [int(i) for i in w]\n\nUninstall & reinstall pennylane\npip uninstall pennylane\npython setup.py install\nNotes\nI created a new conda environment installed pennylane by python setup.py install from pennylane folder (with new operations file). Same error as above1 Reply", "link": "https://discuss.pennylane.ai//t/passing-non-differentiable-arguments-to-qnode/135/8"}, "8": {"author": "mxn.wls", "date": "1558485020384", "content": "Hey @kareem is this what you had in mind?\nThought we had it working for a second there\u2026 I\u2019ve done a bunch of tests, its a Variable, and when I try and access it with .val it thinks it is None.\nI want to iterate over \u2018terms\u2019 in a list of list, perform some operations on the elements of those terms, and adapt the gates of the circuit based on that. Seems like it should be able to be done but proving more difficult than anticipated.\nCode\nimport pennylane as qml\nimport torch\nfrom torch.autograd import Variable\ndev = qml.device(\u2018forest.numpy_wavefunction\u2019, wires=2)\n@qml.qnode(dev, interface=\u2018torch\u2019)\ndef circuit(phi, theta, problem):\n    x = [i.val for i in problem]\n    qml.RX(theta, wires=0)\n    qml.RZ(phi, wires=0)\n    return qml.expval.PauliZ(0)\ndef cost(phi, theta, problem, step):\n    target = -(-1)**(step // 100)\n    return torch.abs(circuit(phi, theta, problem) - target)**2\nphi = Variable(torch.tensor(1., device=\u2018cuda\u2019), requires_grad=True)\ntheta = Variable(torch.tensor(0.05, device=\u2018cuda\u2019), requires_grad=True)\nproblem_var = Variable(torch.tensor([1,2], device=\u2018cuda\u2019), requires_grad=False)\nopt = torch.optim.Adam([phi, theta], lr = 0.1)\nfor i in range(10):\n    opt.zero_grad()\n    loss = cost(phi, theta, problem_var, i)\n    loss.backward()\n    opt.step()\nprint(\u2018fin\u2019)\nError\nTraceback (most recent call last):\nFile \u201c/home/maxiwelian/projects/vqa_optimisation/qiskit_pennylane/test/pytorch_iterable_test/1.py\u201d, line 27, in \nloss = cost(phi, theta, problem_var, i)\nFile \u201c/home/maxiwelian/projects/vqa_optimisation/qiskit_pennylane/test/pytorch_iterable_test/1.py\u201d, line 17, in cost\nreturn torch.abs(circuit(phi, theta, problem) - target)**2\nFile \u201c/home/maxiwelian/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/interfaces/torch.py\u201d, line 390, in custom_apply\nFile \u201c/home/maxiwelian/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/interfaces/torch.py\u201d, line 307, in forward\nFile \u201c/home/maxiwelian/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/qnode.py\u201d, line 457, in call\nFile \u201c/home/maxiwelian/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/tracer.py\u201d, line 48, in f_wrapped\nreturn f_raw(*args, **kwargs)\nFile \u201c/home/maxiwelian/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/qnode.py\u201d, line 471, in evaluate\nFile \u201c/home/maxiwelian/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/qnode.py\u201d, line 298, in construct\nFile \u201c/home/maxiwelian/projects/vqa_optimisation/qiskit_pennylane/test/pytorch_iterable_test/1.py\u201d, line 10, in circuit\nx = [i.val for i in problem]\nFile \u201c/home/maxiwelian/projects/vqa_optimisation/qiskit_pennylane/test/pytorch_iterable_test/1.py\u201d, line 10, in \nx = [i.val for i in problem]\nFile \u201c/home/maxiwelian/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/variable.py\u201d, line 143, in val\nTypeError: \u2018NoneType\u2019 object is not subscriptable", "link": "https://discuss.pennylane.ai//t/passing-non-differentiable-arguments-to-qnode/135/9"}, "9": {"author": "josh", "date": "1558489691429", "content": "\n\n\n mxn.wls:\n\nUnfortunately, I\u2019m still getting an error @josh.\n\n\nHey @mxn.wls, I played around with your example, and I get the same error message. However, it works if I remove the print statements inside the QNode:\nimport pennylane as qml\nfrom pennylane import numpy as np\n\nN = 2\ndev = qml.device('forest.numpy_wavefunction', wires=N)\n\n@qml.qnode(dev)\ndef qaoa_one_qubit(param, problem=None):\n    for i in problem:\n        qml.RX(param[0], wires=i)\n    return qml.expval.PauliZ(i)\n\nproblem = [0]\ndcircuit = qml.grad(qaoa_one_qubit, argnum=0)\nprint(dcircuit([0.5], problem=problem))\n\nI\u2019ll look into why the print statements cause this error, in the meantime, can you verify that the above (without the print statements) works?", "link": "https://discuss.pennylane.ai//t/passing-non-differentiable-arguments-to-qnode/135/10"}, "10": {"author": "josh", "date": "1558490621108", "content": "The following bug fix allows the print statement inside the QNode to work \nBut, there is a caveat. The way PennyLane is coded, the original function is only ever executed once. The QNode compiles the quantum functions after the first execution, and uses the compiled result from then on.\nSo while the below will allow the print function to work, it will only ever print output the first time the QNode is called.\ndiff --git a/pennylane/qnode.py b/pennylane/qnode.py\nindex 6160e8e..2929121 100644\n--- a/pennylane/qnode.py\n+++ b/pennylane/qnode.py\n@@ -288,6 +288,10 @@ class QNode:\n             temp = [Variable(idx, name=key) for idx, _ in enumerate(_flatten(val))]\n             kwarg_variables[key] = unflatten(temp, val)\n \n+        # temporarily store the free parameter values in the Variable class\n+        Variable.free_param_values = np.array(list(_flatten(args)))\n+        Variable.kwarg_values = keyword_values\n+\n         # set up the context for Operation entry\n         if QNode._current_context is None:\n             QNode._current_context = self\n", "link": "https://discuss.pennylane.ai//t/passing-non-differentiable-arguments-to-qnode/135/11"}, "11": {"author": "mxn.wls", "date": "1558547151443", "content": "Hey, awesome this is great thanks. I think there is a bug here also. Would you like me to submit as bug in github?\nThe issue is indexing of the keyword arguments and there is a workaround that currently doesn\u2019t make sense (to me). The function seems to think that both variables are stored in the first index of the term, and that the second index doesn\u2019t exist.\nIssue Code\n%reset -f\nimport pennylane as qml\nfrom pennylane import numpy as np\nN = 2\ndev = qml.device('forest.numpy_wavefunction', wires=N)\n\ndef sign_qubit(term): # s denotes the sign and a and b refer to the idx. Minus 1 from idx to return to standard indexing\nprint(term)\nprint(term[0].val)\nprint(term[1].val)\na = np.abs(term[0].val) - 1\nb = np.abs(term[1].val) - 1\nsa = np.sign(term[0].val)\nsb = np.sign(term[1].val)\nreturn sa, a, sb, b\n\ndef function(param, problem=None):\nfor term in problem:\n    sa, a ,sb, b = sign_qubit(term)\n    qml.RZ(sa*param[0], wires=a)\n    qml.RZ(sb*param[0], wires=b)\n\n@qml.qnode(dev)\ndef qaoa_one_qubit(param, problem=None):\nfunction(param, problem=problem)\nreturn qml.expval.PauliZ(i)\n\nproblem_val = [[1,2]] # renaming to val is ok\n\ndef cost(param):\nexp = qaoa_one_qubit(param, problem=problem_val)\nreturn exp\n\nopt = qml.GradientDescentOptimizer(stepsize=0.01)\nsteps = 10\nparam = [0.01]\n\nfor i in range(steps):\nparam = opt.step(cost, param)\nprint(i)\n\nOutput\n[<pennylane.variable.Variable object at 0x7f8ca38cde80>, <pennylane.variable.Variable object at 0x7f8ca3850630>]\n[1, 2]\nIndexError                                Traceback (most recent call last)\n in \n37\n38 for i in range(steps):\n\u2014> 39     param = opt.step(cost, param)\n40     print(i)\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/optimize/gradient_descent.py in step(self, objective_fn, x, grad_fn)\n61         \u201c\u201d\"\n62\n\u2014> 63         g = self.compute_grad(objective_fn, x, grad_fn=grad_fn)\n64\n65         x_out = self.apply_grad(g, x)\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/optimize/gradient_descent.py in compute_grad(objective_fn, x, grad_fn)\n85         else:\n86             # default is autograd\n\u2014> 87             g = autograd.grad(objective_fn)(x)  # pylint: disable=no-value-for-parameter\n88         return g\n89\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/wrap_util.py in nary_f(*args, **kwargs)\n18             else:\n19                 x = tuple(args[i] for i in argnum)\n\u2014> 20             return unary_operator(unary_f, x, *nary_op_args, **nary_op_kwargs)\n21         return nary_f\n22     return nary_operator\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/differential_operators.py in grad(fun, x)\n22     arguments as fun, but returns the gradient instead. The function fun\n23     should be scalar-valued. The gradient has the same type as the argument.\"\"\"\n\u2014> 24     vjp, ans = _make_vjp(fun, x)\n25     if not vspace(ans).size == 1:\n26         raise TypeError(\"Grad only applies to real scalar-output functions. \"\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/core.py in make_vjp(fun, x)\n8 def make_vjp(fun, x):\n9     start_node = VJPNode.new_root(x)\n\u2014> 10     end_value, end_node =  trace(start_node, fun, x)\n11     if end_node is None:\n12         def vjp(g): return vspace(x).zeros()\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/tracer.py in trace(start_node, fun, x)\n8     with trace_stack.new_trace() as t:\n9         start_box = new_box(x, t, start_node)\n\u2014> 10         end_box = fun(start_box)\n11         if isbox(end_box) and end_box._trace == start_box._trace:\n12             return end_box._value, end_box._node\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/wrap_util.py in unary_f(x)\n13                 else:\n14                     subargs = subvals(args, zip(argnum, x))\n\u2014> 15                 return fun(*subargs, **kwargs)\n16             if isinstance(argnum, int):\n17                 x = args[argnum]\n in cost(param)\n29\n30 def cost(param):\n\u2014> 31     exp = qaoa_one_qubit(param, problem=problem_val)\n32     return exp\n33\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/decorator.py in wrapper(*args, **kwargs)\n151         def wrapper(*args, **kwargs):\n152             \u201c\u201d\u201cWrapper function\u201d\"\"\n\u2013> 153             return qnode(*args, **kwargs)\n154\n155         # bind the jacobian method to the wrapped function\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/qnode.py in call(self, *args, **kwargs)\n459         # pylint: disable=no-member\n460         args = autograd.builtins.tuple(args)  # prevents autograd boxed arguments from going through to evaluate\n\u2013> 461         return self.evaluate(args, **kwargs)  # args as one tuple\n462\n463     @ae.primitive\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/tracer.py in f_wrapped(*args, **kwargs)\n42             parents = tuple(box._node for _     , box in boxed_args)\n43             argnums = tuple(argnum    for argnum, _   in boxed_args)\n\u2014> 44             ans = f_wrapped(*argvals, **kwargs)\n45             node = node_constructor(ans, f_wrapped, argvals, kwargs, argnums, parents)\n46             return new_box(ans, trace, node)\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/autograd-1.2-py3.6.egg/autograd/tracer.py in f_wrapped(*args, **kwargs)\n46             return new_box(ans, trace, node)\n47         else:\n\u2014> 48             return f_raw(*args, **kwargs)\n49     f_wrapped.fun = f_raw\n50     f_wrapped._is_autograd_primitive = True\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/qnode.py in evaluate(self, args, **kwargs)\n473         if not self.ops:\n474             # construct the circuit\n\u2013> 475             self.construct(args, **kwargs)\n476\n477         # temporarily store keyword arguments\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/qnode.py in construct(self, args, **kwargs)\n300         # generate the program queue by executing the quantum circuit function\n301         try:\n\u2013> 302             res = self.func(*variables, **kwarg_variables)\n303         finally:\n304             # remove the context\n in qaoa_one_qubit(param, problem)\n23 @qml.qnode(dev)\n24 def qaoa_one_qubit(param, problem=None):\n\u2014> 25     function(param, problem=problem)\n26     return qml.expval.PauliZ(i)\n27\n in function(param, problem)\n17 def function(param, problem=None):\n18     for term in problem:\n\u2014> 19         sa, a ,sb, b = sign_qubit(term)\n20         qml.RZ(saparam[0], wires=a)\n21         qml.RZ(sbparam[0], wires=b)\n in sign_qubit(term)\n8     print(term)\n9     print(term[0].val)\n\u2014> 10     print(term[1].val)\n11     a = np.abs(term[0].val) - 1\n12     b = np.abs(term[1].val) - 1\n~/anaconda3/envs/vqa/lib/python3.6/site-packages/PennyLane-0.3.1-py3.6.egg/pennylane/variable.py in val(self)\n145         # The variable is a placeholder for a keyword argument\n146         if isinstance(self.kwarg_values[self.name], (Sequence, np.ndarray)):\n\u2013> 147             return self.kwarg_values[self.name][self.idx] * self.mult\n148\n149         return self.kwarg_values[self.name] * self.mult\nIndexError: list index out of range\nNotes\nSeems to be that the it thinks both variables are stored in the first part of the list, so the workaround would be to index after .val call like this\nEx 2\n%reset -f\nimport pennylane as qml\nfrom pennylane import numpy as np\nN = 2\ndev = qml.device(\u2018forest.numpy_wavefunction\u2019, wires=N)\ndef sign_qubit(term): # s denotes the sign and a and b refer to the idx. Minus 1 from idx to return to standard indexing\nprint(term)\nprint(term[0].val)\nprint('term_1: ', term[0].val[0])\nprint('term_2: ', term[0].val[1])\nt1 = term[0].val[0]\nt2 = term[0].val[1]\na = np.abs(t1) - 1\nb = np.abs(t2) - 1\nsa = np.sign(t1)\nsb = np.sign(t2)\nreturn sa, a, sb, b\ndef function(param, problem=None):\nfor term in problem:\nsa, a ,sb, b = sign_qubit(term)\nqml.RZ(saparam[0], wires=a)\nqml.RZ(sbparam[0], wires=b)\n@qml.qnode(dev)\ndef qaoa_one_qubit(param, problem=None):\nfunction(param, problem=problem)\nreturn qml.expval.PauliZ(i)\nproblem_val = [[1,2]] # renaming to val is ok\ndef cost(param):\nexp = qaoa_one_qubit(param, problem=problem_val)\nreturn exp\nopt = qml.GradientDescentOptimizer(stepsize=0.01)\nsteps = 10\nparam = [0.01]\nfor i in range(steps):\nparam = opt.step(cost, param)\nprint(i)\nOutput (which works)\n[<pennylane.variable.Variable object at 0x7f8ca38cdef0>, <pennylane.variable.Variable object at 0x7f8ca38cd518>]\n[1, 2]\nterm_1: 1\nterm_2: 2\n0 1 2 3 4 5 6 7 8 9\nSidenote: Thanks for the great support & work on pennylane. If we meet I owe you one v. big beer.\nMax1", "link": "https://discuss.pennylane.ai//t/passing-non-differentiable-arguments-to-qnode/135/12"}, "12": {"author": "josh", "date": "1558555109348", "content": "Ah, you\u2019ve uncovered a bug/edge case in my previous bug fix! I played around with it, and it looks like my previous bugfix only worked for flat lists (not nested lists).\nThe following change to my previous bugfix fixes this:\ndiff --git a/pennylane/qnode.py b/pennylane/qnode.py\nindex 6160e8e..7facaab 100644\n--- a/pennylane/qnode.py\n+++ b/pennylane/qnode.py\n@@ -288,6 +288,9 @@ class QNode:\n             temp = [Variable(idx, name=key) for idx, _ in enumerate(_flatten(val))]\n             kwarg_variables[key] = unflatten(temp, val)\n \n         Variable.free_param_values = np.array(list(_flatten(args)))\n-        Variable.kwarg_values = keyword_values\n+        Variable.kwarg_values = {k: np.array(list(_flatten(v))) for k, v in keyword_values.items()}\n\n         # set up the context for Operation entry\n         if QNode._current_context is None:\n             QNode._current_context = self\n\nThanks for following up on this @mxn.wls, this is a massive help to ensure we fix/remove as many bugs as we can in PennyLane! \n\nThe following script now runs for me:\nimport pennylane as qml\nfrom pennylane import numpy as np\nN = 2\ndev = qml.device('forest.numpy_wavefunction', wires=N)\n\ndef sign_qubit(term):\n    # s denotes the sign and a and b refer to the idx. Minus 1\n    # from idx to return to standard indexing\n    print(term)\n    print('first term:', term[0].val)\n    print('second term:', term[1].val)\n    a = np.abs(term[0].val) - 1\n    b = np.abs(term[1].val) - 1\n    sa = np.sign(term[0].val)\n    sb = np.sign(term[1].val)\n    return sa, a, sb, b\n\ndef function(param, problem=None):\n    for term in problem:\n        sa, a, sb, b = sign_qubit(term)\n        qml.RZ(sa*param[0], wires=a)\n        qml.RZ(sb*param[0], wires=b)\n\n@qml.qnode(dev)\ndef qaoa_one_qubit(param, problem=None):\n    function(param, problem=problem)\n    return qml.expval.PauliZ(i)\n\nproblem_val = [[1, 2]] # renaming to val is ok\n\ndef cost(param):\n    exp = qaoa_one_qubit(param, problem=problem_val)\n    return exp\n\nopt = qml.GradientDescentOptimizer(stepsize=0.01)\nsteps = 10\nparam = [0.01]\n\nfor i in range(steps):\n    param = opt.step(cost, param)\n    print(i)\n\nAnd gives the following output:\n[<pennylane.variable.Variable object at 0x7fcc6d0b9860>, <pennylane.variable.Variable object at 0x7fcc6d0b98d0>]\nfirst term: 1\nsecond term: 2\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\nUpdate: PR available here: https://github.com/XanaduAI/pennylane/pull/209 2", "link": "https://discuss.pennylane.ai//t/passing-non-differentiable-arguments-to-qnode/135/13"}, "13": {"author": "SreeramV181", "date": "1559934545543", "content": "\n\n\n josh:\n\nTurns off QNode caching by default and makes variable values available during construction by josh146 \u00b7 Pull Request #209 \u00b7 PennyLaneAI/pennylane \u00b7 GitHub\n\n\nHow do I install this on my command line?", "link": "https://discuss.pennylane.ai//t/passing-non-differentiable-arguments-to-qnode/135/14"}}