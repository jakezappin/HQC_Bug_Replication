{"0": {"author": "PatrickHuembeli", "date": "1635776966394", "content": "Hi there,\nI would like to do the following: (with the code below the problem can be reproduced). I have a circuit with a certain binary input X that creates an initial state, followed by some arbitrary circuit from which I sample in the Z basis. In JAX I can use the vmap function so I can input a whole batch X_batch of X and compute the sampling for each X at the same time\nThe problem is, if X_batch contains the same X several times, I sample exactly the same outputs for each of them.\nI am not sure if this is a bug or a feature, but I would like the sampling to be random also if the inputs are the same. Is there any way of telling vmap to keep the samples random?\nWith the following code, the problem can be reproduced\nimport pennylane as qml\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\n\ndev = qml.device('default.qubit.jax', wires=4, shots = 100)\n\n@jax.jit  # QNode calls will now be jitted, and should run faster.\n@qml.qnode(dev, interface='jax')\ndef qnode(params, inputs):\n    layers, qubits, _ = params.shape\n    for i in range(qubits):\n        qml.RX(jnp.pi/2*inputs[i], wires=i)\n    qml.templates.layers.StronglyEntanglingLayers(params, wires=range(4))\n    return [qml.sample(qml.PauliZ(i)) for i in range(qubits)]\n\nparams_shape = (4, 4, 3)\n\nkey = jax.random.PRNGKey(1)\nkey, subkey = jax.random.split(key)\nparams = jax.random.uniform(subkey, params_shape)\n\nqnode_vmap = jax.vmap(qnode, in_axes=(None, 0), out_axes=0)\n\nX_in = np.zeros((3, 4)) # a batch of 3 inputs X\nX_in[2][0] = 1. # change the 3rd X\nX_in[2][1] = 1.\nY_vmap = qnode_vmap(params, X_in)\n\n\nY_vmap_T = jnp.transpose(Y_vmap, axes=(0,2,1))\n\ncompare = (jnp.isclose(Y_vmap_T[0], Y_vmap_T[1])*1).mean()\n\nOne can see the compare = 1. which means that all the 1000 samples for input X_batch[0] and X_batch[1] are identical. But I would like to have individual samples for each input.\nIs this somehow possible?", "link": "https://discuss.pennylane.ai//t/sampling-with-jax-and-vmap-not-random-anymore/1451/1"}, "1": {"author": "josh", "date": "1635787955765", "content": "Hi @PatrickHuembeli! I unfortunately don\u2019t have that much experience with JAX\u2019s jit and vmap, but I\u2019m curious if the approach taking in the following demo,\n\n\n\npennylane.ai\n\n\n\nUsing JAX with PennyLane \u2014 PennyLane 9\nLearn how to use JAX with PennyLane.\n\n\n\n\n\nnamely, defining the device and the QNode inside the jitted function, will solve the problem in your case?", "link": "https://discuss.pennylane.ai//t/sampling-with-jax-and-vmap-not-random-anymore/1451/2"}, "2": {"author": "PatrickHuembeli", "date": "1635839898699", "content": "Hi @josh, thanks for the reply. It gave me the last hint that was necessary. This solution is for a single executions of the sampling, but I figured out how to do the vmapping with random keys. To do so, you define the circuit as described in the link that you added. I slightly modified it and added an input x_in to use it with vmap later:\n@jax.jit\ndef circuit(param, x_in, key):\n    # Notice how the device construction now happens within the jitted method.\n    # Also note the added '.jax' to the device path.\n    dev = qml.device(\"default.qubit.jax\", wires=2, shots=10, prng_key=key)\n\n    # Now we can create our qnode within the circuit function.\n    @qml.qnode(dev, interface=\"jax\", diff_method=None)\n    def my_circuit():\n        qml.RY(x_in*np.pi, wires =0)\n        qml.RX(param, wires=0)\n        qml.CNOT(wires=[0, 1])\n        return qml.sample(qml.PauliZ(0))\n    return my_circuit()\n\nkey1 = jax.random.PRNGKey(0)\n\nNormally I would do the vmapping as follows, with in_axes = (None, 0, None). Which means I only expect x_in to come as a batch. The \u201ctrick\u201d is, that you have to provide a separate key for each x_in\ncircuit_vmap = jax.vmap(circuit , in_axes=(None, 0, 0), out_axes=0)\n\nTo run now the vmapped circuit for a X_batch with dimension (batch_size, 1) for this example one needs to generate also batch_size keys.\nsubkeys = jax.random.split(key, batch_size)\n\nAnd run the circuit with:\n circuit_vmap(params, X_batch, subkeys)1", "link": "https://discuss.pennylane.ai//t/sampling-with-jax-and-vmap-not-random-anymore/1451/3"}, "3": {"author": "josh", "date": "1635840603019", "content": "Glad you got it working @PatrickHuembeli! And thanks for posting your solution, this will be helpful for anyone with the same problem (and me as well )", "link": "https://discuss.pennylane.ai//t/sampling-with-jax-and-vmap-not-random-anymore/1451/4"}, "4": {"author": "PatrickHuembeli", "date": "1635776966394", "content": "Hi there,\nI would like to do the following: (with the code below the problem can be reproduced). I have a circuit with a certain binary input X that creates an initial state, followed by some arbitrary circuit from which I sample in the Z basis. In JAX I can use the vmap function so I can input a whole batch X_batch of X and compute the sampling for each X at the same time\nThe problem is, if X_batch contains the same X several times, I sample exactly the same outputs for each of them.\nI am not sure if this is a bug or a feature, but I would like the sampling to be random also if the inputs are the same. Is there any way of telling vmap to keep the samples random?\nWith the following code, the problem can be reproduced\nimport pennylane as qml\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\n\ndev = qml.device('default.qubit.jax', wires=4, shots = 100)\n\n@jax.jit  # QNode calls will now be jitted, and should run faster.\n@qml.qnode(dev, interface='jax')\ndef qnode(params, inputs):\n    layers, qubits, _ = params.shape\n    for i in range(qubits):\n        qml.RX(jnp.pi/2*inputs[i], wires=i)\n    qml.templates.layers.StronglyEntanglingLayers(params, wires=range(4))\n    return [qml.sample(qml.PauliZ(i)) for i in range(qubits)]\n\nparams_shape = (4, 4, 3)\n\nkey = jax.random.PRNGKey(1)\nkey, subkey = jax.random.split(key)\nparams = jax.random.uniform(subkey, params_shape)\n\nqnode_vmap = jax.vmap(qnode, in_axes=(None, 0), out_axes=0)\n\nX_in = np.zeros((3, 4)) # a batch of 3 inputs X\nX_in[2][0] = 1. # change the 3rd X\nX_in[2][1] = 1.\nY_vmap = qnode_vmap(params, X_in)\n\n\nY_vmap_T = jnp.transpose(Y_vmap, axes=(0,2,1))\n\ncompare = (jnp.isclose(Y_vmap_T[0], Y_vmap_T[1])*1).mean()\n\nOne can see the compare = 1. which means that all the 1000 samples for input X_batch[0] and X_batch[1] are identical. But I would like to have individual samples for each input.\nIs this somehow possible?", "link": "https://discuss.pennylane.ai//t/sampling-with-jax-and-vmap-not-random-anymore/1451/5"}}